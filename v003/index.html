<!DOCTYPE html>
<html>
<head>
    <title>NeverEverLand v003 - ECS Demo</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="container">
        <div id="ui">
            <div id="ui-header">
                <h3>🎮 ECS Engine Demo</h3>
                <span style="font-size: 10px; color: #888;"><i data-lucide="move" style="width: 12px; height: 12px;"></i> Drag to move</span>
            </div>
            <p>Entity Component System in action</p>
            
            <div id="selectionInfo" style="margin: 5px 0; font-size: 11px; color: #888;">
Click an entity to select it. Click components to toggle on/off.
            </div>
            
            <div>
                <button onclick="queryEntities()">Query Test</button>
                <button onclick="stressTest()">Stress Test</button>
            </div>
            
            
            
            <div id="status">
                <div>Entities: <span id="entityCount">0</span></div>
                <div>Components: <span id="componentCount">0</span></div>
                <div>Systems: <span id="systemCount">4</span></div>
                <div>Queries: <span id="queryCount">0</span></div>
                <div>Performance: <span id="performance">--</span></div>
            </div>
            
            <div style="margin-top: 10px; font-size: 10px; color: #888;">
                <strong>ECS Architecture:</strong><br>
                • Entities are just IDs<br>
                • Components hold data<br>
                • Systems process components<br>
                • Queries find entities by components<br><br>
                <strong style="color: #4CAF50;">🚀 Physics & Animation Components Available!</strong><br>
                Use the + button in the inspector to add any component!
            </div>
        </div>
        
        <div id="inspector">
            <div id="inspector-header">
                <span><i data-lucide="search" style="width: 16px; height: 16px; vertical-align: text-bottom;"></i> Component Inspector</span>
                <span style="font-size: 10px; color: #888;"><i data-lucide="move" style="width: 12px; height: 12px;"></i> Drag to move • <i data-lucide="maximize-2" style="width: 12px; height: 12px;"></i> Resize corner</span>
            </div>
            <div id="inspector-content">
                <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                    <button onclick="createEntity()" style="flex: 1; padding: 8px; background: #4CAF50; color: white; border: none; border-radius: 3px; cursor: pointer; font-family: monospace; display: flex; align-items: center; justify-content: center; gap: 5px;"><i data-lucide="plus" style="width: 16px; height: 16px;"></i> Create Entity</button>
                    <button onclick="clearAll()" style="padding: 8px 12px; background: #F44336; color: white; border: none; border-radius: 3px; cursor: pointer; font-family: monospace; display: flex; align-items: center; justify-content: center; gap: 5px;"><i data-lucide="trash-2" style="width: 16px; height: 16px;"></i> Clear All</button>
                </div>
                <div id="entityList"></div>
            </div>
        </div>
    </div>

    <script src="./three.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    
    <script>
        // Simple ECS Implementation
        class Entity {
            static nextId = 1;
            constructor() {
                this.id = Entity.nextId++;
                this.components = new Map();
                this.active = true;
            }
            
            addComponent(component) {
                this.components.set(component.constructor.name, component);
                return this;
            }
            
            removeComponent(componentType) {
                this.components.delete(componentType);
                return this;
            }
            
            getComponent(componentType) {
                return this.components.get(componentType);
            }
            
            hasComponent(componentType) {
                return this.components.has(componentType);
            }
        }
        
        // Components (data only)
        class Transform {
            constructor(x = 0, y = 0, z = 0) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.rotation = { x: 0, y: 0, z: 0 };
                this.scale = { x: 1, y: 1, z: 1 };
            }
        }
        
        class Renderable {
            constructor(mesh) {
                this.mesh = mesh;
                this.visible = true;
            }
        }
        
        class Movement {
            constructor() {
                this.velocity = { x: 0, y: 0, z: 0 };
                this.speed = Math.random() * 2 + 1;
            }
        }
        
        class Health {
            constructor() {
                this.current = 100;
                this.max = 100;
            }
        }
        
        class Lifetime {
            constructor(duration = 5) {
                this.remaining = duration;
            }
        }
        
        class VisualComponent {
            constructor() {
                this.wireframe = false;
                this.wireframeColor = 0x00ff00;
                this.vertexColors = false;
                this.pointsMode = false;
                this.pointSize = 3;
                this.pointColor = 0xff0000;
                this.opacity = 1.0;
                this.transparent = false;
                this.emissive = 0x000000;
                this.emissiveIntensity = 0.5;
                this.flatShading = false;
                this.doubleSided = false;
                this.visible = true;
            }
        }
        
        // Visual System to apply VisualComponent settings
        class VisualSystem {
            update(entities, deltaTime) {
                entities.forEach(entity => {
                    const visual = entity.getComponent('VisualComponent');
                    const renderable = entity.getComponent('Renderable');
                    
                    if (visual && visual.active !== false && renderable && renderable.mesh) {
                        const mesh = renderable.mesh;
                        
                        // Apply visual properties
                        mesh.material.wireframe = visual.wireframe;
                        mesh.material.transparent = visual.transparent;
                        mesh.material.opacity = visual.opacity;
                        mesh.material.emissive.setHex(visual.emissive);
                        mesh.material.side = visual.doubleSided ? THREE.DoubleSide : THREE.FrontSide;
                        mesh.visible = visual.visible;
                        
                        // Handle points mode (requires material change)
                        if (visual.pointsMode && !mesh.userData.isPointsMaterial) {
                            const pointsMaterial = new THREE.PointsMaterial({ 
                                color: visual.pointColor,
                                size: visual.pointSize
                            });
                            const points = new THREE.Points(mesh.geometry, pointsMaterial);
                            points.position.copy(mesh.position);
                            points.rotation.copy(mesh.rotation);
                            points.scale.copy(mesh.scale);
                            
                            // Replace mesh with points temporarily
                            mesh.parent.add(points);
                            mesh.visible = false;
                            mesh.userData.pointsHelper = points;
                            mesh.userData.isPointsMaterial = true;
                        } else if (!visual.pointsMode && mesh.userData.pointsHelper) {
                            // Remove points and show original mesh
                            mesh.parent.remove(mesh.userData.pointsHelper);
                            mesh.userData.pointsHelper.geometry.dispose();
                            mesh.userData.pointsHelper.material.dispose();
                            delete mesh.userData.pointsHelper;
                            delete mesh.userData.isPointsMaterial;
                            mesh.visible = visual.visible;
                        }
                        
                        // Mark material as needing update
                        mesh.material.needsUpdate = true;
                    }
                });
            }
        }
        
        // Systems (logic only)
        class MovementSystem {
            update(entities, deltaTime) {
                entities.forEach(entity => {
                    const transform = entity.getComponent('Transform');
                    const movement = entity.getComponent('Movement');
                    
                    // Only update if both components exist and both are active
                    if (transform && transform.active !== false && movement && movement.active !== false) {
                        // Update position based on velocity
                        transform.x += movement.velocity.x * deltaTime;
                        transform.y += movement.velocity.y * deltaTime;
                        transform.z += movement.velocity.z * deltaTime;
                        
                        // Bounce off boundaries
                        if (Math.abs(transform.x) > 10) movement.velocity.x *= -1;
                        if (Math.abs(transform.z) > 10) movement.velocity.z *= -1;
                        if (transform.y < 0.5) movement.velocity.y = Math.abs(movement.velocity.y);
                        if (transform.y > 5) movement.velocity.y = -Math.abs(movement.velocity.y);
                        
                        // Update 3D mesh position
                        const renderable = entity.getComponent('Renderable');
                        if (renderable && renderable.mesh) {
                            renderable.mesh.position.set(transform.x, transform.y, transform.z);
                        }
                    }
                });
            }
        }
        
        class RenderSystem {
            update(entities) {
                entities.forEach(entity => {
                    const transform = entity.getComponent('Transform');
                    const renderable = entity.getComponent('Renderable');
                    
                    if (transform && transform.active !== false && renderable && renderable.mesh) {
                        // Update mesh transform
                        renderable.mesh.position.set(transform.x, transform.y, transform.z);
                        renderable.mesh.rotation.set(transform.rotation.x, transform.rotation.y, transform.rotation.z);
                        renderable.mesh.scale.set(transform.scale.x, transform.scale.y, transform.scale.z);
                        renderable.mesh.visible = renderable.visible;
                    }
                });
            }
        }
        
        class LifetimeSystem {
            update(entities, deltaTime) {
                const toDestroy = [];
                entities.forEach(entity => {
                    const lifetime = entity.getComponent('Lifetime');
                    if (lifetime && lifetime.active !== false) {
                        lifetime.remaining -= deltaTime;
                        if (lifetime.remaining <= 0) {
                            toDestroy.push(entity);
                        }
                    }
                });
                
                toDestroy.forEach(entity => {
                    // Clear selection if this entity is currently selected
                    if (selectedEntity && selectedEntity.id === entity.id) {
                        selectEntity(null);
                    }
                    world.destroyEntity(entity);
                });
                
                // Force inspector update if entities were destroyed
                if (toDestroy.length > 0) {
                    updateInspector();
                    updateStatus();
                }
            }
        }
        
        class HealthSystem {
            update(entities, deltaTime) {
                entities.forEach(entity => {
                    const health = entity.getComponent('Health');
                    const renderable = entity.getComponent('Renderable');
                    
                    if (health && health.active !== false && renderable && renderable.mesh) {
                        // Color based on health
                        const healthPercent = health.current / health.max;
                        if (healthPercent > 0.5) {
                            renderable.mesh.material.color.setHex(0x4CAF50); // Green
                        } else if (healthPercent > 0.2) {
                            renderable.mesh.material.color.setHex(0xFFEB3B); // Yellow
                        } else {
                            renderable.mesh.material.color.setHex(0xF44336); // Red
                        }
                        
                        // Slowly lose health
                        health.current = Math.max(0, health.current - deltaTime * 5);
                    }
                });
            }
        }
        
        // World (ECS coordinator)
        class World {
            constructor() {
                this.entities = [];
                this.systems = [
                    new MovementSystem(),
                    new VisualSystem(),
                    new RenderSystem(),
                    new LifetimeSystem(),
                    new HealthSystem()
                ];
                this.queryCache = new Map();
            }
            
            createEntity() {
                const entity = new Entity();
                this.entities.push(entity);
                this.clearQueryCache();
                return entity;
            }
            
            destroyEntity(entity) {
                // Remove from scene if it has a mesh
                const renderable = entity.getComponent('Renderable');
                if (renderable && renderable.mesh) {
                    scene.remove(renderable.mesh);
                }
                
                // Clean up all visualization helpers
                removeColliderVisualization(entity);
                
                // Clear selection if this entity is currently selected
                if (selectedEntity && selectedEntity.id === entity.id) {
                    selectEntity(null);
                }
                
                const index = this.entities.indexOf(entity);
                if (index > -1) {
                    this.entities.splice(index, 1);
                }
                this.clearQueryCache();
            }
            
            query(componentTypes) {
                const key = componentTypes.sort().join(',');
                if (this.queryCache.has(key)) {
                    return this.queryCache.get(key);
                }
                
                const result = this.entities.filter(entity => 
                    componentTypes.every(type => entity.hasComponent(type))
                );
                
                this.queryCache.set(key, result);
                return result;
            }
            
            clearQueryCache() {
                this.queryCache.clear();
            }
            
            update(deltaTime) {
                this.systems.forEach(system => {
                    system.update(this.entities, deltaTime);
                });
            }
            
            getStats() {
                let componentCount = 0;
                this.entities.forEach(entity => {
                    componentCount += entity.components.size;
                });
                
                return {
                    entities: this.entities.length,
                    components: componentCount,
                    systems: this.systems.length,
                    queries: this.queryCache.size
                };
            }
        }
        
        // === Phase 3 Components ===
        class PartyComponent {
            constructor() {
                this.members = []; // Array of entity IDs
                this.activeLeader = 0; // Index of current leader
                this.maxSize = 3;
                this.formation = 'line'; // 'line', 'triangle', 'column'
                this.spacing = 2.0; // Distance between party members
                this.followDistance = 1.5; // How close followers stay to leader
                this.active = true;
            }
            
            addMember(entityId) {
                if (this.members.length < this.maxSize && !this.members.includes(entityId)) {
                    this.members.push(entityId);
                    return true;
                }
                return false;
            }
            
            removeMember(entityId) {
                const index = this.members.indexOf(entityId);
                if (index !== -1) {
                    this.members.splice(index, 1);
                    if (this.activeLeader >= this.members.length) {
                        this.activeLeader = Math.max(0, this.members.length - 1);
                    }
                    return true;
                }
                return false;
            }
            
            getLeader() {
                return this.members[this.activeLeader] || null;
            }
            
            switchLeader(newLeaderIndex) {
                if (newLeaderIndex >= 0 && newLeaderIndex < this.members.length) {
                    this.activeLeader = newLeaderIndex;
                    return true;
                }
                return false;
            }
        }
        
        class CharacterComponent {
            constructor() {
                this.name = 'Hero';
                this.level = 1;
                this.experience = 0;
                this.experienceToNext = 100;
                
                // Core stats
                this.stats = {
                    strength: 10,
                    dexterity: 10,
                    intelligence: 10,
                    vitality: 10
                };
                
                // Derived stats
                this.maxHealth = 100;
                this.currentHealth = 100;
                this.maxMana = 50;
                this.currentMana = 50;
                this.moveSpeed = 5.0;
                this.attackPower = 15;
                this.defense = 5;
                
                // Equipment slots
                this.equipment = {
                    weapon: null,
                    armor: null,
                    accessory: null
                };
                
                // Abilities
                this.abilities = [];
                this.activeAbility = null;
                
                this.active = true;
            }
            
            levelUp() {
                this.level++;
                this.experience = 0;
                this.experienceToNext = Math.floor(this.experienceToNext * 1.5);
                
                // Increase stats
                this.stats.strength += 2;
                this.stats.dexterity += 2;
                this.stats.intelligence += 1;
                this.stats.vitality += 3;
                
                this.recalculateStats();
            }
            
            addExperience(amount) {
                this.experience += amount;
                while (this.experience >= this.experienceToNext) {
                    this.levelUp();
                }
            }
            
            recalculateStats() {
                this.maxHealth = 100 + (this.stats.vitality * 10);
                this.maxMana = 50 + (this.stats.intelligence * 5);
                this.attackPower = 15 + (this.stats.strength * 2);
                this.defense = 5 + (this.stats.vitality * 1);
                this.moveSpeed = 5.0 + (this.stats.dexterity * 0.1);
            }
        }
        
        class AIComponent {
            constructor() {
                this.behaviorType = 'follow'; // 'follow', 'guard', 'patrol', 'aggressive'
                this.currentState = 'idle';
                this.target = null; // Target entity ID
                this.lastKnownTargetPosition = null;
                this.detectionRadius = 5.0;
                this.attackRadius = 1.5;
                this.patrolPoints = []; // Array of Vector3 positions
                this.currentPatrolIndex = 0;
                this.stateTimer = 0;
                this.decisionCooldown = 0.5; // How often to make new decisions
                this.lastDecisionTime = 0;
                this.active = true;
            }
            
            setState(newState) {
                this.currentState = newState;
                this.stateTimer = 0;
            }
            
            setTarget(entityId) {
                this.target = entityId;
            }
            
            addPatrolPoint(position) {
                this.patrolPoints.push(position.clone());
            }
        }
        
        class CombatComponent {
            constructor() {
                this.attackPower = 15;
                this.attackSpeed = 1.0; // Attacks per second
                this.attackRange = 1.5;
                this.lastAttackTime = 0;
                this.combatState = 'idle'; // 'idle', 'attacking', 'blocking', 'stunned'
                this.statusEffects = []; // Array of active status effects
                this.immunities = []; // Array of immunity types
                this.weaknesses = []; // Array of weakness types
                this.criticalChance = 0.05; // 5% chance
                this.criticalMultiplier = 2.0;
                this.active = true;
            }
            
            canAttack() {
                const now = performance.now() / 1000;
                return (now - this.lastAttackTime) >= (1.0 / this.attackSpeed) && 
                       this.combatState !== 'stunned';
            }
            
            attack() {
                if (this.canAttack()) {
                    this.lastAttackTime = performance.now() / 1000;
                    this.combatState = 'attacking';
                    
                    // Calculate damage with critical chance
                    let damage = this.attackPower;
                    if (Math.random() < this.criticalChance) {
                        damage *= this.criticalMultiplier;
                        return { damage, isCritical: true };
                    }
                    
                    return { damage, isCritical: false };
                }
                return null;
            }
            
            addStatusEffect(effect) {
                this.statusEffects.push({
                    type: effect.type,
                    duration: effect.duration,
                    value: effect.value,
                    startTime: performance.now() / 1000
                });
            }
        }
        
        class InventoryComponent {
            constructor() {
                this.slots = new Array(20).fill(null); // 20 inventory slots
                this.maxWeight = 100;
                this.currentWeight = 0;
                this.currency = 0; // Gold or other currency
                this.active = true;
            }
            
            addItem(item, quantity = 1) {
                // Find first empty slot
                for (let i = 0; i < this.slots.length; i++) {
                    if (this.slots[i] === null) {
                        this.slots[i] = {
                            item: item,
                            quantity: quantity
                        };
                        this.currentWeight += item.weight * quantity;
                        return true;
                    }
                }
                return false; // Inventory full
            }
            
            removeItem(slotIndex, quantity = 1) {
                if (this.slots[slotIndex] !== null) {
                    const stack = this.slots[slotIndex];
                    const removeQty = Math.min(quantity, stack.quantity);
                    
                    this.currentWeight -= stack.item.weight * removeQty;
                    stack.quantity -= removeQty;
                    
                    if (stack.quantity <= 0) {
                        this.slots[slotIndex] = null;
                    }
                    
                    return removeQty;
                }
                return 0;
            }
            
            hasSpace() {
                return this.slots.some(slot => slot === null);
            }
        }
        
        // Attach Phase 3 components to window so they can be accessed globally
        window.PartyComponent = PartyComponent;
        window.CharacterComponent = CharacterComponent;
        window.AIComponent = AIComponent;
        window.CombatComponent = CombatComponent;
        window.InventoryComponent = InventoryComponent;
        
        console.log('✅ Phase 3 components attached to window');
        
        // Global state
        let scene, camera, renderer, world;
        let lastTime = Date.now();
        let selectedEntity = null;
        let raycaster, mouse;
        
        // Component loading state
        let phase2ComponentsLoaded = false;
        
        // Inspector dragging state
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        
        
        
        function init() {
            // Verify Phase 3 components are available at init time
            console.log('  PartyComponent:', !!window.PartyComponent);
            console.log('  CharacterComponent:', !!window.CharacterComponent);
            console.log('  AIComponent:', !!window.AIComponent);
            console.log('  CombatComponent:', !!window.CombatComponent);
            console.log('  InventoryComponent:', !!window.InventoryComponent);
            
            // Initialize Three.js
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2c3e50);
            
            // Create dimetric camera (orthographic projection with 2:1 tile ratio)
            const frustumSize = 20;
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.OrthographicCamera(
                frustumSize * aspect / -2, frustumSize * aspect / 2,
                frustumSize / 2, frustumSize / -2,
                0.1, 1000
            );
            
            // Position for dimetric view (26.57° elevation, 45° azimuth for 2:1 tile ratio)
            const elevation = 26.57 * Math.PI / 180; // 26.57 degrees
            const azimuth = 45 * Math.PI / 180; // 45 degrees
            const distance = 20;
            
            camera.position.set(
                Math.cos(elevation) * Math.sin(azimuth) * distance,
                Math.sin(elevation) * distance,
                Math.cos(elevation) * Math.cos(azimuth) * distance
            );
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Create ground
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(25, 25),
                new THREE.MeshLambertMaterial({ color: 0x34495e })
            );
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Initialize raycaster for mouse picking
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Add mouse event listeners
            renderer.domElement.addEventListener('click', onMouseClick);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            
            // Initialize inspector dragging
            initInspectorDragging();
            
            // Initialize inspector resize observer
            initInspectorResize();
            
            // Initialize UI dragging
            initUIDragging();
            
            // Initialize ECS
            world = new World();
            
            // Load saved panel positions
            loadPanelPositions();
            
            // Load Phase 2 components (physics & animation) at startup
            loadPhase2Components(() => {
                console.log('✅ Phase 2 components are now available in the ECS inspector');
                
                // Load Phase 3 components (party & character systems)
                loadPhase3Components(() => {
                    console.log('✅ Phase 3 components are now available in the ECS inspector');
                    
                    // Create initial entities AFTER all components are loaded
                    console.log('🎯 Creating initial entities with all components...');
                    for (let i = 0; i < 5; i++) {
                        createEntity();
                    }
                    
                    console.log('ECS Demo initialized with', world.entities.length, 'entities with all components');
                });
            });
            
            // Start game loop immediately
            animate();
            updateStatus();
        }
        
        function createEntity() {
            const entity = world.createEntity();
            
            // Add Transform component
            const transform = new Transform(
                (Math.random() - 0.5) * 10,
                Math.random() * 3 + 1,
                (Math.random() - 0.5) * 10
            );
            entity.addComponent(transform);
            
            // Add Renderable component
            const geometry = Math.random() > 0.5 ? 
                new THREE.BoxGeometry(1, 1, 1) : 
                new THREE.SphereGeometry(0.5, 12, 8);
            const material = new THREE.MeshLambertMaterial({ 
                color: Math.random() * 0xffffff 
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            entity.addComponent(new Renderable(mesh));
            
            // Store entity reference on mesh for picking
            mesh.userData.entity = entity;
            
            scene.add(mesh);
            
            // Add all available components by default
            
            // Add Movement component
            const movement = new Movement();
            movement.velocity = {
                x: (Math.random() - 0.5) * 4,
                y: (Math.random() - 0.5) * 2,
                z: (Math.random() - 0.5) * 4
            };
            entity.addComponent(movement);
            
            // Add Health component
            entity.addComponent(new Health());
            
            // Add Lifetime component
            entity.addComponent(new Lifetime(Math.random() * 10 + 5));
            
            // Add VisualComponent for styling control
            entity.addComponent(new VisualComponent());
            
            // Add physics components if available
            if (phase2ComponentsLoaded) {
                // Add RigidbodyComponent
                const rigidbody = new window.RigidbodyComponent();
                rigidbody.mass = 1;
                rigidbody.useGravity = true;
                rigidbody.velocity = new THREE.Vector3((Math.random() - 0.5) * 2, 0, (Math.random() - 0.5) * 2);
                entity.addComponent(rigidbody);
                
                // Add appropriate collider based on geometry
                if (geometry instanceof THREE.SphereGeometry) {
                    const collider = new window.SphereColliderComponent();
                    collider.setRadius(0.5);
                    entity.addComponent(collider);
                } else {
                    const collider = new window.BoxColliderComponent();
                    collider.setSize(1, 1, 1);
                    entity.addComponent(collider);
                }
                
                // Add TweenComponent 
                const tween = new window.TweenComponent();
                entity.addComponent(tween);
                
                // Add AnimatorComponent
                const animator = new window.AnimatorComponent();
                entity.addComponent(animator);
                
                // Add Phase 3 components if available
                console.log('🔍 Checking Phase 3 components availability:', {
                    PartyComponent: !!window.PartyComponent,
                    CharacterComponent: !!window.CharacterComponent,
                    AIComponent: !!window.AIComponent,
                    CombatComponent: !!window.CombatComponent,
                    InventoryComponent: !!window.InventoryComponent
                });
                
                if (window.PartyComponent) {
                    const party = new window.PartyComponent();
                    party.addMember(entity.id);
                    entity.addComponent(party);
                    console.log('✅ Added PartyComponent to entity', entity.id);
                } else {
                    console.log('❌ PartyComponent not available');
                }
                
                if (window.CharacterComponent) {
                    const character = new window.CharacterComponent();
                    character.name = `Hero ${entity.id}`;
                    character.level = Math.floor(Math.random() * 5) + 1;
                    entity.addComponent(character);
                }
                
                if (window.AIComponent) {
                    const ai = new window.AIComponent();
                    const behaviors = ['follow', 'guard', 'patrol', 'aggressive'];
                    ai.behaviorType = behaviors[Math.floor(Math.random() * behaviors.length)];
                    entity.addComponent(ai);
                }
                
                if (window.CombatComponent) {
                    const combat = new window.CombatComponent();
                    combat.attackPower = Math.floor(Math.random() * 20) + 10;
                    entity.addComponent(combat);
                }
                
                if (window.InventoryComponent) {
                    const inventory = new window.InventoryComponent();
                    inventory.currency = Math.floor(Math.random() * 100);
                    entity.addComponent(inventory);
                }
                
                console.log('✅ Created entity with all components including physics and Phase 3!');
            } else {
                // Add Phase 3 components even if physics components aren't loaded yet
                console.log('🔍 Checking Phase 3 components availability (no physics):', {
                    PartyComponent: !!window.PartyComponent,
                    CharacterComponent: !!window.CharacterComponent,
                    AIComponent: !!window.AIComponent,
                    CombatComponent: !!window.CombatComponent,
                    InventoryComponent: !!window.InventoryComponent
                });
                
                if (window.PartyComponent) {
                    const party = new window.PartyComponent();
                    party.addMember(entity.id);
                    entity.addComponent(party);
                    console.log('✅ Added PartyComponent to entity', entity.id, '(no physics)');
                } else {
                    console.log('❌ PartyComponent not available (no physics)');
                }
                
                if (window.CharacterComponent) {
                    const character = new window.CharacterComponent();
                    character.name = `Hero ${entity.id}`;
                    character.level = Math.floor(Math.random() * 5) + 1;
                    entity.addComponent(character);
                }
                
                if (window.AIComponent) {
                    const ai = new window.AIComponent();
                    const behaviors = ['follow', 'guard', 'patrol', 'aggressive'];
                    ai.behaviorType = behaviors[Math.floor(Math.random() * behaviors.length)];
                    entity.addComponent(ai);
                }
                
                if (window.CombatComponent) {
                    const combat = new window.CombatComponent();
                    combat.attackPower = Math.floor(Math.random() * 20) + 10;
                    entity.addComponent(combat);
                }
                
                if (window.InventoryComponent) {
                    const inventory = new window.InventoryComponent();
                    inventory.currency = Math.floor(Math.random() * 100);
                    entity.addComponent(inventory);
                }
                
                console.log('✅ Created entity with basic components and Phase 3 components (physics components loading...)');
            }
            
            updateStatus();
            return entity;
        }
        
        function addComponentToEntity(entity) {
            const componentTypes = ['Movement', 'Health', 'Lifetime', 'RigidbodyComponent', 'BoxColliderComponent', 'SphereColliderComponent', 'TweenComponent', 'AnimatorComponent', 'VisualComponent', 'PartyComponent', 'CharacterComponent', 'AIComponent', 'CombatComponent', 'InventoryComponent'];
            const availableTypes = componentTypes.filter(type => !entity.hasComponent(type));
            
            if (availableTypes.length === 0) {
                console.log(`⚠️ Entity ${entity.id} already has all possible components`);
                return;
            }
            
            const randomType = availableTypes[Math.floor(Math.random() * availableTypes.length)];
            
            let component;
            switch(randomType) {
                case 'Movement':
                    component = new Movement();
                    component.velocity = {
                        x: (Math.random() - 0.5) * 4,
                        y: (Math.random() - 0.5) * 2,
                        z: (Math.random() - 0.5) * 4
                    };
                    break;
                case 'Health':
                    component = new Health();
                    break;
                case 'Lifetime':
                    component = new Lifetime(Math.random() * 10 + 5);
                    break;
                case 'RigidbodyComponent':
                    component = new window.RigidbodyComponent();
                    component.mass = 1;
                    component.useGravity = true;
                    component.velocity = new THREE.Vector3(0, 0, 0);
                    console.log('🔬 Added physics rigidbody component');
                    break;
                case 'BoxColliderComponent':
                    component = new window.BoxColliderComponent();
                    component.setSize(2, 2, 2);
                    console.log('📦 Added box collider component');
                    break;
                case 'SphereColliderComponent':
                    component = new window.SphereColliderComponent();
                    component.setRadius(1);
                    console.log('⚪ Added sphere collider component');
                    break;
                case 'TweenComponent':
                    component = new window.TweenComponent();
                    console.log('🎬 Added tween animation component');
                    break;
                case 'AnimatorComponent':
                    component = new window.AnimatorComponent();
                    console.log('🎭 Added animator component');
                    break;
                case 'VisualComponent':
                    component = new VisualComponent();
                    console.log('🎨 Added visual styling component');
                    break;
                case 'PartyComponent':
                    component = new PartyComponent();
                    // Auto-add this entity to the party
                    component.addMember(entity.id);
                    console.log('👥 Added party management component');
                    break;
                case 'CharacterComponent':
                    component = new CharacterComponent();
                    component.name = `Hero ${entity.id}`;
                    component.level = Math.floor(Math.random() * 5) + 1;
                    console.log('⚔️ Added character stats component');
                    break;
                case 'AIComponent':
                    component = new AIComponent();
                    const behaviors = ['follow', 'guard', 'patrol', 'aggressive'];
                    component.behaviorType = behaviors[Math.floor(Math.random() * behaviors.length)];
                    console.log(`🤖 Added AI component (${component.behaviorType})`);
                    break;
                case 'CombatComponent':
                    component = new CombatComponent();
                    component.attackPower = Math.floor(Math.random() * 20) + 10;
                    console.log('⚔️ Added combat component');
                    break;
                case 'InventoryComponent':
                    component = new InventoryComponent();
                    component.currency = Math.floor(Math.random() * 100);
                    console.log('🎒 Added inventory component');
                    break;
            }
            
            entity.addComponent(component);
            console.log(`✅ Added ${randomType} to entity ${entity.id}`);
            updateStatus();
        }
        
        function removeComponentFromEntity(entity) {
            const componentTypes = Array.from(entity.components.keys());
            const removableTypes = componentTypes.filter(type => 
                type !== 'Transform' && type !== 'Renderable'
            );
            
            if (removableTypes.length === 0) {
                console.log(`⚠️ Entity ${entity.id} has no removable components`);
                return;
            }
            
            const typeToRemove = removableTypes[Math.floor(Math.random() * removableTypes.length)];
            entity.removeComponent(typeToRemove);
            console.log(`🗑️ Removed ${typeToRemove} from entity ${entity.id}`);
            updateStatus();
        }
        
        function destroyEntity(entity) {
            // Always clean up visualization helpers for this entity
            removeColliderVisualization(entity);
            
            // Clear selection if this entity is currently selected
            if (selectedEntity && selectedEntity.id === entity.id) {
                selectEntity(null); // This will clear selection properly
            }
            
            world.destroyEntity(entity);
            console.log(`💥 Destroyed entity ${entity.id}`);
            updateStatus();
        }
        
        
        function queryEntities() {
            const queries = [
                ['Transform'],
                ['Transform', 'Movement'],
                ['Transform', 'Health'],
                ['Movement', 'Health'],
                ['Transform', 'Renderable', 'Movement']
            ];
            
            queries.forEach(componentTypes => {
                const result = world.query(componentTypes);
                console.log(`Query [${componentTypes.join(', ')}]: ${result.length} entities`);
            });
            
            queryTestCount++;
            updateStatus();
        }
        
        function stressTest() {
            console.log('Running stress test...');
            const start = performance.now();
            
            // Create 100 entities
            for (let i = 0; i < 100; i++) {
                createEntity();
            }
            
            // Run systems 10 times
            for (let i = 0; i < 10; i++) {
                world.update(0.016);
            }
            
            // Perform queries
            for (let i = 0; i < 50; i++) {
                world.query(['Transform', 'Movement']);
            }
            
            const end = performance.now();
            console.log(`Stress test completed in ${(end - start).toFixed(2)}ms`);
            document.getElementById('performance').textContent = `Stress: ${(end - start).toFixed(2)}ms`;
            updateStatus();
        }
        
        function destroyRandomEntity() {
            if (world.entities.length > 0) {
                const entity = world.entities[Math.floor(Math.random() * world.entities.length)];
                world.destroyEntity(entity);
                console.log(`Destroyed entity ${entity.id}`);
                updateStatus();
            }
        }
        
        function clearAll() {
            // Clear selection first
            selectEntity(null);
            
            while (world.entities.length > 0) {
                world.destroyEntity(world.entities[0]);
            }
            console.log('Cleared all entities');
            updateStatus();
        }
        
        function updateStatus() {
            const stats = world.getStats();
            document.getElementById('entityCount').textContent = stats.entities;
            document.getElementById('componentCount').textContent = stats.components;
            document.getElementById('systemCount').textContent = stats.systems;
            document.getElementById('queryCount').textContent = queryTestCount;
            updateInspector();
        }
        
        
        function onMouseMove(event) {
            // Update mouse position for hover effects
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Update raycaster
            raycaster.setFromCamera(mouse, camera);
            
            // Find intersected objects
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            // Reset all mesh colors first
            world.entities.forEach(entity => {
                const renderable = entity.getComponent('Renderable');
                if (renderable && renderable.mesh && renderable.mesh.userData.entity) {
                    if (selectedEntity && selectedEntity.id === entity.id) {
                        // Keep selected entity highlighted
                        renderable.mesh.material.emissive.setHex(0x004400);
                    } else {
                        // Normal color
                        renderable.mesh.material.emissive.setHex(0x000000);
                    }
                }
            });
            
            // Highlight hovered object
            if (intersects.length > 0) {
                const mesh = intersects[0].object;
                if (mesh.userData.entity && (!selectedEntity || selectedEntity.id !== mesh.userData.entity.id)) {
                    mesh.material.emissive.setHex(0x222222);
                }
                renderer.domElement.style.cursor = 'pointer';
            } else {
                renderer.domElement.style.cursor = 'default';
            }
        }
        
        function onMouseClick(event) {
            // Update mouse position
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Update raycaster
            raycaster.setFromCamera(mouse, camera);
            
            // Find intersected objects
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            if (intersects.length > 0) {
                const mesh = intersects[0].object;
                if (mesh.userData.entity) {
                    console.log(`🎯 Viewport click - selecting entity ${mesh.userData.entity.id}`);
                    selectEntity(mesh.userData.entity);
                }
            } else {
                // Clicked on empty space, deselect
                console.log('🎯 Viewport click - deselecting');
                selectEntity(null);
            }
        }
        
        function selectEntity(entity) {
            console.log(`🔄 selectEntity called with: ${entity ? `entity ${entity.id}` : 'null'}`);
            
            // Clear previous selection highlight
            if (selectedEntity) {
                const prevRenderable = selectedEntity.getComponent('Renderable');
                if (prevRenderable && prevRenderable.mesh) {
                    prevRenderable.mesh.material.emissive.setHex(0x000000);
                }
                
                // Remove collider visualization from previous selection
                removeColliderVisualization(selectedEntity);
            }
            
            selectedEntity = entity;
            
            // Highlight new selection with emissive glow
            if (selectedEntity) {
                const renderable = selectedEntity.getComponent('Renderable');
                if (renderable && renderable.mesh) {
                    // Add emissive glow for selection feedback
                    renderable.mesh.material.emissive.setHex(0x004400);
                }
                
                // Add collider visualization (replaces wireframe)
                addColliderVisualization(selectedEntity);
            }
            
            updateSelectionUI();
            updateInspector(); // This will update the inspector to show the selected state
        }
        
        function updateSelectionUI() {
            const selectionInfo = document.getElementById('selectionInfo');
            
            if (selectionInfo) {
                if (selectedEntity) {
                    const componentTypes = Array.from(selectedEntity.components.keys());
                    const activeCount = componentTypes.filter(type => {
                        const component = selectedEntity.getComponent(type);
                        return component.active !== false;
                    }).length;
                    
                    selectionInfo.innerHTML = `
                        <strong>Selected:</strong> Entity ${selectedEntity.id}<br>
                        <span style="font-size: 10px;">
                            ${componentTypes.length} components, ${activeCount} active
                        </span>
                    `;
                    selectionInfo.style.color = '#4CAF50';
                } else {
                    selectionInfo.textContent = 'Click an entity to select it. Click components to toggle on/off.';
                    selectionInfo.style.color = '#888';
                }
            }
        }
        
        function initInspectorDragging() {
            const inspector = document.getElementById('inspector');
            const header = document.getElementById('inspector-header');
            
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                inspector.classList.add('dragging');
                
                const rect = inspector.getBoundingClientRect();
                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;
                
                document.addEventListener('mousemove', onDrag);
                document.addEventListener('mouseup', onDragEnd);
                
                e.preventDefault();
            });
            
            function onDrag(e) {
                if (!isDragging) return;
                
                const newX = e.clientX - dragOffset.x;
                const newY = e.clientY - dragOffset.y;
                
                // Keep inspector within viewport bounds
                const maxX = window.innerWidth - inspector.offsetWidth;
                const maxY = window.innerHeight - inspector.offsetHeight;
                
                const clampedX = Math.max(0, Math.min(newX, maxX));
                const clampedY = Math.max(0, Math.min(newY, maxY));
                
                inspector.style.left = clampedX + 'px';
                inspector.style.top = clampedY + 'px';
                inspector.style.right = 'auto'; // Remove right positioning
                
                e.preventDefault();
            }
            
            function onDragEnd() {
                isDragging = false;
                inspector.classList.remove('dragging');
                document.removeEventListener('mousemove', onDrag);
                document.removeEventListener('mouseup', onDragEnd);
                
                // Save inspector position
                saveInspectorPosition();
            }
        }
        
        function initInspectorResize() {
            const inspector = document.getElementById('inspector');
            let resizeTimeout;
            
            // Use ResizeObserver to detect when inspector is resized
            if (window.ResizeObserver) {
                const resizeObserver = new ResizeObserver(entries => {
                    // Debounce the save operation
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        saveInspectorScale();
                    }, 100);
                });
                
                resizeObserver.observe(inspector);
            } else {
                // Fallback for older browsers - use window resize event
                let lastWidth = inspector.offsetWidth;
                let lastHeight = inspector.offsetHeight;
                
                window.addEventListener('resize', () => {
                    const currentWidth = inspector.offsetWidth;
                    const currentHeight = inspector.offsetHeight;
                    
                    if (currentWidth !== lastWidth || currentHeight !== lastHeight) {
                        clearTimeout(resizeTimeout);
                        resizeTimeout = setTimeout(() => {
                            saveInspectorScale();
                        }, 100);
                        
                        lastWidth = currentWidth;
                        lastHeight = currentHeight;
                    }
                });
            }
        }
        
        function initUIDragging() {
            const ui = document.getElementById('ui');
            const header = document.getElementById('ui-header');
            let isDraggingUI = false;
            let uiDragOffset = { x: 0, y: 0 };
            
            header.addEventListener('mousedown', (e) => {
                isDraggingUI = true;
                ui.classList.add('dragging');
                
                const rect = ui.getBoundingClientRect();
                uiDragOffset.x = e.clientX - rect.left;
                uiDragOffset.y = e.clientY - rect.top;
                
                document.addEventListener('mousemove', onUIDrag);
                document.addEventListener('mouseup', onUIDragEnd);
                
                e.preventDefault();
            });
            
            function onUIDrag(e) {
                if (!isDraggingUI) return;
                
                const newX = e.clientX - uiDragOffset.x;
                const newY = e.clientY - uiDragOffset.y;
                
                // Keep UI within viewport bounds
                const maxX = window.innerWidth - ui.offsetWidth;
                const maxY = window.innerHeight - ui.offsetHeight;
                
                const clampedX = Math.max(0, Math.min(newX, maxX));
                const clampedY = Math.max(0, Math.min(newY, maxY));
                
                ui.style.left = clampedX + 'px';
                ui.style.top = clampedY + 'px';
                
                e.preventDefault();
            }
            
            function onUIDragEnd() {
                isDraggingUI = false;
                ui.classList.remove('dragging');
                document.removeEventListener('mousemove', onUIDrag);
                document.removeEventListener('mouseup', onUIDragEnd);
                
                // Save UI position
                saveUIPosition();
            }
        }
        
        function saveUIPosition() {
            const ui = document.getElementById('ui');
            const position = {
                left: ui.style.left || '10px',
                top: ui.style.top || '10px'
            };
            localStorage.setItem('ecsUI_position', JSON.stringify(position));
        }
        
        function saveInspectorPosition() {
            const inspector = document.getElementById('inspector');
            const position = {
                left: inspector.style.left || 'auto',
                top: inspector.style.top || '10px',
                right: inspector.style.right || '10px',
                width: inspector.style.width || '320px',
                height: inspector.style.height || '400px'
            };
            localStorage.setItem('ecsInspector_position', JSON.stringify(position));
        }
        
        function saveInspectorScale() {
            const inspector = document.getElementById('inspector');
            const scale = {
                width: inspector.offsetWidth + 'px',
                height: inspector.offsetHeight + 'px'
            };
            localStorage.setItem('ecsInspector_scale', JSON.stringify(scale));
        }
        
        function loadPanelPositions() {
            // Load UI position
            const uiPosition = localStorage.getItem('ecsUI_position');
            if (uiPosition) {
                try {
                    const pos = JSON.parse(uiPosition);
                    const ui = document.getElementById('ui');
                    ui.style.left = pos.left;
                    ui.style.top = pos.top;
                } catch (e) {
                    console.log('Failed to load UI position:', e);
                }
            }
            
            // Load Inspector position
            const inspectorPosition = localStorage.getItem('ecsInspector_position');
            if (inspectorPosition) {
                try {
                    const pos = JSON.parse(inspectorPosition);
                    const inspector = document.getElementById('inspector');
                    
                    // Apply position
                    if (pos.left !== 'auto') {
                        inspector.style.left = pos.left;
                        inspector.style.right = 'auto';
                    } else {
                        inspector.style.right = pos.right;
                    }
                    inspector.style.top = pos.top;
                    inspector.style.width = pos.width;
                    inspector.style.height = pos.height;
                } catch (e) {
                    console.log('Failed to load Inspector position:', e);
                }
            }
            
            // Load Inspector scale
            const inspectorScale = localStorage.getItem('ecsInspector_scale');
            if (inspectorScale) {
                try {
                    const scale = JSON.parse(inspectorScale);
                    const inspector = document.getElementById('inspector');
                    inspector.style.width = scale.width;
                    inspector.style.height = scale.height;
                } catch (e) {
                    console.log('Failed to load Inspector scale:', e);
                }
            }
        }
        
        function updateInspector() {
            // Validate that selected entity still exists
            if (selectedEntity && !world.entities.find(e => e.id === selectedEntity.id)) {
                selectedEntity = null; // Clear selection if entity no longer exists
            }
            
            const entityList = document.getElementById('entityList');
            entityList.innerHTML = '';
            
            console.log(`🔄 Updating inspector, selected entity: ${selectedEntity ? selectedEntity.id : 'none'}`);
            
            // Show ALL entities, not just first 10
            world.entities.forEach(entity => {
                const card = document.createElement('div');
                card.className = 'entity-card';
                
                // Check if this entity is selected and apply style directly
                const isSelected = selectedEntity && selectedEntity.id === entity.id;
                if (isSelected) {
                    card.style.setProperty('background', 'rgba(76,175,80,0.5)', 'important');
                    card.style.setProperty('border', '2px solid #4CAF50', 'important');
                    card.style.setProperty('box-shadow', '0 0 8px rgba(76,175,80,0.6)', 'important');
                    card.style.setProperty('opacity', '1', 'important');
                    card.classList.add('selected');
                } else {
                    card.style.setProperty('background', 'rgba(255,255,255,0.1)', 'important');
                    card.style.setProperty('border', 'none', 'important');
                    card.style.setProperty('box-shadow', 'none', 'important');
                    card.style.setProperty('opacity', '0.6', 'important');
                    card.classList.remove('selected');
                }
                
                // Create header with entity name and buttons
                const header = document.createElement('div');
                header.className = 'entity-header';
                
                const entityName = document.createElement('strong');
                entityName.innerHTML = `<i data-lucide="box" style="width: 18px; height: 18px; vertical-align: text-bottom; margin-right: 6px;"></i>Entity ${entity.id}`;
                entityName.style.cursor = 'pointer';
                entityName.style.zIndex = '10';
                entityName.style.position = 'relative';
                
                // Add direct click handler to entity name
                entityName.addEventListener('click', (e) => {
                    console.log(`🖱️ Entity name clicked for entity ${entity.id}`);
                    selectEntity(entity);
                    e.stopPropagation();
                });
                
                const buttonContainer = document.createElement('div');
                buttonContainer.className = 'entity-buttons';
                
                // Add Component button
                const addBtn = document.createElement('button');
                addBtn.className = 'entity-btn';
                addBtn.innerHTML = '<i data-lucide="plus" style="width: 14px; height: 14px;"></i>';
                addBtn.title = 'Add Component';
                
                const componentTypes = ['Movement', 'Health', 'Lifetime', 'RigidbodyComponent', 'BoxColliderComponent', 'SphereColliderComponent', 'TweenComponent', 'AnimatorComponent', 'VisualComponent', 'PartyComponent', 'CharacterComponent', 'AIComponent', 'CombatComponent', 'InventoryComponent'];
                const availableTypes = componentTypes.filter(type => !entity.hasComponent(type));
                addBtn.disabled = availableTypes.length === 0;
                
                addBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    addComponentToEntity(entity);
                });
                
                // Remove Component button
                const removeBtn = document.createElement('button');
                removeBtn.className = 'entity-btn remove';
                removeBtn.innerHTML = '<i data-lucide="minus" style="width: 14px; height: 14px;"></i>';
                removeBtn.title = 'Remove Component';
                
                const componentKeys = Array.from(entity.components.keys());
                const removableTypes = componentKeys.filter(type => 
                    type !== 'Transform' && type !== 'Renderable'
                );
                removeBtn.disabled = removableTypes.length === 0;
                
                removeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    removeComponentFromEntity(entity);
                });
                
                // Destroy Entity button
                const destroyBtn = document.createElement('button');
                destroyBtn.className = 'entity-btn destroy';
                destroyBtn.innerHTML = '<i data-lucide="trash-2" style="width: 14px; height: 14px;"></i>';
                destroyBtn.title = 'Destroy Entity';
                
                destroyBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    destroyEntity(entity);
                });
                
                buttonContainer.appendChild(addBtn);
                buttonContainer.appendChild(removeBtn);
                buttonContainer.appendChild(destroyBtn);
                header.appendChild(entityName);
                header.appendChild(buttonContainer);
                
                // Add click handler to header background (not buttons)
                header.addEventListener('click', (e) => {
                    // Only trigger if clicking on header background, not buttons or entity name
                    if (e.target === header) {
                        console.log(`🖱️ Header background clicked for entity ${entity.id}`);
                        selectEntity(entity);
                    }
                });
                
                card.appendChild(header);
                
                // Add components display
                const componentsDiv = document.createElement('div');
                Array.from(entity.components.keys()).forEach(componentType => {
                    const component = entity.components.get(componentType);
                    const cssClass = componentType.toLowerCase();
                    
                    let details = '';
                    if (componentType === 'Transform') {
                        details = `(${component.x.toFixed(1)}, ${component.y.toFixed(1)}, ${component.z.toFixed(1)})`;
                    } else if (componentType === 'Movement') {
                        const speed = Math.sqrt(
                            component.velocity.x ** 2 + 
                            component.velocity.y ** 2 + 
                            component.velocity.z ** 2
                        ).toFixed(1);
                        details = `(speed: ${speed})`;
                    } else if (componentType === 'Health') {
                        details = `(${Math.round(component.current)}/${component.max})`;
                    } else if (componentType === 'Lifetime') {
                        details = `(${component.remaining.toFixed(1)}s)`;
                    } else if (componentType === 'RigidbodyComponent') {
                        const kinematic = component.isKinematic ? 'kinematic' : 'dynamic';
                        const mass = component.mass.toFixed(1);
                        if (!component.isKinematic && component.velocity) {
                            const speed = Math.sqrt(
                                component.velocity.x ** 2 + 
                                component.velocity.y ** 2 + 
                                component.velocity.z ** 2
                            ).toFixed(1);
                            details = `(${kinematic}, v: ${speed})`;
                        } else {
                            details = `(${kinematic}, mass: ${mass})`;
                        }
                    } else if (componentType === 'BoxColliderComponent') {
                        const size = component.size;
                        details = `(${size.x}×${size.y}×${size.z})`;
                    } else if (componentType === 'SphereColliderComponent') {
                        details = `(radius: ${component.radius.toFixed(1)})`;
                    } else if (componentType === 'TweenComponent') {
                        const status = component.isPlaying ? 'playing' : 'stopped';
                        details = `(${status})`;
                    } else if (componentType === 'AnimatorComponent') {
                        const state = component.currentState || 'idle';
                        details = `(${state})`;
                    } else if (componentType === 'VisualComponent') {
                        const modes = [];
                        if (component.wireframe) modes.push('wire');
                        if (component.pointsMode) modes.push('points');
                        if (component.transparent) modes.push('transp');
                        if (!component.visible) modes.push('hidden');
                        details = modes.length > 0 ? `(${modes.join(', ')})` : '(default)';
                    } else if (componentType === 'PartyComponent') {
                        const memberCount = component.members.length;
                        const leader = component.activeLeader;
                        details = `(${memberCount}/${component.maxSize} members, leader: ${leader})`;
                    } else if (componentType === 'CharacterComponent') {
                        const health = `${component.currentHealth}/${component.maxHealth}`;
                        details = `(Lv.${component.level}, HP: ${health})`;
                    } else if (componentType === 'AIComponent') {
                        const state = component.currentState || 'idle';
                        details = `(${component.behaviorType}, ${state})`;
                    } else if (componentType === 'CombatComponent') {
                        const state = component.combatState || 'idle';
                        const power = component.attackPower;
                        details = `(ATK: ${power}, ${state})`;
                    } else if (componentType === 'InventoryComponent') {
                        const itemCount = component.slots.filter(slot => slot !== null).length;
                        const gold = component.currency;
                        details = `(${itemCount}/20 items, ${gold} gold)`;
                    }
                    
                    const componentSpan = document.createElement('span');
                    const isActive = component.active !== false; // Default to true if not set
                    componentSpan.className = `component ${cssClass} ${isActive ? 'active' : 'inactive'}`;
                    componentSpan.textContent = `${componentType} ${details}`;
                    componentSpan.style.cursor = 'pointer';
                    componentSpan.title = `Click to ${isActive ? 'disable' : 'enable'} component`;
                    
                    // Add click handler to toggle component
                    componentSpan.addEventListener('click', (e) => {
                        console.log(`🖠️ Component ${componentType} clicked for entity ${entity.id}`);
                        e.stopPropagation();
                        e.preventDefault();
                        toggleComponent(entity, componentType, component);
                    });
                    
                    componentsDiv.appendChild(componentSpan);
                });
                
                card.appendChild(componentsDiv);
                entityList.appendChild(card);
            });
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const now = Date.now();
            const deltaTime = (now - lastTime) / 1000;
            lastTime = now;
            
            // Update ECS world
            world.update(deltaTime);
            
            // Update physics system if available
            if (world.physicsSystem) {
                world.physicsSystem.update(deltaTime);
            }
            
            // Update Phase 3 systems if available
            if (world.partySystem) {
                world.partySystem.update(deltaTime);
            }
            if (world.characterSystem) {
                world.characterSystem.update(deltaTime);
            }
            if (world.aiSystem) {
                world.aiSystem.update(deltaTime);
            }
            if (world.combatSystem) {
                world.combatSystem.update(deltaTime);
            }
            if (world.inventorySystem) {
                world.inventorySystem.update(deltaTime);
            }
            
            
            // Update UI less frequently to avoid flickering (every 1000ms)
            if ((now - lastInspectorUpdate) > 1000) {
                updateInspector();
                updateStatus();
                lastInspectorUpdate = now;
            }
            
            // Update collider visualization for selected entity
            if (selectedEntity) {
                updateColliderVisualization(selectedEntity);
            }
            
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            const frustumSize = 20;
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Initialize
        if (typeof THREE !== 'undefined') {
            init();
        } else {
            window.addEventListener('load', init);
        }
        
        // Load Phase 2 components at initialization
        
        function loadPhase2Components(callback) {
            if (phase2ComponentsLoaded) {
                if (callback) callback();
                return;
            }
            
            console.log('📦 Loading Phase 2 components for ECS...');
            
            // Load GameEngine-standalone to get the component classes
            const gameEngineScript = document.createElement('script');
            gameEngineScript.src = './GameEngine-standalone.js';
            gameEngineScript.onload = () => {
                console.log('✅ Phase 2 components loaded and available in ECS');
                phase2ComponentsLoaded = true;
                
                // Add physics system to existing ECS
                addPhysicsSystemToECS();
                
                if (callback) callback();
            };
            gameEngineScript.onerror = () => {
                console.error('❌ Failed to load Phase 2 components');
                if (callback) callback();
            };
            document.head.appendChild(gameEngineScript);
        }
        
        function addPhysicsSystemToECS() {
            // Add a proper physics system based on PhysicsSystem from GameEngine
            if (!world.physicsSystem) {
                world.physicsSystem = {
                    gravity: new THREE.Vector3(0, -9.81, 0),
                    enableGravity: true,
                    requiredComponents: ['Transform', 'RigidbodyComponent'],
                    
                    update: function(deltaTime) {
                        // Process entities using proper ECS pattern
                        world.entities.forEach(entity => {
                            if (!this.entityMatches(entity)) return;
                            
                            const transform = entity.getComponent('Transform');
                            const rigidbody = entity.getComponent('RigidbodyComponent');
                            
                            if (rigidbody.isKinematic || rigidbody.isSleeping || rigidbody.active === false || transform.active === false) return;
                            
                            // Apply gravity
                            if (rigidbody.useGravity && this.enableGravity) {
                                rigidbody.forces = rigidbody.forces || [];
                                const gravityForce = this.gravity.clone().multiplyScalar(rigidbody.mass);
                                rigidbody.forces.push(gravityForce);
                            }
                            
                            // Apply forces to acceleration
                            rigidbody.acceleration = rigidbody.acceleration || new THREE.Vector3(0, 0, 0);
                            rigidbody.acceleration.set(0, 0, 0);
                            
                            if (rigidbody.forces) {
                                rigidbody.forces.forEach(force => {
                                    rigidbody.acceleration.add(force.clone().divideScalar(rigidbody.mass));
                                });
                                rigidbody.forces = []; // Clear forces
                            }
                            
                            // Apply drag
                            if (rigidbody.drag) {
                                const dragForce = rigidbody.velocity.clone().multiplyScalar(-rigidbody.drag);
                                rigidbody.acceleration.add(dragForce);
                            }
                            
                            // Update velocity
                            rigidbody.velocity.add(rigidbody.acceleration.clone().multiplyScalar(deltaTime));
                            
                            // Update position 
                            const deltaPosition = rigidbody.velocity.clone().multiplyScalar(deltaTime);
                            transform.x += deltaPosition.x;
                            transform.y += deltaPosition.y;
                            transform.z += deltaPosition.z;
                            
                            // Simple ground collision with collider detection
                            const sphereCollider = entity.getComponent('SphereColliderComponent');
                            const boxCollider = entity.getComponent('BoxColliderComponent');
                            
                            let colliderRadius = 0.5; // Default
                            if (sphereCollider) {
                                colliderRadius = sphereCollider.radius;
                            } else if (boxCollider) {
                                colliderRadius = Math.min(boxCollider.size.x, boxCollider.size.y, boxCollider.size.z) / 2;
                            }
                            
                            if (transform.y < colliderRadius) {
                                transform.y = colliderRadius;
                                rigidbody.velocity.y = Math.abs(rigidbody.velocity.y) * 0.7; // Bounce with restitution
                                
                                // Wake up if sleeping
                                rigidbody.isSleeping = false;
                            }
                            
                            // Check for sleep threshold
                            if (rigidbody.velocity.length() < (rigidbody.sleepThreshold || 0.01)) {
                                rigidbody.isSleeping = true;
                            }
                        });
                    },
                    
                    entityMatches: function(entity) {
                        return this.requiredComponents.every(componentType => entity.hasComponent(componentType));
                    },
                    
                    getStats: function() {
                        return {
                            gravity: this.gravity.clone(),
                            enableGravity: this.enableGravity
                        };
                    }
                };
                console.log('✅ Proper PhysicsSystem integrated into existing ECS with collision detection');
            }
        }
        
        // === Phase 3 Systems ===
        function addPhase3SystemsToECS() {
            console.log('🎯 Adding Phase 3 systems to ECS...');
            
            // PartySystem
            if (!world.partySystem) {
                world.partySystem = {
                    update: function(deltaTime) {
                        world.entities.forEach(entity => {
                            const party = entity.getComponent('PartyComponent');
                            if (!party || party.active === false) return;
                            
                            this.updatePartyFormation(entity, party);
                            this.updateFollowerPositions(entity, party, deltaTime);
                        });
                    },
                    
                    updatePartyFormation: function(partyEntity, party) {
                        const leaderId = party.getLeader();
                        const leader = world.entities.find(entity => entity.id === leaderId);
                        if (!leader) return;
                        
                        const leaderTransform = leader.getComponent('Transform');
                        if (!leaderTransform) return;
                        
                        // Update formation positions for followers
                        for (let i = 0; i < party.members.length; i++) {
                            if (i === party.activeLeader) continue; // Skip leader
                            
                            const follower = world.entities.find(entity => entity.id === party.members[i]);
                            if (!follower) continue;
                            
                            const followerTransform = follower.getComponent('Transform');
                            if (!followerTransform) continue;
                            
                            // Calculate formation position
                            const formationPos = this.calculateFormationPosition(
                                leaderTransform, i, party.formation, party.spacing
                            );
                            
                            // Set follower target position (will be handled by AI)
                            const ai = follower.getComponent('AIComponent');
                            if (ai) {
                                ai.target = party.getLeader();
                                ai.lastKnownTargetPosition = formationPos;
                            }
                        }
                    },
                    
                    calculateFormationPosition: function(leaderTransform, memberIndex, formation, spacing) {
                        const pos = { x: leaderTransform.x, y: leaderTransform.y, z: leaderTransform.z };
                        
                        switch (formation) {
                            case 'line':
                                pos.x -= spacing * (memberIndex + 1);
                                break;
                            case 'triangle':
                                const side = memberIndex % 2 === 0 ? -1 : 1;
                                pos.x += side * spacing * Math.ceil(memberIndex / 2);
                                pos.z -= spacing * Math.ceil(memberIndex / 2);
                                break;
                            case 'column':
                                pos.z -= spacing * (memberIndex + 1);
                                break;
                        }
                        
                        return pos;
                    },
                    
                    updateFollowerPositions: function(partyEntity, party, deltaTime) {
                        // Smooth movement toward formation positions
                        // This would integrate with movement/AI systems
                    }
                };
                console.log('✅ PartySystem added to ECS');
            }
            
            // CharacterSystem  
            if (!world.characterSystem) {
                world.characterSystem = {
                    update: function(deltaTime) {
                        world.entities.forEach(entity => {
                            const character = entity.getComponent('CharacterComponent');
                            if (!character || character.active === false) return;
                            
                            this.updateCharacterStats(character);
                            this.processStatusEffects(character, deltaTime);
                        });
                    },
                    
                    updateCharacterStats: function(character) {
                        // Recalculate derived stats if needed
                        character.recalculateStats();
                    },
                    
                    processStatusEffects: function(character, deltaTime) {
                        const combat = character.entity?.getComponent('CombatComponent');
                        if (!combat) return;
                        
                        const now = performance.now() / 1000;
                        combat.statusEffects = combat.statusEffects.filter(effect => {
                            const elapsed = now - effect.startTime;
                            return elapsed < effect.duration;
                        });
                    }
                };
                console.log('✅ CharacterSystem added to ECS');
            }
            
            // AISystem
            if (!world.aiSystem) {
                world.aiSystem = {
                    update: function(deltaTime) {
                        world.entities.forEach(entity => {
                            const ai = entity.getComponent('AIComponent');
                            if (!ai || ai.active === false) return;
                            
                            const now = performance.now() / 1000;
                            if ((now - ai.lastDecisionTime) >= ai.decisionCooldown) {
                                this.processAI(entity, ai, deltaTime);
                                ai.lastDecisionTime = now;
                            }
                            
                            ai.stateTimer += deltaTime;
                        });
                    },
                    
                    processAI: function(entity, ai, deltaTime) {
                        const transform = entity.getComponent('Transform');
                        if (!transform) return;
                        
                        switch (ai.behaviorType) {
                            case 'follow':
                                this.processFollowBehavior(entity, ai, transform);
                                break;
                            case 'patrol':
                                this.processPatrolBehavior(entity, ai, transform);
                                break;
                            case 'guard':
                                this.processGuardBehavior(entity, ai, transform);
                                break;
                            case 'aggressive':
                                this.processAggressiveBehavior(entity, ai, transform);
                                break;
                        }
                    },
                    
                    processFollowBehavior: function(entity, ai, transform) {
                        if (!ai.target) return;
                        
                        const targetEntity = world.entities.find(entity => entity.id === ai.target);
                        if (!targetEntity) return;
                        
                        const targetTransform = targetEntity.getComponent('Transform');
                        if (!targetTransform) return;
                        
                        // Calculate distance to target
                        const dx = targetTransform.x - transform.x;
                        const dz = targetTransform.z - transform.z;
                        const distance = Math.sqrt(dx * dx + dz * dz);
                        
                        // Move toward target if too far
                        const movement = entity.getComponent('Movement');
                        if (movement && distance > 2.0) {
                            const moveSpeed = 2.0;
                            movement.velocity.x = (dx / distance) * moveSpeed;
                            movement.velocity.z = (dz / distance) * moveSpeed;
                            ai.setState('moving');
                        } else if (movement) {
                            movement.velocity.x = 0;
                            movement.velocity.z = 0;
                            ai.setState('idle');
                        }
                    },
                    
                    processPatrolBehavior: function(entity, ai, transform) {
                        // Patrol between waypoints
                        if (ai.patrolPoints.length === 0) return;
                        
                        const targetPoint = ai.patrolPoints[ai.currentPatrolIndex];
                        const dx = targetPoint.x - transform.x;
                        const dz = targetPoint.z - transform.z;
                        const distance = Math.sqrt(dx * dx + dz * dz);
                        
                        if (distance < 1.0) {
                            // Reached waypoint, move to next
                            ai.currentPatrolIndex = (ai.currentPatrolIndex + 1) % ai.patrolPoints.length;
                        } else {
                            // Move toward current waypoint
                            const movement = entity.getComponent('Movement');
                            if (movement) {
                                const moveSpeed = 1.5;
                                movement.velocity.x = (dx / distance) * moveSpeed;
                                movement.velocity.z = (dz / distance) * moveSpeed;
                            }
                        }
                    },
                    
                    processGuardBehavior: function(entity, ai, transform) {
                        // Stay in place and watch for threats
                        const movement = entity.getComponent('Movement');
                        if (movement) {
                            movement.velocity.x = 0;
                            movement.velocity.z = 0;
                        }
                        ai.setState('guarding');
                    },
                    
                    processAggressiveBehavior: function(entity, ai, transform) {
                        // Look for targets and attack
                        if (!ai.target) {
                            // Find nearest enemy (for now, just find any other entity)
                            let nearestEntity = null;
                            let nearestDistance = ai.detectionRadius;
                            
                            world.entities.forEach((otherEntity, id) => {
                                if (otherEntity.id === entity.id) return;
                                
                                const otherTransform = otherEntity.getComponent('Transform');
                                if (!otherTransform) return;
                                
                                const dx = otherTransform.x - transform.x;
                                const dz = otherTransform.z - transform.z;
                                const distance = Math.sqrt(dx * dx + dz * dz);
                                
                                if (distance < nearestDistance) {
                                    nearestEntity = otherEntity;
                                    nearestDistance = distance;
                                }
                            });
                            
                            if (nearestEntity) {
                                ai.setTarget(nearestEntity.id);
                            }
                        } else {
                            // Chase and attack target
                            this.processFollowBehavior(entity, ai, transform);
                            
                            const targetEntity = world.entities.find(entity => entity.id === ai.target);
                            if (targetEntity) {
                                const targetTransform = targetEntity.getComponent('Transform');
                                if (targetTransform) {
                                    const dx = targetTransform.x - transform.x;
                                    const dz = targetTransform.z - transform.z;
                                    const distance = Math.sqrt(dx * dx + dz * dz);
                                    
                                    if (distance <= ai.attackRadius) {
                                        const combat = entity.getComponent('CombatComponent');
                                        if (combat && combat.canAttack()) {
                                            const attackResult = combat.attack();
                                            if (attackResult) {
                                                console.log(`🗡️ Entity ${entity.id} attacks for ${attackResult.damage} damage${attackResult.isCritical ? ' (CRITICAL!)' : ''}`);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                };
                console.log('✅ AISystem added to ECS');
            }
            
            // CombatSystem
            if (!world.combatSystem) {
                world.combatSystem = {
                    update: function(deltaTime) {
                        world.entities.forEach(entity => {
                            const combat = entity.getComponent('CombatComponent');
                            if (!combat || combat.active === false) return;
                            
                            this.updateCombatState(combat, deltaTime);
                            this.processStatusEffects(combat, deltaTime);
                            this.processCombatCooldowns(combat, deltaTime);
                        });
                    },
                    
                    updateCombatState: function(combat, deltaTime) {
                        // Reset combat state after attacks
                        if (combat.combatState === 'attacking') {
                            const now = performance.now() / 1000;
                            if ((now - combat.lastAttackTime) > 0.5) { // 0.5s attack animation
                                combat.combatState = 'idle';
                            }
                        }
                    },
                    
                    processStatusEffects: function(combat, deltaTime) {
                        const now = performance.now() / 1000;
                        combat.statusEffects = combat.statusEffects.filter(effect => {
                            const elapsed = now - effect.startTime;
                            if (elapsed >= effect.duration) {
                                console.log(`✨ Status effect ${effect.type} expired`);
                                return false;
                            }
                            return true;
                        });
                    },
                    
                    processCombatCooldowns: function(combat, deltaTime) {
                        // Handle ability cooldowns and other timers
                        // This would be expanded with more complex combat mechanics
                    },
                    
                    dealDamage: function(attackerEntity, targetEntity, damage) {
                        const targetCharacter = targetEntity.getComponent('CharacterComponent');
                        const targetHealth = targetEntity.getComponent('Health');
                        
                        if (targetCharacter) {
                            targetCharacter.currentHealth -= damage;
                            console.log(`💥 ${targetEntity.id} takes ${damage} damage (${targetCharacter.currentHealth}/${targetCharacter.maxHealth} HP)`);
                            
                            if (targetCharacter.currentHealth <= 0) {
                                console.log(`💀 Entity ${targetEntity.id} has been defeated!`);
                                // Could trigger death/destruction logic here
                            }
                        } else if (targetHealth) {
                            targetHealth.current -= damage;
                            console.log(`💥 ${targetEntity.id} takes ${damage} damage (${targetHealth.current}/${targetHealth.max} HP)`);
                        }
                    }
                };
                console.log('✅ CombatSystem added to ECS');
            }
            
            // InventorySystem
            if (!world.inventorySystem) {
                world.inventorySystem = {
                    update: function(deltaTime) {
                        world.entities.forEach(entity => {
                            const inventory = entity.getComponent('InventoryComponent');
                            if (!inventory || inventory.active === false) return;
                            
                            this.updateInventoryWeight(inventory);
                        });
                    },
                    
                    updateInventoryWeight: function(inventory) {
                        let totalWeight = 0;
                        inventory.slots.forEach(slot => {
                            if (slot !== null) {
                                totalWeight += (slot.item.weight || 1) * slot.quantity;
                            }
                        });
                        inventory.currentWeight = totalWeight;
                    },
                    
                    transferItem: function(fromInventory, toInventory, fromSlot, toSlot) {
                        const item = fromInventory.slots[fromSlot];
                        if (!item) return false;
                        
                        if (toInventory.slots[toSlot] === null) {
                            toInventory.slots[toSlot] = item;
                            fromInventory.slots[fromSlot] = null;
                            console.log(`📦 Transferred ${item.item.name || 'item'} to new slot`);
                            return true;
                        }
                        return false;
                    },
                    
                    createRandomItem: function() {
                        const items = [
                            { name: 'Sword', weight: 3, value: 50, type: 'weapon' },
                            { name: 'Shield', weight: 5, value: 30, type: 'armor' },
                            { name: 'Potion', weight: 1, value: 10, type: 'consumable' },
                            { name: 'Gold Coin', weight: 0.1, value: 1, type: 'currency' },
                            { name: 'Magic Ring', weight: 0.5, value: 100, type: 'accessory' }
                        ];
                        return items[Math.floor(Math.random() * items.length)];
                    }
                };
                console.log('✅ InventorySystem added to ECS');
            }
            
            console.log('🎯 Phase 3 systems integration complete');
        }
        
        // Load Phase 3 components and systems
        function loadPhase3Components(callback) {
            console.log('📦 Loading Phase 3 components for ECS...');
            
            // Verify Phase 3 components are available
            const componentsAvailable = [
                'PartyComponent',
                'CharacterComponent', 
                'AIComponent',
                'CombatComponent',
                'InventoryComponent'
            ].every(name => {
                const available = !!window[name];
                console.log(`  ${available ? '✅' : '❌'} ${name}: ${available ? 'Available' : 'Not found'}`);
                return available;
            });
            
            if (!componentsAvailable) {
                console.error('❌ Some Phase 3 components are not available on window!');
            }
            
            // Add Phase 3 systems to existing ECS
            addPhase3SystemsToECS();
            
            console.log('✅ Phase 3 components and systems loaded');
            if (callback) callback();
        }
        
        
        // Collider visualization
        function addColliderVisualization(entity) {
            if (!entity) return;
            
            const transform = entity.getComponent('Transform');
            if (!transform) return;
            
            // Always create visualizations - they show component state, not movement state
            
            // Remove existing collider visualizations
            removeColliderVisualization(entity);
            
            // Visualize SphereColliderComponent
            const sphereCollider = entity.getComponent('SphereColliderComponent');
            if (sphereCollider && sphereCollider.active !== false) {
                const geometry = new THREE.SphereGeometry(sphereCollider.radius, 16, 12);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x00ff88,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.6
                });
                const sphereHelper = new THREE.Mesh(geometry, material);
                
                // Position the helper
                sphereHelper.position.set(transform.x, transform.y, transform.z);
                sphereHelper.position.add(sphereCollider.center);
                
                // Store reference and add to scene
                entity.sphereColliderHelper = sphereHelper;
                scene.add(sphereHelper);
                
                console.log(`🔵 Added sphere collider visualization for entity ${entity.id}`);
            }
            
            // Visualize BoxColliderComponent
            const boxCollider = entity.getComponent('BoxColliderComponent');
            if (boxCollider && boxCollider.active !== false) {
                const geometry = new THREE.BoxGeometry(boxCollider.size.x, boxCollider.size.y, boxCollider.size.z);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x0088ff,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.6
                });
                const boxHelper = new THREE.Mesh(geometry, material);
                
                // Position the helper
                boxHelper.position.set(transform.x, transform.y, transform.z);
                boxHelper.position.add(boxCollider.center);
                
                // Store reference and add to scene
                entity.boxColliderHelper = boxHelper;
                scene.add(boxHelper);
                
                console.log(`🟦 Added box collider visualization for entity ${entity.id}`);
            }
            
            // Visualize TweenComponent
            const tweenComponent = entity.getComponent('TweenComponent');
            if (tweenComponent && tweenComponent.active !== false) {
                // Create a pulsing ring around the entity to show it has tweening
                const ringGeometry = new THREE.RingGeometry(1.5, 2.0, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff44ff,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide
                });
                const ringHelper = new THREE.Mesh(ringGeometry, ringMaterial);
                
                // Position the ring horizontally around the entity
                ringHelper.position.set(transform.x, transform.y + 1, transform.z);
                ringHelper.rotation.x = Math.PI / 2; // Make it horizontal
                
                // Store reference and add to scene
                entity.tweenHelper = ringHelper;
                scene.add(ringHelper);
                
                console.log(`🟠 Added tween visualization for entity ${entity.id}`);
            }
            
            // Visualize AnimatorComponent
            const animatorComponent = entity.getComponent('AnimatorComponent');
            if (animatorComponent && animatorComponent.active !== false) {
                // Create rotating wireframe octahedron to show animation state
                const geometry = new THREE.OctahedronGeometry(1.2);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xaa44ff,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.8
                });
                const animatorHelper = new THREE.Mesh(geometry, material);
                
                // Position above the entity
                animatorHelper.position.set(transform.x, transform.y + 2.5, transform.z);
                
                // Store reference and add to scene
                entity.animatorHelper = animatorHelper;
                scene.add(animatorHelper);
                
                console.log(`🎭 Added animator visualization for entity ${entity.id}`);
            }
            
            // Visualize PartyComponent
            const party = entity.getComponent('PartyComponent');
            if (party && party.active !== false) {
                // Create party leadership indicator (crown)
                const crownGeometry = new THREE.ConeGeometry(0.2, 0.4, 6);
                const crownMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffd700,
                    transparent: true,
                    opacity: 0.9
                });
                const crownHelper = new THREE.Mesh(crownGeometry, crownMaterial);
                crownHelper.position.set(transform.x, transform.y + 2, transform.z);
                
                entity.partyHelper = crownHelper;
                scene.add(crownHelper);
                
                console.log(`👑 Added party leadership indicator for entity ${entity.id}`);
            }
            
            // Visualize CharacterComponent
            const character = entity.getComponent('CharacterComponent');
            if (character && character.active !== false) {
                // Create health bar
                const healthBarGeometry = new THREE.PlaneGeometry(1, 0.1);
                const healthPercent = character.currentHealth / character.maxHealth;
                const healthColor = healthPercent > 0.5 ? 0x4caf50 : healthPercent > 0.2 ? 0xffeb3b : 0xf44336;
                const healthBarMaterial = new THREE.MeshBasicMaterial({ 
                    color: healthColor,
                    transparent: true,
                    opacity: 0.8
                });
                const healthBar = new THREE.Mesh(healthBarGeometry, healthBarMaterial);
                healthBar.position.set(transform.x, transform.y + 1.8, transform.z);
                healthBar.lookAt(camera.position);
                
                // Create level indicator
                const levelGeometry = new THREE.RingGeometry(0.15, 0.25, 8);
                const levelMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x2196f3,
                    transparent: true,
                    opacity: 0.7
                });
                const levelHelper = new THREE.Mesh(levelGeometry, levelMaterial);
                levelHelper.position.set(transform.x + 0.7, transform.y + 1.8, transform.z);
                levelHelper.lookAt(camera.position);
                
                entity.healthBarHelper = healthBar;
                entity.levelHelper = levelHelper;
                scene.add(healthBar);
                scene.add(levelHelper);
                
                console.log(`❤️ Added health bar and level indicator for entity ${entity.id}`);
            }
            
            // Visualize AIComponent
            const ai = entity.getComponent('AIComponent');
            if (ai && ai.active !== false) {
                // Create behavior state indicator
                const behaviorGeometry = new THREE.SphereGeometry(0.15, 8, 6);
                let behaviorColor;
                switch(ai.behaviorType) {
                    case 'follow': behaviorColor = 0x4caf50; break;
                    case 'guard': behaviorColor = 0xff9800; break;
                    case 'patrol': behaviorColor = 0x2196f3; break;
                    case 'aggressive': behaviorColor = 0xf44336; break;
                    default: behaviorColor = 0x9e9e9e;
                }
                const behaviorMaterial = new THREE.MeshBasicMaterial({ 
                    color: behaviorColor,
                    transparent: true,
                    opacity: 0.8
                });
                const behaviorHelper = new THREE.Mesh(behaviorGeometry, behaviorMaterial);
                behaviorHelper.position.set(transform.x - 0.7, transform.y + 1.8, transform.z);
                
                entity.aiHelper = behaviorHelper;
                scene.add(behaviorHelper);
                
                console.log(`🤖 Added AI behavior indicator for entity ${entity.id}`);
            }
            
            // Visualize CombatComponent
            const combat = entity.getComponent('CombatComponent');
            if (combat && combat.active !== false) {
                // Create attack range indicator
                const rangeGeometry = new THREE.RingGeometry(1.5, 1.7, 16);
                const rangeMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xf44336,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                const rangeHelper = new THREE.Mesh(rangeGeometry, rangeMaterial);
                rangeHelper.position.set(transform.x, transform.y + 0.1, transform.z);
                rangeHelper.rotation.x = -Math.PI / 2;
                
                entity.combatHelper = rangeHelper;
                scene.add(rangeHelper);
                
                console.log(`⚔️ Added combat range indicator for entity ${entity.id}`);
            }
            
            // Visualize InventoryComponent
            const inventory = entity.getComponent('InventoryComponent');
            if (inventory && inventory.active !== false) {
                // Create inventory bag indicator
                const bagGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                const bagMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x8d6e63,
                    transparent: true,
                    opacity: 0.9
                });
                const bagHelper = new THREE.Mesh(bagGeometry, bagMaterial);
                bagHelper.position.set(transform.x + 0.7, transform.y + 1.2, transform.z);
                
                entity.inventoryHelper = bagHelper;
                scene.add(bagHelper);
                
                console.log(`💰 Added inventory indicator for entity ${entity.id}`);
            }
        }
        
        function removeColliderVisualization(entity) {
            if (!entity) return;
            
            // Remove sphere collider helper
            if (entity.sphereColliderHelper) {
                scene.remove(entity.sphereColliderHelper);
                entity.sphereColliderHelper.geometry.dispose();
                entity.sphereColliderHelper.material.dispose();
                delete entity.sphereColliderHelper;
            }
            
            // Remove box collider helper
            if (entity.boxColliderHelper) {
                scene.remove(entity.boxColliderHelper);
                entity.boxColliderHelper.geometry.dispose();
                entity.boxColliderHelper.material.dispose();
                delete entity.boxColliderHelper;
            }
            
            // Remove tween helper
            if (entity.tweenHelper) {
                scene.remove(entity.tweenHelper);
                entity.tweenHelper.geometry.dispose();
                entity.tweenHelper.material.dispose();
                delete entity.tweenHelper;
            }
            
            // Remove animator helper
            if (entity.animatorHelper) {
                scene.remove(entity.animatorHelper);
                entity.animatorHelper.geometry.dispose();
                entity.animatorHelper.material.dispose();
                delete entity.animatorHelper;
            }
            
            // Remove Phase 3 component helpers
            if (entity.partyHelper) {
                scene.remove(entity.partyHelper);
                entity.partyHelper.geometry.dispose();
                entity.partyHelper.material.dispose();
                delete entity.partyHelper;
            }
            
            if (entity.healthBarHelper) {
                scene.remove(entity.healthBarHelper);
                entity.healthBarHelper.geometry.dispose();
                entity.healthBarHelper.material.dispose();
                delete entity.healthBarHelper;
            }
            
            if (entity.levelHelper) {
                scene.remove(entity.levelHelper);
                entity.levelHelper.geometry.dispose();
                entity.levelHelper.material.dispose();
                delete entity.levelHelper;
            }
            
            if (entity.aiHelper) {
                scene.remove(entity.aiHelper);
                entity.aiHelper.geometry.dispose();
                entity.aiHelper.material.dispose();
                delete entity.aiHelper;
            }
            
            if (entity.combatHelper) {
                scene.remove(entity.combatHelper);
                entity.combatHelper.geometry.dispose();
                entity.combatHelper.material.dispose();
                delete entity.combatHelper;
            }
            
            if (entity.inventoryHelper) {
                scene.remove(entity.inventoryHelper);
                entity.inventoryHelper.geometry.dispose();
                entity.inventoryHelper.material.dispose();
                delete entity.inventoryHelper;
            }
        }
        
        function updateColliderVisualization(entity) {
            if (!entity || entity !== selectedEntity) return;
            
            const transform = entity.getComponent('Transform');
            if (!transform || transform.active === false) return;
            
            const now = Date.now();
            
            // Update sphere collider position
            if (entity.sphereColliderHelper) {
                const sphereCollider = entity.getComponent('SphereColliderComponent');
                if (sphereCollider) {
                    entity.sphereColliderHelper.position.set(transform.x, transform.y, transform.z);
                    entity.sphereColliderHelper.position.add(sphereCollider.center);
                }
            }
            
            // Update box collider position
            if (entity.boxColliderHelper) {
                const boxCollider = entity.getComponent('BoxColliderComponent');
                if (boxCollider) {
                    entity.boxColliderHelper.position.set(transform.x, transform.y, transform.z);
                    entity.boxColliderHelper.position.add(boxCollider.center);
                }
            }
            
            // Update tween helper with pulsing animation
            if (entity.tweenHelper) {
                entity.tweenHelper.position.set(transform.x, transform.y + 1, transform.z);
                
                // Pulsing effect
                const pulse = Math.sin(now * 0.005) * 0.3 + 0.7;
                entity.tweenHelper.material.opacity = pulse;
                
                // Slow rotation
                entity.tweenHelper.rotation.z += 0.02;
            }
            
            // Update animator helper with rotation
            if (entity.animatorHelper) {
                entity.animatorHelper.position.set(transform.x, transform.y + 2.5, transform.z);
                
                // Continuous rotation on multiple axes
                entity.animatorHelper.rotation.x += 0.03;
                entity.animatorHelper.rotation.y += 0.02;
                entity.animatorHelper.rotation.z += 0.01;
            }
            
            // Update Phase 3 component helpers
            if (entity.partyHelper) {
                entity.partyHelper.position.set(transform.x, transform.y + 2, transform.z);
                
                // Gentle bobbing animation for crown
                const bob = Math.sin(now * 0.003) * 0.1;
                entity.partyHelper.position.y += bob;
                
                // Slow rotation
                entity.partyHelper.rotation.y += 0.01;
            }
            
            if (entity.healthBarHelper) {
                entity.healthBarHelper.position.set(transform.x, transform.y + 1.8, transform.z);
                entity.healthBarHelper.lookAt(camera.position);
                
                // Update health bar color based on current health
                const character = entity.getComponent('CharacterComponent');
                if (character) {
                    const healthPercent = character.currentHealth / character.maxHealth;
                    const healthColor = healthPercent > 0.5 ? 0x4caf50 : healthPercent > 0.2 ? 0xffeb3b : 0xf44336;
                    entity.healthBarHelper.material.color.setHex(healthColor);
                    
                    // Scale health bar based on health percentage
                    entity.healthBarHelper.scale.x = healthPercent;
                }
            }
            
            if (entity.levelHelper) {
                entity.levelHelper.position.set(transform.x + 0.7, transform.y + 1.8, transform.z);
                entity.levelHelper.lookAt(camera.position);
                
                // Gentle pulsing for level indicator
                const pulse = Math.sin(now * 0.004) * 0.1 + 0.9;
                entity.levelHelper.scale.setScalar(pulse);
            }
            
            if (entity.aiHelper) {
                entity.aiHelper.position.set(transform.x - 0.7, transform.y + 1.8, transform.z);
                
                // Behavior-specific animations
                const ai = entity.getComponent('AIComponent');
                if (ai) {
                    switch(ai.behaviorType) {
                        case 'follow':
                            // Gentle floating motion
                            entity.aiHelper.position.y += Math.sin(now * 0.005) * 0.1;
                            break;
                        case 'guard':
                            // Steady pulsing
                            const guardPulse = Math.sin(now * 0.003) * 0.2 + 0.8;
                            entity.aiHelper.material.opacity = guardPulse;
                            break;
                        case 'patrol':
                            // Rotating motion
                            entity.aiHelper.rotation.y += 0.02;
                            break;
                        case 'aggressive':
                            // Rapid pulsing
                            const aggroPulse = Math.sin(now * 0.01) * 0.3 + 0.7;
                            entity.aiHelper.material.opacity = aggroPulse;
                            break;
                    }
                }
            }
            
            if (entity.combatHelper) {
                entity.combatHelper.position.set(transform.x, transform.y + 0.1, transform.z);
                
                // Pulsing attack range
                const rangePulse = Math.sin(now * 0.002) * 0.1 + 0.9;
                entity.combatHelper.scale.setScalar(rangePulse);
                
                // Slow rotation
                entity.combatHelper.rotation.z += 0.005;
            }
            
            if (entity.inventoryHelper) {
                entity.inventoryHelper.position.set(transform.x + 0.7, transform.y + 1.2, transform.z);
                
                // Gentle swaying motion
                const sway = Math.sin(now * 0.003) * 0.05;
                entity.inventoryHelper.rotation.z = sway;
                
                // Subtle scaling based on inventory state
                const inventory = entity.getComponent('InventoryComponent');
                if (inventory) {
                    const fillPercent = inventory.currentWeight / inventory.maxWeight;
                    const scale = 0.8 + (fillPercent * 0.4); // Scale from 0.8 to 1.2
                    entity.inventoryHelper.scale.setScalar(scale);
                }
            }
        }
        
        // Component toggle functionality
        function toggleComponent(entity, componentType, component) {
            const wasActive = component.active !== false;
            component.active = !wasActive;
            
            console.log(`🔄 ${wasActive ? 'Disabled' : 'Enabled'} ${componentType} for entity ${entity.id}`);
            
            // If this is the selected entity, update its visualizations immediately
            if (entity === selectedEntity) {
                // Always refresh visualizations to sync with component active states
                removeColliderVisualization(entity);
                addColliderVisualization(entity);
                
                // Maintain entity selection
                selectedEntity = entity;
            }
            
            // Force immediate update after toggle to show the change
            setTimeout(() => {
                updateInspector();
                updateSelectionUI();
            }, 0);
        }
        
        // Physics and animation components are now integrated directly into ECS
        // Users can add physics/animation components via the inspector using the + button
        
        // Initialize Lucide icons when they're loaded
        window.addEventListener('load', () => {
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
                
                // Re-create icons whenever the inspector updates
                const originalUpdateInspector = updateInspector;
                updateInspector = function() {
                    originalUpdateInspector();
                    setTimeout(() => lucide.createIcons(), 0);
                };
            }
        });
    </script>
</body>
</html>