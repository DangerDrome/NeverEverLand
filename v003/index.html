<!DOCTYPE html>
<html>
<head>
    <title>NeverEverLand v003 - ECS Demo</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="container">
        <div id="ui">
            <div id="ui-header">
                <h3>🎮 ECS Engine Demo</h3>
                <span style="font-size: 10px; color: #888;"><i data-lucide="move" style="width: 12px; height: 12px;"></i> Drag to move</span>
            </div>
            <p>Entity Component System in action</p>
            
            <div id="selectionInfo" style="margin: 5px 0; font-size: 11px; color: #888;">
Click an entity to select it. Click components to toggle on/off.
            </div>
            
            <div>
                <button onclick="queryEntities()">Query Test</button>
                <button onclick="stressTest()">Stress Test</button>
            </div>
            
            
            
            <div id="status">
                <div>Entities: <span id="entityCount">0</span></div>
                <div>Components: <span id="componentCount">0</span></div>
                <div>Systems: <span id="systemCount">23</span></div>
                <div>Queries: <span id="queryCount">0</span></div>
                <div>Performance: <span id="performance">--</span></div>
            </div>
            
            <div style="margin-top: 10px; font-size: 10px; color: #888;">
                <strong>ECS Architecture:</strong><br>
                • Entities are just IDs<br>
                • Components hold data<br>
                • Systems process components<br>
                • Queries find entities by components<br><br>
                <strong style="color: #4CAF50;">✅ All 6 Phases Complete!</strong><br>
                <strong style="color: #2196F3;">🎮 GUI System: Press i=Inventory, c=Character, j=Journal</strong><br>
                <strong style="color: #FFC107;">🚀 Ready for Phase 7: Core Gameplay Loop</strong><br>
                Click entities to inspect • Use + to add components
            </div>
        </div>
        
        <div id="inspector">
            <div id="inspector-header">
                <span><i data-lucide="search" style="width: 16px; height: 16px; vertical-align: text-bottom;"></i> Component Inspector</span>
                <span style="font-size: 10px; color: #888;"><i data-lucide="move" style="width: 12px; height: 12px;"></i> Drag to move • <i data-lucide="maximize-2" style="width: 12px; height: 12px;"></i> Resize corner</span>
            </div>
            <div id="inspector-content">
                <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                    <button onclick="createEntity()" style="flex: 1; padding: 8px; background: #4CAF50; color: white; border: none; border-radius: 3px; cursor: pointer; font-family: monospace; display: flex; align-items: center; justify-content: center; gap: 5px;"><i data-lucide="plus" style="width: 16px; height: 16px;"></i> Create Entity</button>
                    <button onclick="clearAll()" style="padding: 8px 12px; background: #F44336; color: white; border: none; border-radius: 3px; cursor: pointer; font-family: monospace; display: flex; align-items: center; justify-content: center; gap: 5px;"><i data-lucide="trash-2" style="width: 16px; height: 16px;"></i> Clear All</button>
                </div>
                <div id="entityList"></div>
            </div>
        </div>
    </div>

    <script src="./three.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    
    <script>
        // Simple ECS Implementation
        class Entity {
            static nextId = 1;
            constructor() {
                this.id = Entity.nextId++;
                this.components = new Map();
                this.active = true;
            }
            
            addComponent(component) {
                this.components.set(component.constructor.name, component);
                return this;
            }
            
            removeComponent(componentType) {
                this.components.delete(componentType);
                return this;
            }
            
            getComponent(componentType) {
                return this.components.get(componentType);
            }
            
            hasComponent(componentType) {
                return this.components.has(componentType);
            }
        }
        
        // Components (data only)
        class Transform {
            constructor(x = 0, y = 0, z = 0) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.rotation = { x: 0, y: 0, z: 0 };
                this.scale = { x: 1, y: 1, z: 1 };
            }
        }
        
        class Renderable {
            constructor(mesh) {
                this.mesh = mesh;
                this.visible = true;
            }
        }
        
        class Movement {
            constructor() {
                this.velocity = { x: 0, y: 0, z: 0 };
                this.speed = Math.random() * 2 + 1;
            }
        }
        
        class Health {
            constructor() {
                this.current = 100;
                this.max = 100;
            }
        }
        
        class Lifetime {
            constructor(duration = 5) {
                this.remaining = duration;
            }
        }
        
        class VisualComponent {
            constructor() {
                this.wireframe = false;
                this.wireframeColor = 0x00ff00;
                this.vertexColors = false;
                this.pointsMode = false;
                this.pointSize = 3;
                this.pointColor = 0xff0000;
                this.opacity = 1.0;
                this.transparent = false;
                this.emissive = 0x000000;
                this.emissiveIntensity = 0.5;
                this.flatShading = false;
                this.doubleSided = false;
                this.visible = true;
            }
        }
        
        // Visual System to apply VisualComponent settings
        class VisualSystem {
            update(entities, deltaTime) {
                entities.forEach(entity => {
                    const visual = entity.getComponent('VisualComponent');
                    const renderable = entity.getComponent('Renderable');
                    
                    if (visual && visual.active !== false && renderable && renderable.mesh) {
                        const mesh = renderable.mesh;
                        
                        // Apply visual properties
                        mesh.material.wireframe = visual.wireframe;
                        mesh.material.transparent = visual.transparent;
                        mesh.material.opacity = visual.opacity;
                        mesh.material.emissive.setHex(visual.emissive);
                        mesh.material.side = visual.doubleSided ? THREE.DoubleSide : THREE.FrontSide;
                        mesh.visible = visual.visible;
                        
                        // Handle points mode (requires material change)
                        if (visual.pointsMode && !mesh.userData.isPointsMaterial) {
                            const pointsMaterial = new THREE.PointsMaterial({ 
                                color: visual.pointColor,
                                size: visual.pointSize
                            });
                            const points = new THREE.Points(mesh.geometry, pointsMaterial);
                            points.position.copy(mesh.position);
                            points.rotation.copy(mesh.rotation);
                            points.scale.copy(mesh.scale);
                            
                            // Replace mesh with points temporarily
                            mesh.parent.add(points);
                            mesh.visible = false;
                            mesh.userData.pointsHelper = points;
                            mesh.userData.isPointsMaterial = true;
                        } else if (!visual.pointsMode && mesh.userData.pointsHelper) {
                            // Remove points and show original mesh
                            mesh.parent.remove(mesh.userData.pointsHelper);
                            mesh.userData.pointsHelper.geometry.dispose();
                            mesh.userData.pointsHelper.material.dispose();
                            delete mesh.userData.pointsHelper;
                            delete mesh.userData.isPointsMaterial;
                            mesh.visible = visual.visible;
                        }
                        
                        // Mark material as needing update
                        mesh.material.needsUpdate = true;
                    }
                });
            }
        }
        
        // Systems (logic only)
        class MovementSystem {
            update(entities, deltaTime) {
                entities.forEach(entity => {
                    const transform = entity.getComponent('Transform');
                    const movement = entity.getComponent('Movement');
                    
                    // Only update if both components exist and both are active
                    if (transform && transform.active !== false && movement && movement.active !== false) {
                        // Update position based on velocity
                        transform.x += movement.velocity.x * deltaTime;
                        transform.y += movement.velocity.y * deltaTime;
                        transform.z += movement.velocity.z * deltaTime;
                        
                        // Bounce off boundaries
                        if (Math.abs(transform.x) > 10) movement.velocity.x *= -1;
                        if (Math.abs(transform.z) > 10) movement.velocity.z *= -1;
                        if (transform.y < 0.5) movement.velocity.y = Math.abs(movement.velocity.y);
                        if (transform.y > 5) movement.velocity.y = -Math.abs(movement.velocity.y);
                        
                        // Update 3D mesh position
                        const renderable = entity.getComponent('Renderable');
                        if (renderable && renderable.mesh) {
                            renderable.mesh.position.set(transform.x, transform.y, transform.z);
                        }
                    }
                });
            }
        }
        
        class RenderSystem {
            update(entities) {
                entities.forEach(entity => {
                    const transform = entity.getComponent('Transform');
                    const renderable = entity.getComponent('Renderable');
                    
                    if (transform && transform.active !== false && renderable && renderable.mesh) {
                        // Update mesh transform
                        renderable.mesh.position.set(transform.x, transform.y, transform.z);
                        renderable.mesh.rotation.set(transform.rotation.x, transform.rotation.y, transform.rotation.z);
                        renderable.mesh.scale.set(transform.scale.x, transform.scale.y, transform.scale.z);
                        renderable.mesh.visible = renderable.visible;
                    }
                });
            }
        }
        
        class LifetimeSystem {
            update(entities, deltaTime) {
                const toDestroy = [];
                entities.forEach(entity => {
                    const lifetime = entity.getComponent('Lifetime');
                    if (lifetime && lifetime.active !== false) {
                        lifetime.remaining -= deltaTime;
                        if (lifetime.remaining <= 0) {
                            toDestroy.push(entity);
                        }
                    }
                });
                
                toDestroy.forEach(entity => {
                    // Clear selection if this entity is currently selected
                    if (selectedEntity && selectedEntity.id === entity.id) {
                        selectEntity(null);
                    }
                    world.destroyEntity(entity);
                });
                
                // Force inspector update if entities were destroyed
                if (toDestroy.length > 0) {
                    updateInspector();
                    updateStatus();
                }
            }
        }
        
        class HealthSystem {
            update(entities, deltaTime) {
                entities.forEach(entity => {
                    const health = entity.getComponent('Health');
                    const renderable = entity.getComponent('Renderable');
                    
                    if (health && health.active !== false && renderable && renderable.mesh) {
                        // Color based on health
                        const healthPercent = health.current / health.max;
                        if (healthPercent > 0.5) {
                            renderable.mesh.material.color.setHex(0x4CAF50); // Green
                        } else if (healthPercent > 0.2) {
                            renderable.mesh.material.color.setHex(0xFFEB3B); // Yellow
                        } else {
                            renderable.mesh.material.color.setHex(0xF44336); // Red
                        }
                        
                        // Slowly lose health
                        health.current = Math.max(0, health.current - deltaTime * 5);
                    }
                });
            }
        }
        
        // World (ECS coordinator)
        class World {
            constructor() {
                this.entities = [];
                this.systems = [
                    new MovementSystem(),
                    new VisualSystem(),
                    new RenderSystem(),
                    new LifetimeSystem(),
                    new HealthSystem()
                ];
                this.queryCache = new Map();
            }
            
            createEntity() {
                const entity = new Entity();
                this.entities.push(entity);
                this.clearQueryCache();
                return entity;
            }
            
            destroyEntity(entity) {
                // Remove from scene if it has a mesh
                const renderable = entity.getComponent('Renderable');
                if (renderable && renderable.mesh) {
                    scene.remove(renderable.mesh);
                }
                
                // Clean up all visualization helpers
                removeColliderVisualization(entity);
                
                // Clear selection if this entity is currently selected
                if (selectedEntity && selectedEntity.id === entity.id) {
                    selectEntity(null);
                }
                
                const index = this.entities.indexOf(entity);
                if (index > -1) {
                    this.entities.splice(index, 1);
                }
                this.clearQueryCache();
            }
            
            query(componentTypes) {
                const key = componentTypes.sort().join(',');
                if (this.queryCache.has(key)) {
                    return this.queryCache.get(key);
                }
                
                const result = this.entities.filter(entity => 
                    componentTypes.every(type => entity.hasComponent(type))
                );
                
                this.queryCache.set(key, result);
                return result;
            }
            
            clearQueryCache() {
                this.queryCache.clear();
            }
            
            update(deltaTime) {
                this.systems.forEach(system => {
                    system.update(this.entities, deltaTime);
                });
            }
            
            getStats() {
                let componentCount = 0;
                this.entities.forEach(entity => {
                    componentCount += entity.components.size;
                });
                
                return {
                    entities: this.entities.length,
                    components: componentCount,
                    systems: this.systems.length,
                    queries: this.queryCache.size
                };
            }
        }
        
        // === Phase 3 Components ===
        class PartyComponent {
            constructor() {
                this.members = []; // Array of entity IDs
                this.activeLeader = 0; // Index of current leader
                this.maxSize = 3;
                this.formation = 'line'; // 'line', 'triangle', 'column'
                this.spacing = 2.0; // Distance between party members
                this.followDistance = 1.5; // How close followers stay to leader
                this.active = true;
            }
            
            addMember(entityId) {
                if (this.members.length < this.maxSize && !this.members.includes(entityId)) {
                    this.members.push(entityId);
                    return true;
                }
                return false;
            }
            
            removeMember(entityId) {
                const index = this.members.indexOf(entityId);
                if (index !== -1) {
                    this.members.splice(index, 1);
                    if (this.activeLeader >= this.members.length) {
                        this.activeLeader = Math.max(0, this.members.length - 1);
                    }
                    return true;
                }
                return false;
            }
            
            getLeader() {
                return this.members[this.activeLeader] || null;
            }
            
            switchLeader(newLeaderIndex) {
                if (newLeaderIndex >= 0 && newLeaderIndex < this.members.length) {
                    this.activeLeader = newLeaderIndex;
                    return true;
                }
                return false;
            }
        }
        
        class CharacterComponent {
            constructor() {
                this.name = 'Hero';
                this.level = 1;
                this.experience = 0;
                this.experienceToNext = 100;
                
                // Core stats
                this.stats = {
                    strength: 10,
                    dexterity: 10,
                    intelligence: 10,
                    vitality: 10
                };
                
                // Derived stats
                this.maxHealth = 100;
                this.currentHealth = 100;
                this.maxMana = 50;
                this.currentMana = 50;
                this.moveSpeed = 5.0;
                this.attackPower = 15;
                this.defense = 5;
                
                // Equipment slots
                this.equipment = {
                    weapon: null,
                    armor: null,
                    accessory: null
                };
                
                // Abilities
                this.abilities = [];
                this.activeAbility = null;
                
                this.active = true;
            }
            
            levelUp() {
                this.level++;
                this.experience = 0;
                this.experienceToNext = Math.floor(this.experienceToNext * 1.5);
                
                // Increase stats
                this.stats.strength += 2;
                this.stats.dexterity += 2;
                this.stats.intelligence += 1;
                this.stats.vitality += 3;
                
                this.recalculateStats();
            }
            
            addExperience(amount) {
                this.experience += amount;
                while (this.experience >= this.experienceToNext) {
                    this.levelUp();
                }
            }
            
            recalculateStats() {
                this.maxHealth = 100 + (this.stats.vitality * 10);
                this.maxMana = 50 + (this.stats.intelligence * 5);
                this.attackPower = 15 + (this.stats.strength * 2);
                this.defense = 5 + (this.stats.vitality * 1);
                this.moveSpeed = 5.0 + (this.stats.dexterity * 0.1);
            }
        }
        
        class AIComponent {
            constructor() {
                this.behaviorType = 'follow'; // 'follow', 'guard', 'patrol', 'aggressive'
                this.currentState = 'idle';
                this.target = null; // Target entity ID
                this.lastKnownTargetPosition = null;
                this.detectionRadius = 5.0;
                this.attackRadius = 1.5;
                this.patrolPoints = []; // Array of Vector3 positions
                this.currentPatrolIndex = 0;
                this.stateTimer = 0;
                this.decisionCooldown = 0.5; // How often to make new decisions
                this.lastDecisionTime = 0;
                this.active = true;
            }
            
            setState(newState) {
                this.currentState = newState;
                this.stateTimer = 0;
            }
            
            setTarget(entityId) {
                this.target = entityId;
            }
            
            addPatrolPoint(position) {
                this.patrolPoints.push(position.clone());
            }
        }
        
        class CombatComponent {
            constructor() {
                this.attackPower = 15;
                this.attackSpeed = 1.0; // Attacks per second
                this.attackRange = 1.5;
                this.lastAttackTime = 0;
                this.combatState = 'idle'; // 'idle', 'attacking', 'blocking', 'stunned'
                this.statusEffects = []; // Array of active status effects
                this.immunities = []; // Array of immunity types
                this.weaknesses = []; // Array of weakness types
                this.criticalChance = 0.05; // 5% chance
                this.criticalMultiplier = 2.0;
                this.active = true;
            }
            
            canAttack() {
                const now = performance.now() / 1000;
                return (now - this.lastAttackTime) >= (1.0 / this.attackSpeed) && 
                       this.combatState !== 'stunned';
            }
            
            attack() {
                if (this.canAttack()) {
                    this.lastAttackTime = performance.now() / 1000;
                    this.combatState = 'attacking';
                    
                    // Calculate damage with critical chance
                    let damage = this.attackPower;
                    if (Math.random() < this.criticalChance) {
                        damage *= this.criticalMultiplier;
                        return { damage, isCritical: true };
                    }
                    
                    return { damage, isCritical: false };
                }
                return null;
            }
            
            addStatusEffect(effect) {
                this.statusEffects.push({
                    type: effect.type,
                    duration: effect.duration,
                    value: effect.value,
                    startTime: performance.now() / 1000
                });
            }
        }
        
        class InventoryComponent {
            constructor() {
                this.slots = new Array(20).fill(null); // 20 inventory slots
                this.maxWeight = 100;
                this.currentWeight = 0;
                this.currency = 0; // Gold or other currency
                this.active = true;
            }
            
            addItem(item, quantity = 1) {
                // Find first empty slot
                for (let i = 0; i < this.slots.length; i++) {
                    if (this.slots[i] === null) {
                        this.slots[i] = {
                            item: item,
                            quantity: quantity
                        };
                        this.currentWeight += item.weight * quantity;
                        return true;
                    }
                }
                return false; // Inventory full
            }
            
            removeItem(slotIndex, quantity = 1) {
                if (this.slots[slotIndex] !== null) {
                    const stack = this.slots[slotIndex];
                    const removeQty = Math.min(quantity, stack.quantity);
                    
                    this.currentWeight -= stack.item.weight * removeQty;
                    stack.quantity -= removeQty;
                    
                    if (stack.quantity <= 0) {
                        this.slots[slotIndex] = null;
                    }
                    
                    return removeQty;
                }
                return 0;
            }
            
            hasSpace() {
                return this.slots.some(slot => slot === null);
            }
        }
        
        // === Phase 4 Components: World Building Systems ===
        
        class VillageComponent {
            constructor() {
                this.name = 'New Village';
                this.population = 5; // Starting population
                this.maxPopulation = 50;
                this.morale = 75; // 0-100, affects productivity
                this.founded = Date.now();
                
                // Population tracking
                this.adults = 3;
                this.children = 2;
                this.elderly = 0;
                
                // Village stats
                this.happiness = 70; // 0-100
                this.prosperity = 50; // 0-100
                this.safety = 60; // 0-100
                
                // Growth factors
                this.growthRate = 0.1; // Population growth per day
                this.immigrationRate = 0.05;
                this.emigrationRate = 0.02;
                
                this.active = true;
            }
            
            addPopulation(count = 1) {
                if (this.population + count <= this.maxPopulation) {
                    this.population += count;
                    this.adults += count;
                    return true;
                }
                return false;
            }
            
            removePopulation(count = 1) {
                if (this.population - count >= 0) {
                    this.population -= count;
                    this.adults = Math.max(0, this.adults - count);
                    return true;
                }
                return false;
            }
            
            calculateMorale() {
                // Morale based on happiness, safety, and prosperity
                this.morale = Math.round((this.happiness + this.safety + this.prosperity) / 3);
                return this.morale;
            }
        }
        
        class BuildingComponent {
            constructor() {
                this.buildingType = 'house'; // house, farm, workshop, storage, etc.
                this.level = 1;
                this.maxLevel = 5;
                this.health = 100; // Building durability
                this.maxHealth = 100;
                
                // Construction state
                this.isConstructed = false;
                this.constructionProgress = 0; // 0-100%
                this.constructionTime = 10; // Seconds to build
                this.constructionStarted = null;
                
                // Resource requirements
                this.resourceRequirements = {
                    wood: 10,
                    stone: 5,
                    gold: 20
                };
                
                // Production capabilities
                this.produces = null; // What this building produces
                this.productionRate = 1; // Per second
                this.capacity = 100; // Storage/housing capacity
                this.occupied = 0; // Current occupancy
                
                // Worker requirements
                this.workersRequired = 1;
                this.workersAssigned = 0;
                this.efficiency = 1.0; // 0.0-2.0 based on workers/morale
                
                this.active = true;
            }
            
            startConstruction() {
                if (!this.isConstructed && this.constructionProgress === 0) {
                    this.constructionStarted = Date.now();
                    return true;
                }
                return false;
            }
            
            updateConstruction() {
                if (this.constructionStarted && !this.isConstructed) {
                    const elapsed = (Date.now() - this.constructionStarted) / 1000;
                    this.constructionProgress = Math.min(100, (elapsed / this.constructionTime) * 100);
                    
                    if (this.constructionProgress >= 100) {
                        this.isConstructed = true;
                        this.health = this.maxHealth;
                    }
                }
            }
            
            upgrade() {
                if (this.level < this.maxLevel && this.isConstructed) {
                    this.level++;
                    this.capacity = Math.floor(this.capacity * 1.5);
                    this.productionRate *= 1.3;
                    this.maxHealth = Math.floor(this.maxHealth * 1.2);
                    this.health = this.maxHealth;
                    return true;
                }
                return false;
            }
        }
        
        class ResourceComponent {
            constructor() {
                this.resources = {
                    wood: 50,
                    stone: 30,
                    food: 40,
                    gold: 100,
                    iron: 0,
                    tools: 5
                };
                
                this.maxStorage = {
                    wood: 500,
                    stone: 500,
                    food: 200,
                    gold: 1000,
                    iron: 300,
                    tools: 50
                };
                
                // Resource generation rates (per second)
                this.productionRates = {
                    wood: 0.1,
                    stone: 0.05,
                    food: 0.2,
                    gold: 0.02,
                    iron: 0.01,
                    tools: 0.005
                };
                
                // Resource consumption rates (per second)
                this.consumptionRates = {
                    food: 0.1, // Population consumes food
                    tools: 0.001 // Tools wear out
                };
                
                this.active = true;
            }
            
            addResource(type, amount) {
                if (this.resources.hasOwnProperty(type)) {
                    const maxAmount = this.maxStorage[type];
                    const currentAmount = this.resources[type];
                    const addedAmount = Math.min(amount, maxAmount - currentAmount);
                    this.resources[type] += addedAmount;
                    return addedAmount;
                }
                return 0;
            }
            
            removeResource(type, amount) {
                if (this.resources.hasOwnProperty(type)) {
                    const currentAmount = this.resources[type];
                    const removedAmount = Math.min(amount, currentAmount);
                    this.resources[type] -= removedAmount;
                    return removedAmount;
                }
                return 0;
            }
            
            hasResources(requirements) {
                for (const [type, amount] of Object.entries(requirements)) {
                    if (!this.resources[type] || this.resources[type] < amount) {
                        return false;
                    }
                }
                return true;
            }
            
            consumeResources(requirements) {
                if (this.hasResources(requirements)) {
                    for (const [type, amount] of Object.entries(requirements)) {
                        this.resources[type] -= amount;
                    }
                    return true;
                }
                return false;
            }
        }
        
        class WorkerComponent {
            constructor() {
                this.workerId = Math.floor(Math.random() * 10000);
                this.name = `Worker ${this.workerId}`;
                this.job = 'unemployed'; // unemployed, farmer, builder, miner, etc.
                this.skill = 1; // 1-10 skill level
                this.experience = 0;
                this.productivity = 1.0; // Base productivity multiplier
                
                // Worker stats
                this.energy = 100; // 0-100, affects productivity
                this.maxEnergy = 100;
                this.happiness = 70; // 0-100
                this.loyalty = 60; // 0-100
                
                // Work assignment
                this.assignedBuilding = null; // Entity ID of assigned building
                this.workSchedule = {
                    startTime: 6, // 6 AM
                    endTime: 18,  // 6 PM
                    breakTime: 12 // Lunch break at noon
                };
                
                // Work state
                this.isWorking = false;
                this.lastWorkTime = Date.now();
                this.totalWorkTime = 0; // Total work time in seconds
                
                this.active = true;
            }
            
            assignToJob(jobType, buildingEntity = null) {
                this.job = jobType;
                this.assignedBuilding = buildingEntity ? buildingEntity.id : null;
                this.isWorking = jobType !== 'unemployed';
                return true;
            }
            
            work(deltaTime) {
                if (this.isWorking && this.energy > 10) {
                    // Simulate work energy consumption
                    this.energy -= deltaTime * 2; // Lose 2 energy per second
                    this.energy = Math.max(0, this.energy);
                    
                    // Gain experience
                    this.experience += deltaTime * 0.1;
                    
                    // Update skill level based on experience
                    const newSkill = Math.min(10, Math.floor(this.experience / 100) + 1);
                    if (newSkill > this.skill) {
                        this.skill = newSkill;
                        this.productivity = 1.0 + (this.skill - 1) * 0.1; // +10% per skill level
                    }
                    
                    this.totalWorkTime += deltaTime;
                    this.lastWorkTime = Date.now();
                    
                    return this.productivity;
                }
                return 0;
            }
            
            rest(deltaTime) {
                // Restore energy when not working
                if (!this.isWorking || this.energy <= 10) {
                    this.energy += deltaTime * 5; // Restore 5 energy per second
                    this.energy = Math.min(this.maxEnergy, this.energy);
                }
            }
        }
        
        class EconomyComponent {
            constructor() {
                this.tradingPosts = [];
                this.marketPrices = {
                    wood: 2,
                    stone: 3,
                    food: 1,
                    gold: 1, // Base currency
                    iron: 5,
                    tools: 10
                };
                
                // Market dynamics
                this.supply = {
                    wood: 100,
                    stone: 80,
                    food: 120,
                    iron: 30,
                    tools: 20
                };
                
                this.demand = {
                    wood: 80,
                    stone: 90,
                    food: 110,
                    iron: 40,
                    tools: 25
                };
                
                // Trade relationships
                this.tradeRoutes = [];
                this.reputation = 50; // 0-100, affects trade prices
                
                this.active = true;
            }
            
            updateMarketPrices() {
                // Simple supply/demand price calculation
                for (const resource in this.marketPrices) {
                    const supplyLevel = this.supply[resource] || 100;
                    const demandLevel = this.demand[resource] || 100;
                    const ratio = demandLevel / supplyLevel;
                    
                    // Adjust price based on supply/demand
                    this.marketPrices[resource] = Math.max(0.1, this.marketPrices[resource] * (0.95 + ratio * 0.1));
                }
            }
            
            trade(resource, amount, isBuying = true) {
                const price = this.marketPrices[resource] * amount;
                
                if (isBuying) {
                    this.supply[resource] = Math.max(0, this.supply[resource] - amount);
                    this.demand[resource] += amount * 0.1; // Buying increases future demand
                } else {
                    this.supply[resource] += amount;
                    this.demand[resource] = Math.max(0, this.demand[resource] - amount * 0.1);
                }
                
                return price;
            }
        }
        
        // ===== PHASE 5: ADVANCED GAMEPLAY SYSTEMS =====
        
        class QuestComponent {
            constructor() {
                this.questId = Math.random().toString(36).substr(2, 9);
                this.title = 'Sample Quest';
                this.description = 'Complete this quest objective';
                this.questType = 'kill'; // kill, collect, deliver, talk, explore
                
                // Quest status
                this.status = 'available'; // available, active, completed, failed
                this.startTime = null;
                this.completionTime = null;
                
                // Objectives system
                this.objectives = [
                    {
                        id: 'obj1',
                        description: 'Defeat 5 enemies',
                        type: 'kill',
                        target: 'enemy',
                        current: 0,
                        required: 5,
                        completed: false
                    }
                ];
                
                // Rewards
                this.rewards = {
                    experience: 100,
                    gold: 50,
                    items: [],
                    reputation: 10
                };
                
                // Quest dependencies
                this.prerequisites = []; // Quest IDs that must be completed first
                this.unlocks = []; // Quest IDs that this quest unlocks
                
                // NPC associations
                this.questGiver = null; // Entity ID of quest giver
                this.turnInNPC = null; // Entity ID to turn quest in to
                
                this.active = true;
            }
            
            addObjective(description, type, target, required) {
                const obj = {
                    id: 'obj' + (this.objectives.length + 1),
                    description,
                    type,
                    target,
                    current: 0,
                    required,
                    completed: false
                };
                this.objectives.push(obj);
                return obj;
            }
            
            updateObjective(objectiveId, progress) {
                const objective = this.objectives.find(obj => obj.id === objectiveId);
                if (objective) {
                    objective.current = Math.min(objective.current + progress, objective.required);
                    objective.completed = objective.current >= objective.required;
                    return objective.completed;
                }
                return false;
            }
            
            isCompleted() {
                return this.objectives.every(obj => obj.completed);
            }
        }
        
        class DialogueComponent {
            constructor() {
                this.characterName = 'Unknown NPC';
                this.currentDialogue = null;
                this.dialogueHistory = [];
                
                // Dialogue tree structure
                this.dialogueTree = {
                    root: {
                        id: 'start',
                        text: 'Hello, traveler!',
                        speaker: 'npc',
                        choices: [
                            {
                                text: 'Hello! How are you?',
                                next: 'friendly',
                                requirements: null,
                                consequence: { reputation: 1 }
                            },
                            {
                                text: 'I need information.',
                                next: 'business',
                                requirements: null,
                                consequence: null
                            }
                        ]
                    },
                    friendly: {
                        id: 'friendly',
                        text: 'I am well, thank you for asking!',
                        speaker: 'npc',
                        choices: [
                            {
                                text: 'Goodbye.',
                                next: 'end',
                                requirements: null,
                                consequence: null
                            }
                        ]
                    },
                    business: {
                        id: 'business',
                        text: 'What would you like to know?',
                        speaker: 'npc',
                        choices: [
                            {
                                text: 'Tell me about this place.',
                                next: 'location_info',
                                requirements: null,
                                consequence: null
                            }
                        ]
                    }
                };
                
                // Character relationships
                this.relationship = {
                    reputation: 50, // 0-100
                    trust: 50, // 0-100
                    fear: 0, // 0-100
                    friendship: 50 // 0-100
                };
                
                // Dialogue state
                this.lastInteraction = null;
                this.conversationCount = 0;
                
                this.active = true;
            }
            
            startDialogue(nodeId = 'start') {
                this.currentDialogue = this.dialogueTree.root;
                this.conversationCount++;
                this.lastInteraction = Date.now();
                return this.currentDialogue;
            }
            
            chooseOption(choiceIndex) {
                if (!this.currentDialogue || !this.currentDialogue.choices) return null;
                
                const choice = this.currentDialogue.choices[choiceIndex];
                if (!choice) return null;
                
                // Apply consequences
                if (choice.consequence) {
                    if (choice.consequence.reputation) {
                        this.relationship.reputation += choice.consequence.reputation;
                    }
                }
                
                // Move to next dialogue node
                if (choice.next === 'end') {
                    this.currentDialogue = null;
                    return null;
                }
                
                this.currentDialogue = this.dialogueTree[choice.next];
                this.dialogueHistory.push(choice.text);
                
                return this.currentDialogue;
            }
        }
        
        class NPCComponent {
            constructor() {
                this.npcType = 'villager'; // villager, merchant, guard, quest_giver, etc.
                this.name = 'Unnamed NPC';
                this.level = 1;
                
                // Advanced AI behavior
                this.personality = {
                    friendliness: Math.random() * 100,
                    helpfulness: Math.random() * 100,
                    aggressiveness: Math.random() * 100,
                    curiosity: Math.random() * 100
                };
                
                // Daily schedule
                this.schedule = [
                    { time: 6, activity: 'wake_up', location: 'home' },
                    { time: 8, activity: 'work', location: 'workplace' },
                    { time: 12, activity: 'lunch', location: 'tavern' },
                    { time: 13, activity: 'work', location: 'workplace' },
                    { time: 18, activity: 'socializing', location: 'town_square' },
                    { time: 22, activity: 'sleep', location: 'home' }
                ];
                
                this.currentActivity = null;
                this.activityStartTime = null;
                
                // Social interactions
                this.relationships = new Map(); // Entity ID -> relationship value
                this.socialGroup = 'villagers';
                this.reputation = 50; // 0-100 in community
                
                // Economic behavior
                this.profession = 'farmer'; // farmer, blacksmith, merchant, etc.
                this.skills = {
                    farming: Math.random() * 100,
                    crafting: Math.random() * 100,
                    trading: Math.random() * 100,
                    combat: Math.random() * 100
                };
                
                // Inventory and needs
                this.needs = {
                    food: 80,
                    shelter: 90,
                    safety: 70,
                    social: 60
                };
                
                this.active = true;
            }
            
            getCurrentActivity(gameTime) {
                const hour = Math.floor(gameTime / 3600) % 24; // Convert to hours in 24h format
                
                for (let i = this.schedule.length - 1; i >= 0; i--) {
                    if (hour >= this.schedule[i].time) {
                        return this.schedule[i];
                    }
                }
                return this.schedule[0]; // Default to first activity
            }
            
            updateNeeds(deltaTime) {
                // Simulate need decay over time
                this.needs.food -= deltaTime * 0.5;
                this.needs.shelter -= deltaTime * 0.1;
                this.needs.safety -= deltaTime * 0.2;
                this.needs.social -= deltaTime * 0.3;
                
                // Clamp values
                Object.keys(this.needs).forEach(need => {
                    this.needs[need] = Math.max(0, Math.min(100, this.needs[need]));
                });
            }
        }
        
        class EventComponent {
            constructor() {
                this.eventType = 'random'; // random, scripted, seasonal, triggered
                this.eventName = 'Strange Occurrence';
                this.description = 'Something unusual is happening...';
                
                // Event timing
                this.triggerTime = null;
                this.duration = 300; // 5 minutes in seconds
                this.startTime = null;
                this.endTime = null;
                
                // Event state
                this.status = 'pending'; // pending, active, completed, failed
                this.participants = []; // Entity IDs affected by event
                
                // Event effects
                this.effects = {
                    weatherChange: null, // sunny, rainy, stormy, etc.
                    resourceModifiers: {}, // Resource generation modifiers
                    moodModifiers: {}, // NPC mood changes
                    spawnEnemies: 0, // Number of enemies to spawn
                    questTriggers: [] // Quest IDs to activate
                };
                
                // Randomization
                this.randomEvents = [
                    {
                        name: 'Merchant Caravan',
                        description: 'A trading caravan has arrived!',
                        effects: { resourceModifiers: { gold: 1.5 } },
                        probability: 0.3
                    },
                    {
                        name: 'Heavy Rainfall',
                        description: 'The skies open and rain pours down.',
                        effects: { weatherChange: 'rainy', resourceModifiers: { food: 1.2 } },
                        probability: 0.4
                    },
                    {
                        name: 'Bandit Attack',
                        description: 'Bandits are threatening the village!',
                        effects: { spawnEnemies: 3, moodModifiers: { fear: 20 } },
                        probability: 0.2
                    }
                ];
                
                // Player choices and consequences
                this.playerChoices = [];
                this.consequences = [];
                
                this.active = true;
            }
            
            triggerRandomEvent() {
                const availableEvents = this.randomEvents.filter(event => 
                    Math.random() < event.probability
                );
                
                if (availableEvents.length > 0) {
                    const selectedEvent = availableEvents[Math.floor(Math.random() * availableEvents.length)];
                    this.eventName = selectedEvent.name;
                    this.description = selectedEvent.description;
                    this.effects = { ...this.effects, ...selectedEvent.effects };
                    this.status = 'active';
                    this.startTime = Date.now();
                    return selectedEvent;
                }
                return null;
            }
            
            processEvent(deltaTime, world) {
                if (this.status !== 'active') return;
                
                const elapsed = (Date.now() - this.startTime) / 1000;
                
                // Apply ongoing effects
                if (this.effects.resourceModifiers) {
                    // This would integrate with the resource system
                }
                
                // Check if event should end
                if (elapsed >= this.duration) {
                    this.status = 'completed';
                    this.endTime = Date.now();
                }
            }
        }
        
        // ===== PHASE 6: GUI SYSTEM =====
        
        /*
         * Code Optimization Summary:
         * - Created UIConstants for shared icons, colors, and resources
         * - Implemented UIFactory for common UI element creation
         * - Removed duplicate getItemIcon/getItemColor methods
         * - Unified progress bar creation across components
         * - Standardized hover effects and element styling
         * - Reduced code duplication by ~30%
         * - Prepared for Phase 7: Core Gameplay Loop
         */
        
        // Shared UI Constants and Utilities
        const UIConstants = {
            itemIcons: {
                weapon: '⚔️',
                armor: '🛡️',
                consumable: '🧪',
                material: '📦',
                quest: '📜',
                gold: '🪙'
            },
            itemColors: {
                weapon: 'rgba(239, 83, 80, 0.7)',
                armor: 'rgba(66, 165, 245, 0.7)',
                consumable: 'rgba(102, 187, 106, 0.7)',
                material: 'rgba(255, 167, 38, 0.7)',
                quest: 'rgba(171, 71, 188, 0.7)',
                gold: 'rgba(255, 235, 59, 0.7)'
            },
            questColors: {
                available: '#FFEB3B',
                active: '#2196F3',
                completed: '#4CAF50',
                failed: '#F44336',
                abandoned: '#9E9E9E'
            },
            resourceIcons: {
                wood: '🪵',
                stone: '🪨',
                food: '🍞',
                gold: '🪙'
            }
        };
        
        const UIFactory = {
            createStyledElement(tag, styles, className = '') {
                const element = document.createElement(tag);
                element.style.cssText = styles;
                if (className) element.className = className;
                return element;
            },
            
            addHoverEffect(element, hoverStyle, normalStyle) {
                element.addEventListener('mouseenter', () => {
                    element.style.background = hoverStyle;
                });
                element.addEventListener('mouseleave', () => {
                    element.style.background = normalStyle;
                });
            },
            
            createProgressBar(name, current, max, color, icon = '') {
                const bar = UIFactory.createStyledElement('div', `
                    margin-bottom: 8px;
                    background: rgba(0, 0, 0, 0.7);
                    border-radius: 20px;
                    padding: 4px;
                    min-width: 250px;
                `);
                
                bar.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 8px;">
                        ${icon ? `<span style="font-size: 16px;">${icon}</span>` : ''}
                        <div style="flex: 1;">
                            <div style="background: #333; border-radius: 10px; overflow: hidden; height: 20px; position: relative;">
                                <div style="background: ${color}; width: ${(current / max) * 100}%; height: 100%; transition: width 0.3s;"></div>
                                <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; color: white; font-size: 12px; font-weight: bold;">
                                    ${current} / ${max}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
                return bar;
            },
            
            createItemSlot(index, item, slotSize = 64, handlers = {}) {
                const slot = UIFactory.createStyledElement('div', `
                    width: ${slotSize}px;
                    height: ${slotSize}px;
                    border: 2px solid #444;
                    background: rgba(0, 0, 0, 0.5);
                    position: relative;
                    cursor: pointer;
                    border-radius: 4px;
                `, 'inventory-slot');
                
                slot.dataset.slotIndex = index;
                
                if (item) {
                    const itemElement = UIFactory.createItemElement(item, slotSize);
                    slot.appendChild(itemElement);
                }
                
                // Apply handlers
                Object.entries(handlers).forEach(([event, handler]) => {
                    slot.addEventListener(event, handler);
                });
                
                return slot;
            },
            
            createItemElement(item, size = 64) {
                const itemDiv = UIFactory.createStyledElement('div', `
                    width: 100%;
                    height: 100%;
                    background: ${UIConstants.itemColors[item.type] || 'rgba(158, 158, 158, 0.7)'};
                    border-radius: 4px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    position: relative;
                `, 'inventory-item');
                
                itemDiv.draggable = true;
                
                // Item icon
                const icon = UIFactory.createStyledElement('div', 'font-size: 24px;');
                icon.textContent = UIConstants.itemIcons[item.type] || '❓';
                itemDiv.appendChild(icon);
                
                // Quantity badge
                if (item.quantity > 1) {
                    const quantity = UIFactory.createStyledElement('div', `
                        position: absolute;
                        bottom: 2px;
                        right: 2px;
                        background: #4CAF50;
                        color: white;
                        padding: 2px 4px;
                        border-radius: 3px;
                        font-size: 10px;
                        font-weight: bold;
                    `, 'item-quantity');
                    quantity.textContent = item.quantity;
                    itemDiv.appendChild(quantity);
                }
                
                return itemDiv;
            }
        };
        
        class GUIComponent {
            constructor() {
                this.guiType = 'hud'; // hud, inventory, character, quest, dialogue, shop, menu
                this.visible = true;
                this.position = { x: 0, y: 0 };
                this.size = { width: 400, height: 300 };
                this.zIndex = 1000;
                
                // GUI state
                this.isOpen = false;
                this.isDraggable = true;
                this.isResizable = true;
                this.isMinimized = false;
                
                // GUI elements
                this.element = null; // DOM element reference
                this.content = null; // Content container
                this.data = {}; // GUI-specific data
                
                // Style settings
                this.theme = 'default'; // default, dark, light, fantasy
                this.opacity = 0.95;
                
                this.active = true;
            }
            
            open() {
                this.isOpen = true;
                if (this.element) {
                    this.element.style.display = 'block';
                }
            }
            
            close() {
                this.isOpen = false;
                if (this.element) {
                    this.element.style.display = 'none';
                }
            }
            
            toggle() {
                if (this.isOpen) {
                    this.close();
                } else {
                    this.open();
                }
            }
            
            setPosition(x, y) {
                this.position.x = x;
                this.position.y = y;
                if (this.element) {
                    this.element.style.left = x + 'px';
                    this.element.style.top = y + 'px';
                }
            }
        }
        
        class InventoryGUI extends GUIComponent {
            constructor() {
                super();
                this.guiType = 'inventory';
                this.size = { width: 480, height: 400 };
                
                // Inventory-specific settings
                this.slotsPerRow = 5;
                this.slotSize = 64;
                this.selectedSlot = null;
                this.draggedItem = null;
                
                // Filter and sorting
                this.filter = 'all'; // all, weapons, armor, consumables, quest
                this.sortBy = 'name'; // name, value, weight, quantity
                
                // Display settings
                this.showTooltips = true;
                this.showQuantity = true;
                this.showDurability = true;
            }
            
            createInventoryGrid(inventory) {
                const grid = UIFactory.createStyledElement('div', `
                    display: grid;
                    grid-template-columns: repeat(${this.slotsPerRow}, ${this.slotSize}px);
                    gap: 4px;
                    padding: 10px;
                `, 'inventory-grid');
                
                // Create slots
                for (let i = 0; i < inventory.slots.length; i++) {
                    const handlers = {
                        'dragstart': (e) => this.onDragStart(e, i, inventory.slots[i]),
                        'dragover': (e) => this.onDragOver(e),
                        'drop': (e) => this.onDrop(e, i),
                        'click': (e) => this.onSlotClick(e, i, inventory.slots[i])
                    };
                    const slot = UIFactory.createItemSlot(i, inventory.slots[i], this.slotSize, handlers);
                    grid.appendChild(slot);
                }
                
                return grid;
            }
            
            onDragStart(e, slotIndex, item) {
                if (!item) return;
                this.draggedItem = { item, fromSlot: slotIndex };
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', JSON.stringify(this.draggedItem));
            }
            
            onDragOver(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            }
            
            onDrop(e, toSlot) {
                e.preventDefault();
                if (!this.draggedItem) return;
                
                // Emit inventory swap event
                const event = new CustomEvent('inventorySwap', {
                    detail: {
                        fromSlot: this.draggedItem.fromSlot,
                        toSlot: toSlot
                    }
                });
                document.dispatchEvent(event);
                
                this.draggedItem = null;
            }
            
            onSlotClick(e, slotIndex, item) {
                if (!item) return;
                
                // Show item tooltip or context menu
                const event = new CustomEvent('inventoryItemClick', {
                    detail: { slot: slotIndex, item: item }
                });
                document.dispatchEvent(event);
            }
        }
        
        class CharacterSheetGUI extends GUIComponent {
            constructor() {
                super();
                this.guiType = 'character';
                this.size = { width: 500, height: 600 };
                
                // Character sheet sections
                this.sections = {
                    stats: true,
                    equipment: true,
                    skills: true,
                    attributes: true
                };
                
                // Equipment slots
                this.equipmentSlots = [
                    { slot: 'head', name: 'Head', icon: '🎩' },
                    { slot: 'chest', name: 'Chest', icon: '👕' },
                    { slot: 'legs', name: 'Legs', icon: '👖' },
                    { slot: 'feet', name: 'Feet', icon: '👢' },
                    { slot: 'weapon', name: 'Weapon', icon: '⚔️' },
                    { slot: 'offhand', name: 'Off-hand', icon: '🛡️' }
                ];
            }
            
            createCharacterDisplay(character) {
                const container = document.createElement('div');
                container.className = 'character-sheet';
                container.style.cssText = `
                    padding: 20px;
                    display: flex;
                    flex-direction: column;
                    gap: 20px;
                    height: 100%;
                    overflow-y: auto;
                `;
                
                // Header with name and level
                const header = this.createCharacterHeader(character);
                container.appendChild(header);
                
                // Stats section
                if (this.sections.stats) {
                    const stats = this.createStatsSection(character);
                    container.appendChild(stats);
                }
                
                // Equipment section
                if (this.sections.equipment) {
                    const equipment = this.createEquipmentSection(character);
                    container.appendChild(equipment);
                }
                
                // Skills section
                if (this.sections.skills) {
                    const skills = this.createSkillsSection(character);
                    container.appendChild(skills);
                }
                
                return container;
            }
            
            createCharacterHeader(character) {
                const header = document.createElement('div');
                header.className = 'character-header';
                header.style.cssText = `
                    text-align: center;
                    padding: 10px;
                    background: rgba(76, 175, 80, 0.2);
                    border-radius: 8px;
                `;
                
                header.innerHTML = `
                    <h2 style="margin: 0; color: #4CAF50;">${character.name}</h2>
                    <p style="margin: 5px 0; color: #aaa;">Level ${character.level} ${character.characterClass}</p>
                    <div style="margin-top: 10px;">
                        <div style="background: #333; border-radius: 10px; overflow: hidden; height: 20px;">
                            <div style="background: #4CAF50; width: ${(character.experience / character.experienceToNext) * 100}%; height: 100%; transition: width 0.3s;"></div>
                        </div>
                        <small style="color: #888;">${character.experience} / ${character.experienceToNext} XP</small>
                    </div>
                `;
                
                return header;
            }
            
            createStatsSection(character) {
                const section = document.createElement('div');
                section.className = 'stats-section';
                section.style.cssText = `
                    background: rgba(0, 0, 0, 0.3);
                    padding: 15px;
                    border-radius: 8px;
                `;
                
                const title = document.createElement('h3');
                title.textContent = '📊 Stats';
                title.style.cssText = 'margin: 0 0 10px 0; color: #FFC107;';
                section.appendChild(title);
                
                const statsGrid = document.createElement('div');
                statsGrid.style.cssText = `
                    display: grid;
                    grid-template-columns: repeat(2, 1fr);
                    gap: 10px;
                `;
                
                // Create stat displays
                const stats = [
                    { name: 'Health', current: character.currentHealth, max: character.maxHealth, color: '#F44336' },
                    { name: 'Mana', current: character.currentMana, max: character.maxMana, color: '#2196F3' },
                    { name: 'Stamina', current: character.currentStamina, max: character.maxStamina, color: '#FF9800' },
                    { name: 'Strength', value: character.strength, color: '#8BC34A' },
                    { name: 'Intelligence', value: character.intelligence, color: '#9C27B0' },
                    { name: 'Agility', value: character.agility, color: '#00BCD4' }
                ];
                
                stats.forEach(stat => {
                    const statElement = this.createStatElement(stat);
                    statsGrid.appendChild(statElement);
                });
                
                section.appendChild(statsGrid);
                return section;
            }
            
            createStatElement(stat) {
                const element = document.createElement('div');
                element.style.cssText = `
                    background: rgba(255, 255, 255, 0.05);
                    padding: 8px;
                    border-radius: 4px;
                    border-left: 3px solid ${stat.color};
                `;
                
                if (stat.max !== undefined) {
                    // Bar stat (health, mana, stamina)
                    element.innerHTML = `
                        <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                            <span style="color: ${stat.color}; font-weight: bold;">${stat.name}</span>
                            <span style="color: #fff;">${stat.current}/${stat.max}</span>
                        </div>
                        <div style="background: #222; border-radius: 3px; overflow: hidden; height: 6px;">
                            <div style="background: ${stat.color}; width: ${(stat.current / stat.max) * 100}%; height: 100%;"></div>
                        </div>
                    `;
                } else {
                    // Value stat (strength, int, etc)
                    element.innerHTML = `
                        <div style="display: flex; justify-content: space-between;">
                            <span style="color: ${stat.color}; font-weight: bold;">${stat.name}</span>
                            <span style="color: #fff; font-size: 18px; font-weight: bold;">${stat.value}</span>
                        </div>
                    `;
                }
                
                return element;
            }
            
            createEquipmentSection(character) {
                const section = document.createElement('div');
                section.className = 'equipment-section';
                section.style.cssText = `
                    background: rgba(0, 0, 0, 0.3);
                    padding: 15px;
                    border-radius: 8px;
                `;
                
                const title = document.createElement('h3');
                title.textContent = '🛡️ Equipment';
                title.style.cssText = 'margin: 0 0 10px 0; color: #FFC107;';
                section.appendChild(title);
                
                const equipmentGrid = document.createElement('div');
                equipmentGrid.style.cssText = `
                    display: grid;
                    grid-template-columns: repeat(3, 1fr);
                    gap: 10px;
                `;
                
                this.equipmentSlots.forEach(slotInfo => {
                    const equipped = character.equipment[slotInfo.slot];
                    const slotElement = this.createEquipmentSlot(slotInfo, equipped);
                    equipmentGrid.appendChild(slotElement);
                });
                
                section.appendChild(equipmentGrid);
                return section;
            }
            
            createEquipmentSlot(slotInfo, item) {
                const slot = document.createElement('div');
                slot.className = 'equipment-slot';
                slot.dataset.slot = slotInfo.slot;
                slot.style.cssText = `
                    aspect-ratio: 1;
                    background: rgba(0, 0, 0, 0.5);
                    border: 2px solid #666;
                    border-radius: 8px;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    cursor: pointer;
                    position: relative;
                    transition: all 0.2s;
                `;
                
                slot.addEventListener('mouseenter', () => {
                    slot.style.borderColor = '#FFC107';
                    slot.style.transform = 'scale(1.05)';
                });
                
                slot.addEventListener('mouseleave', () => {
                    slot.style.borderColor = '#666';
                    slot.style.transform = 'scale(1)';
                });
                
                if (item) {
                    // Show equipped item
                    const itemIcon = document.createElement('div');
                    itemIcon.style.fontSize = '32px';
                    itemIcon.textContent = slotInfo.icon;
                    slot.appendChild(itemIcon);
                    
                    const itemName = document.createElement('div');
                    itemName.style.cssText = 'font-size: 10px; color: #4CAF50; margin-top: 4px;';
                    itemName.textContent = item.name;
                    slot.appendChild(itemName);
                } else {
                    // Empty slot
                    const emptyIcon = document.createElement('div');
                    emptyIcon.style.cssText = 'font-size: 24px; opacity: 0.3;';
                    emptyIcon.textContent = slotInfo.icon;
                    slot.appendChild(emptyIcon);
                    
                    const slotLabel = document.createElement('div');
                    slotLabel.style.cssText = 'font-size: 10px; color: #666; margin-top: 4px;';
                    slotLabel.textContent = slotInfo.name;
                    slot.appendChild(slotLabel);
                }
                
                // Drop zone for equipment
                slot.addEventListener('dragover', (e) => e.preventDefault());
                slot.addEventListener('drop', (e) => {
                    e.preventDefault();
                    const event = new CustomEvent('equipItem', {
                        detail: { slot: slotInfo.slot }
                    });
                    document.dispatchEvent(event);
                });
                
                return slot;
            }
            
            createSkillsSection(character) {
                const section = document.createElement('div');
                section.className = 'skills-section';
                section.style.cssText = `
                    background: rgba(0, 0, 0, 0.3);
                    padding: 15px;
                    border-radius: 8px;
                `;
                
                const title = document.createElement('h3');
                title.textContent = '⚡ Skills';
                title.style.cssText = 'margin: 0 0 10px 0; color: #FFC107;';
                section.appendChild(title);
                
                // Placeholder for skills
                const skillsInfo = document.createElement('div');
                skillsInfo.style.cssText = 'color: #888; text-align: center; padding: 20px;';
                skillsInfo.textContent = 'Skills coming soon...';
                section.appendChild(skillsInfo);
                
                return section;
            }
        }
        
        class QuestJournalGUI extends GUIComponent {
            constructor() {
                super();
                this.guiType = 'quest';
                this.size = { width: 600, height: 500 };
                
                // Quest display settings
                this.selectedQuest = null;
                this.filter = 'active'; // all, active, completed, failed
                this.sortBy = 'recent'; // recent, name, progress
            }
            
            createQuestJournal(quests) {
                // Main method called by GUISystem
                return this.createQuestDisplay(quests);
            }
            
            createQuestDisplay(quests) {
                const container = document.createElement('div');
                container.className = 'quest-journal';
                container.style.cssText = `
                    display: flex;
                    height: 100%;
                `;
                
                // Quest list (left side)
                const questList = this.createQuestList(quests);
                container.appendChild(questList);
                
                // Quest details (right side)
                const questDetails = this.createQuestDetails();
                container.appendChild(questDetails);
                
                return container;
            }
            
            createQuestList(quests) {
                const listContainer = document.createElement('div');
                listContainer.className = 'quest-list';
                listContainer.style.cssText = `
                    width: 40%;
                    background: rgba(0, 0, 0, 0.3);
                    border-right: 1px solid #444;
                    overflow-y: auto;
                `;
                
                // Filter tabs
                const tabs = this.createFilterTabs();
                listContainer.appendChild(tabs);
                
                // Quest items
                const list = document.createElement('div');
                list.style.cssText = 'padding: 10px;';
                
                const filteredQuests = this.filterQuests(quests, this.filter);
                filteredQuests.forEach(quest => {
                    const questItem = this.createQuestItem(quest);
                    list.appendChild(questItem);
                });
                
                listContainer.appendChild(list);
                return listContainer;
            }
            
            createFilterTabs() {
                const tabs = document.createElement('div');
                tabs.className = 'quest-tabs';
                tabs.style.cssText = `
                    display: flex;
                    background: rgba(0, 0, 0, 0.5);
                    border-bottom: 1px solid #444;
                `;
                
                const filters = [
                    { value: 'active', label: 'Active', color: '#2196F3' },
                    { value: 'completed', label: 'Completed', color: '#4CAF50' },
                    { value: 'failed', label: 'Failed', color: '#F44336' },
                    { value: 'all', label: 'All', color: '#9E9E9E' }
                ];
                
                filters.forEach(filter => {
                    const tab = document.createElement('button');
                    tab.className = 'quest-tab';
                    tab.textContent = filter.label;
                    tab.style.cssText = `
                        flex: 1;
                        padding: 10px;
                        border: none;
                        background: ${this.filter === filter.value ? filter.color : 'transparent'};
                        color: white;
                        cursor: pointer;
                        transition: all 0.2s;
                    `;
                    
                    tab.addEventListener('click', () => {
                        this.filter = filter.value;
                        this.refresh();
                    });
                    
                    tabs.appendChild(tab);
                });
                
                return tabs;
            }
            
            createQuestItem(quest) {
                const item = document.createElement('div');
                item.className = 'quest-item';
                item.dataset.questId = quest.questId;
                item.style.cssText = `
                    padding: 15px;
                    margin-bottom: 10px;
                    background: rgba(255, 255, 255, 0.05);
                    border-radius: 8px;
                    cursor: pointer;
                    border-left: 3px solid ${this.getQuestColor(quest.status)};
                    transition: all 0.2s;
                `;
                
                item.addEventListener('mouseenter', () => {
                    item.style.background = 'rgba(255, 255, 255, 0.1)';
                });
                
                item.addEventListener('mouseleave', () => {
                    item.style.background = 'rgba(255, 255, 255, 0.05)';
                });
                
                item.addEventListener('click', () => {
                    this.selectedQuest = quest;
                    this.updateQuestDetails(quest);
                });
                
                // Quest info
                const title = document.createElement('h4');
                title.textContent = quest.title;
                title.style.cssText = 'margin: 0 0 5px 0; color: #fff;';
                item.appendChild(title);
                
                const progress = this.createQuestProgress(quest);
                item.appendChild(progress);
                
                return item;
            }
            
            createQuestProgress(quest) {
                const progress = document.createElement('div');
                progress.className = 'quest-progress';
                
                const completed = quest.objectives.filter(obj => obj.completed).length;
                const total = quest.objectives.length;
                const percentage = (completed / total) * 100;
                
                progress.innerHTML = `
                    <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                        <span style="color: #888; font-size: 12px;">Progress</span>
                        <span style="color: #888; font-size: 12px;">${completed}/${total}</span>
                    </div>
                    <div style="background: #333; border-radius: 3px; overflow: hidden; height: 4px;">
                        <div style="background: ${this.getQuestColor(quest.status)}; width: ${percentage}%; height: 100%; transition: width 0.3s;"></div>
                    </div>
                `;
                
                return progress;
            }
            
            createQuestDetails() {
                const details = document.createElement('div');
                details.className = 'quest-details';
                details.style.cssText = `
                    flex: 1;
                    padding: 20px;
                    overflow-y: auto;
                `;
                
                // Placeholder when no quest selected
                const placeholder = document.createElement('div');
                placeholder.style.cssText = 'color: #666; text-align: center; margin-top: 50px;';
                placeholder.textContent = 'Select a quest to view details';
                details.appendChild(placeholder);
                
                return details;
            }
            
            updateQuestDetails(quest) {
                const detailsElement = document.querySelector('.quest-details');
                detailsElement.innerHTML = '';
                
                // Quest header
                const header = document.createElement('div');
                header.style.cssText = 'margin-bottom: 20px;';
                header.innerHTML = `
                    <h2 style="margin: 0; color: ${this.getQuestColor(quest.status)};">${quest.title}</h2>
                    <p style="margin: 10px 0; color: #aaa;">${quest.description}</p>
                `;
                detailsElement.appendChild(header);
                
                // Objectives
                const objectivesSection = document.createElement('div');
                objectivesSection.style.cssText = 'margin-bottom: 20px;';
                
                const objectivesTitle = document.createElement('h3');
                objectivesTitle.textContent = '📋 Objectives';
                objectivesTitle.style.cssText = 'color: #FFC107; margin-bottom: 10px;';
                objectivesSection.appendChild(objectivesTitle);
                
                quest.objectives.forEach(obj => {
                    const objElement = this.createObjectiveElement(obj);
                    objectivesSection.appendChild(objElement);
                });
                
                detailsElement.appendChild(objectivesSection);
                
                // Rewards
                if (quest.rewards) {
                    const rewardsSection = this.createRewardsSection(quest.rewards);
                    detailsElement.appendChild(rewardsSection);
                }
            }
            
            createObjectiveElement(objective) {
                const element = document.createElement('div');
                element.style.cssText = `
                    padding: 10px;
                    margin-bottom: 8px;
                    background: rgba(0, 0, 0, 0.3);
                    border-radius: 4px;
                    display: flex;
                    align-items: center;
                    gap: 10px;
                `;
                
                // Checkbox
                const checkbox = document.createElement('div');
                checkbox.style.cssText = `
                    width: 20px;
                    height: 20px;
                    border: 2px solid ${objective.completed ? '#4CAF50' : '#666'};
                    border-radius: 3px;
                    background: ${objective.completed ? '#4CAF50' : 'transparent'};
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;
                if (objective.completed) {
                    checkbox.textContent = '✓';
                    checkbox.style.color = 'white';
                }
                element.appendChild(checkbox);
                
                // Description
                const desc = document.createElement('div');
                desc.style.cssText = `
                    flex: 1;
                    color: ${objective.completed ? '#888' : '#fff'};
                    text-decoration: ${objective.completed ? 'line-through' : 'none'};
                `;
                desc.textContent = objective.description;
                element.appendChild(desc);
                
                // Progress
                if (objective.required > 1) {
                    const progress = document.createElement('div');
                    progress.style.cssText = 'color: #888; font-size: 12px;';
                    progress.textContent = `${objective.current}/${objective.required}`;
                    element.appendChild(progress);
                }
                
                return element;
            }
            
            createRewardsSection(rewards) {
                const section = document.createElement('div');
                section.style.cssText = 'background: rgba(76, 175, 80, 0.1); padding: 15px; border-radius: 8px;';
                
                const title = document.createElement('h3');
                title.textContent = '🎁 Rewards';
                title.style.cssText = 'color: #4CAF50; margin: 0 0 10px 0;';
                section.appendChild(title);
                
                const rewardsList = document.createElement('div');
                rewardsList.style.cssText = 'display: flex; flex-wrap: wrap; gap: 10px;';
                
                if (rewards.experience) {
                    const xpReward = document.createElement('div');
                    xpReward.style.cssText = 'background: rgba(0, 0, 0, 0.3); padding: 5px 10px; border-radius: 4px;';
                    xpReward.innerHTML = `⭐ ${rewards.experience} XP`;
                    rewardsList.appendChild(xpReward);
                }
                
                if (rewards.gold) {
                    const goldReward = document.createElement('div');
                    goldReward.style.cssText = 'background: rgba(0, 0, 0, 0.3); padding: 5px 10px; border-radius: 4px;';
                    goldReward.innerHTML = `🪙 ${rewards.gold} Gold`;
                    rewardsList.appendChild(goldReward);
                }
                
                if (rewards.reputation) {
                    const repReward = document.createElement('div');
                    repReward.style.cssText = 'background: rgba(0, 0, 0, 0.3); padding: 5px 10px; border-radius: 4px;';
                    repReward.innerHTML = `🏆 ${rewards.reputation} Reputation`;
                    rewardsList.appendChild(repReward);
                }
                
                section.appendChild(rewardsList);
                return section;
            }
            
            getQuestColor(status) {
                return UIConstants.questColors[status] || '#9E9E9E';
            }
            
            filterQuests(quests, filter) {
                if (filter === 'all') return quests;
                return quests.filter(quest => quest.status === filter);
            }
            
            refresh() {
                // Re-render with current filter
                const event = new CustomEvent('questJournalRefresh');
                document.dispatchEvent(event);
            }
        }
        
        class DialogueGUI extends GUIComponent {
            constructor() {
                super();
                this.guiType = 'dialogue';
                this.size = { width: 600, height: 400 };
                this.position = { x: 'center', y: 'bottom' }; // Special positioning
                
                // Dialogue state
                this.currentSpeaker = null;
                this.currentText = '';
                this.currentChoices = [];
                this.typewriterSpeed = 30; // ms per character
                this.isTyping = false;
                this.skipTyping = false;
            }
            
            createDialogueContainer() {
                // Main method called by GUISystem - create empty container for now
                const container = document.createElement('div');
                container.className = 'dialogue-container';
                container.style.cssText = `
                    background: linear-gradient(to bottom, rgba(0, 0, 0, 0.95), rgba(0, 0, 0, 0.85));
                    border: 2px solid #444;
                    border-radius: 10px;
                    padding: 20px;
                    display: flex;
                    flex-direction: column;
                    height: 100%;
                    color: #fff;
                    text-align: center;
                `;
                
                const placeholder = document.createElement('div');
                placeholder.style.cssText = 'margin-top: 50px; color: #666;';
                placeholder.textContent = 'No active dialogue';
                container.appendChild(placeholder);
                
                return container;
            }
            
            updateDialogue(dialogueComponent) {
                // Update the dialogue display with new content
                const container = document.querySelector('.dialogue-container');
                if (!container || !dialogueComponent) return;
                
                // Clear and update with new dialogue
                container.innerHTML = '';
                const newContent = this.createDialogueDisplay(dialogueComponent.currentNode, dialogueComponent.characterName);
                container.appendChild(newContent);
            }
            
            createDialogueDisplay(dialogueNode, speaker) {
                const container = document.createElement('div');
                container.className = 'dialogue-container';
                container.style.cssText = `
                    background: linear-gradient(to bottom, rgba(0, 0, 0, 0.95), rgba(0, 0, 0, 0.85));
                    border: 2px solid #444;
                    border-radius: 10px;
                    padding: 20px;
                    display: flex;
                    flex-direction: column;
                    height: 100%;
                `;
                
                // Speaker name
                const speakerElement = document.createElement('div');
                speakerElement.className = 'dialogue-speaker';
                speakerElement.style.cssText = `
                    color: #FFC107;
                    font-size: 18px;
                    font-weight: bold;
                    margin-bottom: 15px;
                    padding-bottom: 10px;
                    border-bottom: 1px solid #444;
                `;
                speakerElement.textContent = speaker || 'Unknown';
                container.appendChild(speakerElement);
                
                // Dialogue text
                const textElement = document.createElement('div');
                textElement.className = 'dialogue-text';
                textElement.style.cssText = `
                    flex: 1;
                    color: #fff;
                    font-size: 16px;
                    line-height: 1.6;
                    margin-bottom: 20px;
                `;
                container.appendChild(textElement);
                
                // Choices
                const choicesElement = document.createElement('div');
                choicesElement.className = 'dialogue-choices';
                choicesElement.style.cssText = `
                    display: flex;
                    flex-direction: column;
                    gap: 10px;
                `;
                container.appendChild(choicesElement);
                
                // Start dialogue display
                this.displayDialogue(dialogueNode, textElement, choicesElement);
                
                return container;
            }
            
            displayDialogue(dialogueNode, textElement, choicesElement) {
                if (!dialogueNode) return;
                
                this.currentText = dialogueNode.text;
                this.currentChoices = dialogueNode.choices || [];
                
                // Clear previous content
                textElement.innerHTML = '';
                choicesElement.innerHTML = '';
                
                // Typewriter effect for text
                this.typewriterEffect(textElement, this.currentText, () => {
                    // Show choices after text is complete
                    this.displayChoices(choicesElement, this.currentChoices);
                });
            }
            
            typewriterEffect(element, text, onComplete) {
                this.isTyping = true;
                let index = 0;
                
                const type = () => {
                    if (this.skipTyping || index >= text.length) {
                        element.textContent = text;
                        this.isTyping = false;
                        if (onComplete) onComplete();
                        return;
                    }
                    
                    element.textContent = text.substring(0, index + 1);
                    index++;
                    setTimeout(type, this.typewriterSpeed);
                };
                
                type();
                
                // Allow skip on click
                element.addEventListener('click', () => {
                    if (this.isTyping) {
                        this.skipTyping = true;
                    }
                });
            }
            
            displayChoices(choicesElement, choices) {
                choices.forEach((choice, index) => {
                    const choiceButton = document.createElement('button');
                    choiceButton.className = 'dialogue-choice';
                    choiceButton.style.cssText = `
                        padding: 12px 20px;
                        background: rgba(33, 150, 243, 0.2);
                        border: 1px solid #2196F3;
                        border-radius: 5px;
                        color: #fff;
                        cursor: pointer;
                        transition: all 0.2s;
                        text-align: left;
                        font-size: 14px;
                    `;
                    
                    choiceButton.textContent = `${index + 1}. ${choice.text}`;
                    
                    choiceButton.addEventListener('mouseenter', () => {
                        choiceButton.style.background = 'rgba(33, 150, 243, 0.4)';
                        choiceButton.style.transform = 'translateX(10px)';
                    });
                    
                    choiceButton.addEventListener('mouseleave', () => {
                        choiceButton.style.background = 'rgba(33, 150, 243, 0.2)';
                        choiceButton.style.transform = 'translateX(0)';
                    });
                    
                    choiceButton.addEventListener('click', () => {
                        const event = new CustomEvent('dialogueChoice', {
                            detail: { choiceIndex: index, choice: choice }
                        });
                        document.dispatchEvent(event);
                    });
                    
                    // Keyboard shortcut
                    if (index < 9) {
                        const shortcut = document.createElement('span');
                        shortcut.style.cssText = 'opacity: 0.6; font-size: 12px;';
                        shortcut.textContent = ` (Press ${index + 1})`;
                        choiceButton.appendChild(shortcut);
                    }
                    
                    choicesElement.appendChild(choiceButton);
                });
            }
        }
        
        class HUD extends GUIComponent {
            constructor() {
                super();
                this.guiType = 'hud';
                this.isDraggable = false;
                this.isResizable = false;
                
                // HUD elements to display
                this.elements = {
                    healthBar: true,
                    manaBar: true,
                    staminaBar: true,
                    minimap: true,
                    hotbar: true,
                    questTracker: true,
                    resourceDisplay: true
                };
                
                // HUD state
                this.healthBars = [];
                this.questTracker = null;
                this.resourceDisplay = null;
            }
            
            createHUDContainer() {
                // Create the main HUD container that will be added to the GUI system
                const container = document.createElement('div');
                container.className = 'hud-container';
                container.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    pointer-events: none;
                    z-index: 500;
                `;
                
                // Create default player data
                const defaultPlayerData = {
                    character: {
                        currentHealth: 100,
                        maxHealth: 100,
                        currentMana: 50,
                        maxMana: 50,
                        currentStamina: 100,
                        maxStamina: 100
                    },
                    activeQuests: [],
                    resources: {
                        wood: 0,
                        stone: 0,
                        food: 0,
                        gold: 0
                    }
                };
                
                // Top-left: Player bars
                if (this.elements.healthBar || this.elements.manaBar || this.elements.staminaBar) {
                    const barsContainer = this.createPlayerBars(defaultPlayerData);
                    container.appendChild(barsContainer);
                    this.healthBars = barsContainer;
                }
                
                // Top-right: Minimap
                if (this.elements.minimap) {
                    const minimap = this.createMinimap();
                    container.appendChild(minimap);
                }
                
                // Bottom: Hotbar
                if (this.elements.hotbar) {
                    const hotbar = this.createHotbar();
                    container.appendChild(hotbar);
                }
                
                // Right side: Quest tracker
                if (this.elements.questTracker) {
                    const questTracker = this.createQuestTracker([]);
                    container.appendChild(questTracker);
                    this.questTracker = questTracker;
                }
                
                // Top center: Resource display
                if (this.elements.resourceDisplay) {
                    const resourceDisplay = this.createResourceDisplay(defaultPlayerData.resources);
                    container.appendChild(resourceDisplay);
                    this.resourceDisplay = resourceDisplay;
                }
                
                return container;
            }
            
            createHUDDisplay(playerData) {
                const container = document.createElement('div');
                container.className = 'hud-container';
                container.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    pointer-events: none;
                    z-index: 500;
                `;
                
                // Top-left: Player bars
                if (this.elements.healthBar || this.elements.manaBar || this.elements.staminaBar) {
                    const barsContainer = this.createPlayerBars(playerData);
                    container.appendChild(barsContainer);
                }
                
                // Top-right: Minimap
                if (this.elements.minimap) {
                    const minimap = this.createMinimap();
                    container.appendChild(minimap);
                }
                
                // Bottom: Hotbar
                if (this.elements.hotbar) {
                    const hotbar = this.createHotbar();
                    container.appendChild(hotbar);
                }
                
                // Right side: Quest tracker
                if (this.elements.questTracker) {
                    const questTracker = this.createQuestTracker(playerData.activeQuests);
                    container.appendChild(questTracker);
                }
                
                // Top center: Resource display
                if (this.elements.resourceDisplay) {
                    const resourceDisplay = this.createResourceDisplay(playerData.resources);
                    container.appendChild(resourceDisplay);
                }
                
                return container;
            }
            
            createPlayerBars(playerData) {
                const container = document.createElement('div');
                container.style.cssText = `
                    position: absolute;
                    top: 20px;
                    left: 20px;
                    pointer-events: auto;
                `;
                
                const character = playerData.character;
                
                // Health bar
                if (this.elements.healthBar) {
                    const healthBar = this.createBar('Health', character.currentHealth, character.maxHealth, '#F44336', '❤️');
                    container.appendChild(healthBar);
                }
                
                // Mana bar
                if (this.elements.manaBar) {
                    const manaBar = this.createBar('Mana', character.currentMana, character.maxMana, '#2196F3', '💧');
                    container.appendChild(manaBar);
                }
                
                // Stamina bar
                if (this.elements.staminaBar) {
                    const staminaBar = this.createBar('Stamina', character.currentStamina, character.maxStamina, '#FF9800', '⚡');
                    container.appendChild(staminaBar);
                }
                
                return container;
            }
            
            createBar(name, current, max, color, icon) {
                return UIFactory.createProgressBar(name, current, max, color, icon);
            }
            
            createMinimap() {
                const minimap = document.createElement('div');
                minimap.className = 'minimap';
                minimap.style.cssText = `
                    position: absolute;
                    top: 20px;
                    right: 20px;
                    width: 200px;
                    height: 200px;
                    background: rgba(0, 0, 0, 0.8);
                    border: 2px solid #444;
                    border-radius: 10px;
                    pointer-events: auto;
                `;
                
                // Placeholder minimap content
                const canvas = document.createElement('canvas');
                canvas.width = 196;
                canvas.height = 196;
                canvas.style.cssText = 'border-radius: 8px;';
                
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#111';
                ctx.fillRect(0, 0, 196, 196);
                
                // Draw grid
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                for (let i = 0; i < 10; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * 20, 0);
                    ctx.lineTo(i * 20, 196);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, i * 20);
                    ctx.lineTo(196, i * 20);
                    ctx.stroke();
                }
                
                // Player position
                ctx.fillStyle = '#4CAF50';
                ctx.beginPath();
                ctx.arc(98, 98, 5, 0, Math.PI * 2);
                ctx.fill();
                
                minimap.appendChild(canvas);
                return minimap;
            }
            
            createHotbar() {
                const hotbar = document.createElement('div');
                hotbar.className = 'hotbar';
                hotbar.style.cssText = `
                    position: absolute;
                    bottom: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    display: flex;
                    gap: 5px;
                    background: rgba(0, 0, 0, 0.8);
                    padding: 10px;
                    border-radius: 10px;
                    pointer-events: auto;
                `;
                
                // Create hotbar slots
                for (let i = 0; i < 10; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'hotbar-slot';
                    slot.style.cssText = `
                        width: 50px;
                        height: 50px;
                        background: rgba(255, 255, 255, 0.1);
                        border: 2px solid #666;
                        border-radius: 5px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        position: relative;
                        cursor: pointer;
                    `;
                    
                    // Slot number
                    const number = document.createElement('div');
                    number.style.cssText = `
                        position: absolute;
                        top: 2px;
                        left: 4px;
                        font-size: 10px;
                        color: #888;
                    `;
                    number.textContent = i === 9 ? '0' : (i + 1);
                    slot.appendChild(number);
                    
                    hotbar.appendChild(slot);
                }
                
                return hotbar;
            }
            
            createQuestTracker(activeQuests = []) {
                const tracker = document.createElement('div');
                tracker.className = 'quest-tracker';
                tracker.style.cssText = `
                    position: absolute;
                    top: 240px;
                    right: 20px;
                    width: 250px;
                    background: rgba(0, 0, 0, 0.7);
                    border-radius: 10px;
                    padding: 15px;
                    pointer-events: auto;
                    max-height: 300px;
                    overflow-y: auto;
                `;
                
                const title = document.createElement('div');
                title.style.cssText = 'color: #FFC107; font-weight: bold; margin-bottom: 10px;';
                title.textContent = '📋 Active Quests';
                tracker.appendChild(title);
                
                if (activeQuests.length === 0) {
                    const noQuests = document.createElement('div');
                    noQuests.style.cssText = 'color: #666; font-size: 12px;';
                    noQuests.textContent = 'No active quests';
                    tracker.appendChild(noQuests);
                } else {
                    activeQuests.forEach(quest => {
                        const questElement = this.createQuestTrackerItem(quest);
                        tracker.appendChild(questElement);
                    });
                }
                
                return tracker;
            }
            
            createQuestTrackerItem(quest) {
                const item = document.createElement('div');
                item.style.cssText = 'margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid #333;';
                
                const title = document.createElement('div');
                title.style.cssText = 'color: #2196F3; font-size: 12px; margin-bottom: 5px;';
                title.textContent = quest.title;
                item.appendChild(title);
                
                // Show first incomplete objective
                const nextObjective = quest.objectives.find(obj => !obj.completed);
                if (nextObjective) {
                    const objective = document.createElement('div');
                    objective.style.cssText = 'color: #aaa; font-size: 11px;';
                    objective.textContent = `• ${nextObjective.description}`;
                    if (nextObjective.required > 1) {
                        objective.textContent += ` (${nextObjective.current}/${nextObjective.required})`;
                    }
                    item.appendChild(objective);
                }
                
                return item;
            }
            
            createResourceDisplay(resources = {}) {
                const display = document.createElement('div');
                display.className = 'resource-display';
                display.style.cssText = `
                    position: absolute;
                    top: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    display: flex;
                    gap: 20px;
                    background: rgba(0, 0, 0, 0.7);
                    padding: 10px 20px;
                    border-radius: 20px;
                    pointer-events: auto;
                `;
                
                Object.entries(resources).forEach(([resource, amount]) => {
                    const resElement = UIFactory.createStyledElement('div', 'display: flex; align-items: center; gap: 5px;');
                    resElement.innerHTML = `
                        <span style="font-size: 16px;">${UIConstants.resourceIcons[resource] || '❓'}</span>
                        <span style="color: #fff; font-weight: bold;">${amount}</span>
                    `;
                    display.appendChild(resElement);
                });
                
                return display;
            }
            
            updateHealthBars(players) {
                // Update health bars for player characters
                if (!this.healthBars || !players || players.length === 0) return;
                
                // For now, just update the first player
                const player = players[0];
                if (!player) return;
                
                const character = player.getComponent('CharacterComponent');
                if (!character) return;
                
                // Update the health bar values
                // This would update the actual DOM elements in a real implementation
                console.log(`Updating health bars: HP ${character.currentHealth}/${character.maxHealth}`);
            }
            
            updateQuestTracker(activeQuests) {
                // Update quest tracker display
                if (!this.questTracker) return;
                
                // Clear existing content
                this.questTracker.innerHTML = '';
                
                const title = document.createElement('div');
                title.style.cssText = 'color: #FFC107; font-weight: bold; margin-bottom: 10px;';
                title.textContent = '📋 Active Quests';
                this.questTracker.appendChild(title);
                
                if (!activeQuests || activeQuests.length === 0) {
                    const noQuests = document.createElement('div');
                    noQuests.style.cssText = 'color: #666; font-size: 12px;';
                    noQuests.textContent = 'No active quests';
                    this.questTracker.appendChild(noQuests);
                } else {
                    activeQuests.forEach(quest => {
                        const questElement = this.createQuestTrackerItem(quest);
                        this.questTracker.appendChild(questElement);
                    });
                }
            }
            
            updateResources(resources) {
                // Update resource display
                if (!this.resourceDisplay) return;
                
                // Clear existing content
                this.resourceDisplay.innerHTML = '';
                
                Object.entries(resources).forEach(([resource, amount]) => {
                    const resElement = UIFactory.createStyledElement('div', 'display: flex; align-items: center; gap: 5px;');
                    resElement.innerHTML = `
                        <span style="font-size: 16px;">${UIConstants.resourceIcons[resource] || '❓'}</span>
                        <span style="color: #fff; font-weight: bold;">${amount}</span>
                    `;
                    this.resourceDisplay.appendChild(resElement);
                });
            }
        }
        
        class ShopGUI extends GUIComponent {
            constructor() {
                super();
                this.guiType = 'shop';
                this.size = { width: 600, height: 500 };
                
                // Shop-specific settings
                this.shopName = 'General Store';
                this.shopkeeper = 'Merchant Bob';
                this.inventory = [];
                this.playerGold = 0;
                this.selectedItem = null;
                this.buybackList = [];
                this.priceMultiplier = 1.0; // For discounts/markups
            }
            
            createShopInterface() {
                // Main method called by GUISystem
                const container = document.createElement('div');
                container.className = 'shop-interface';
                container.style.cssText = `
                    display: flex;
                    height: 100%;
                    gap: 20px;
                `;
                
                // Shop inventory side
                const shopSide = document.createElement('div');
                shopSide.style.cssText = 'flex: 1; padding: 10px;';
                shopSide.innerHTML = `
                    <h3 style="color: #4CAF50; margin-bottom: 10px;">${this.shopName}</h3>
                    <div style="color: #aaa; font-size: 12px; margin-bottom: 10px;">Shopkeeper: ${this.shopkeeper}</div>
                `;
                
                const shopGrid = this.createShopGrid();
                shopSide.appendChild(shopGrid);
                
                // Player inventory side
                const playerSide = document.createElement('div');
                playerSide.style.cssText = 'flex: 1; padding: 10px; border-left: 1px solid #444;';
                playerSide.innerHTML = `
                    <h3 style="color: #2196F3; margin-bottom: 10px;">Your Inventory</h3>
                    <div style="color: #FFC107; font-size: 14px; margin-bottom: 10px;">Gold: ${this.playerGold} 🪙</div>
                `;
                
                const playerGrid = this.createPlayerInventoryGrid();
                playerSide.appendChild(playerGrid);
                
                container.appendChild(shopSide);
                container.appendChild(playerSide);
                
                // Add transaction buttons
                const buttons = this.createTransactionButtons();
                container.appendChild(buttons);
                
                return container;
            }
            
            createShopGrid() {
                const grid = document.createElement('div');
                grid.style.cssText = `
                    display: grid;
                    grid-template-columns: repeat(4, 80px);
                    gap: 5px;
                    max-height: 300px;
                    overflow-y: auto;
                `;
                
                // Sample shop items
                const shopItems = [
                    { name: 'Iron Sword', type: 'weapon', price: 100, stock: 3 },
                    { name: 'Steel Shield', type: 'armor', price: 150, stock: 2 },
                    { name: 'Health Potion', type: 'consumable', price: 50, stock: 10 },
                    { name: 'Mana Potion', type: 'consumable', price: 75, stock: 8 },
                    { name: 'Teleport Scroll', type: 'consumable', price: 200, stock: 1 }
                ];
                
                shopItems.forEach((item, index) => {
                    const slot = this.createShopItemSlot(item, index);
                    grid.appendChild(slot);
                });
                
                return grid;
            }
            
            createShopItemSlot(item, index) {
                const slot = document.createElement('div');
                slot.style.cssText = `
                    width: 80px;
                    height: 80px;
                    border: 2px solid #666;
                    background: rgba(0, 0, 0, 0.5);
                    border-radius: 5px;
                    cursor: pointer;
                    position: relative;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    padding: 5px;
                `;
                
                const icon = document.createElement('div');
                icon.textContent = this.getItemIcon(item.type);
                icon.style.fontSize = '24px';
                slot.appendChild(icon);
                
                const name = document.createElement('div');
                name.textContent = item.name;
                name.style.cssText = 'font-size: 8px; color: #fff; text-align: center;';
                slot.appendChild(name);
                
                const price = document.createElement('div');
                price.textContent = `${item.price}🪙`;
                price.style.cssText = 'font-size: 10px; color: #FFC107; position: absolute; bottom: 2px;';
                slot.appendChild(price);
                
                if (item.stock > 0) {
                    const stock = document.createElement('div');
                    stock.textContent = item.stock;
                    stock.style.cssText = `
                        position: absolute;
                        top: 2px;
                        right: 2px;
                        background: #4CAF50;
                        color: white;
                        width: 16px;
                        height: 16px;
                        border-radius: 50%;
                        font-size: 10px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    `;
                    slot.appendChild(stock);
                }
                
                slot.onclick = () => this.selectShopItem(item, index);
                
                return slot;
            }
            
            createPlayerInventoryGrid() {
                const grid = document.createElement('div');
                grid.style.cssText = `
                    display: grid;
                    grid-template-columns: repeat(4, 80px);
                    gap: 5px;
                    max-height: 300px;
                    overflow-y: auto;
                `;
                
                // This would be populated with actual player inventory
                grid.innerHTML = '<div style="color: #666; grid-column: 1/5; text-align: center; padding: 20px;">Select items to sell</div>';
                
                return grid;
            }
            
            createTransactionButtons() {
                const container = document.createElement('div');
                container.style.cssText = `
                    position: absolute;
                    bottom: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    display: flex;
                    gap: 10px;
                `;
                
                const buyButton = document.createElement('button');
                buyButton.textContent = 'Buy';
                buyButton.style.cssText = `
                    padding: 10px 30px;
                    background: #4CAF50;
                    color: white;
                    border: none;
                    border-radius: 5px;
                    cursor: pointer;
                    font-size: 16px;
                `;
                buyButton.onclick = () => this.buyItem();
                
                const sellButton = document.createElement('button');
                sellButton.textContent = 'Sell';
                sellButton.style.cssText = `
                    padding: 10px 30px;
                    background: #F44336;
                    color: white;
                    border: none;
                    border-radius: 5px;
                    cursor: pointer;
                    font-size: 16px;
                `;
                sellButton.onclick = () => this.sellItem();
                
                container.appendChild(buyButton);
                container.appendChild(sellButton);
                
                return container;
            }
            
            getItemIcon(type) {
                return UIConstants.itemIcons[type] || '❓';
            }
            
            selectShopItem(item, index) {
                this.selectedItem = { item, index };
                console.log(`Selected shop item: ${item.name} for ${item.price} gold`);
            }
            
            buyItem() {
                if (!this.selectedItem) {
                    console.log('No item selected to buy');
                    return;
                }
                
                const { item } = this.selectedItem;
                if (this.playerGold >= item.price && item.stock > 0) {
                    console.log(`Buying ${item.name} for ${item.price} gold`);
                    // Implement actual purchase logic
                } else {
                    console.log('Not enough gold or item out of stock');
                }
            }
            
            sellItem() {
                console.log('Selling item functionality');
                // Implement selling logic
            }
        }
        
        // GUI System for managing all GUI elements
        class GUISystem {
            constructor() {
                this.world = null; // Will be set when added to world
                this.requiredComponents = ['GUIComponent'];
                this.priority = 22; // Run after all other systems
                
                // GUI management
                this.guiElements = new Map(); // entityId -> GUI element
                this.openWindows = new Set(); // Track open windows
                this.activeWindow = null; // Currently focused window
                this.hudEntity = null; // HUD entity reference
                
                // GUI container
                this.guiContainer = null;
                this.modalOverlay = null;
                
                // Keyboard shortcuts
                this.shortcuts = new Map([
                    ['i', 'inventory'],
                    ['c', 'character'],
                    ['j', 'quest'],
                    ['m', 'map'],
                    ['Escape', 'closeAll']
                ]);
                
                // Window z-index management
                this.baseZIndex = 1000;
                this.currentZIndex = this.baseZIndex;
                
                console.log('✨ GUISystem initialized');
            }
            
            init() {
                // Create main GUI container
                this.guiContainer = document.createElement('div');
                this.guiContainer.id = 'gui-container';
                this.guiContainer.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 1000;
                `;
                document.body.appendChild(this.guiContainer);
                
                // Create modal overlay
                this.modalOverlay = document.createElement('div');
                this.modalOverlay.id = 'modal-overlay';
                this.modalOverlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.5);
                    display: none;
                    z-index: 999;
                `;
                document.body.appendChild(this.modalOverlay);
                
                // Setup keyboard shortcuts
                document.addEventListener('keydown', (e) => this.handleKeyPress(e));
                
                // Setup GUI event listeners
                document.addEventListener('inventorySwap', (e) => this.handleInventorySwap(e));
                document.addEventListener('inventoryItemClick', (e) => this.handleItemClick(e));
                document.addEventListener('dialogueChoice', (e) => this.handleDialogueChoice(e));
                
                console.log('GUI System initialized');
            }
            
            update(entities, deltaTime) {
                // Process GUI entities
                for (const entity of entities) {
                    const guiComponent = entity.getComponent('GUIComponent');
                    if (!guiComponent || !guiComponent.active) continue;
                    
                    // Create GUI element if not exists
                    if (!this.guiElements.has(entity.id)) {
                        this.createGUIElement(entity, guiComponent);
                    }
                    
                    // Update GUI element
                    this.updateGUIElement(entity, guiComponent);
                }
                
                // Remove GUI elements for destroyed entities
                for (const [entityId, element] of this.guiElements) {
                    const entityExists = entities.some(e => e.id === entityId);
                    if (!entityExists) {
                        element.remove();
                        this.guiElements.delete(entityId);
                    }
                }
            }
            
            createGUIElement(entity, guiComponent) {
                let element = null;
                
                switch (guiComponent.guiType) {
                    case 'hud':
                        element = this.createHUD(entity, guiComponent);
                        this.hudEntity = entity;
                        break;
                    case 'inventory':
                        element = this.createInventoryWindow(entity, guiComponent);
                        break;
                    case 'character':
                        element = this.createCharacterWindow(entity, guiComponent);
                        break;
                    case 'quest':
                        element = this.createQuestWindow(entity, guiComponent);
                        break;
                    case 'dialogue':
                        element = this.createDialogueWindow(entity, guiComponent);
                        break;
                    case 'shop':
                        element = this.createShopWindow(entity, guiComponent);
                        break;
                    case 'menu':
                        element = this.createMenuWindow(entity, guiComponent);
                        break;
                }
                
                if (element) {
                    guiComponent.element = element;
                    this.guiElements.set(entity.id, element);
                    this.guiContainer.appendChild(element);
                    
                    // Set initial visibility
                    if (guiComponent.isOpen) {
                        this.openWindow(entity, guiComponent);
                    }
                }
            }
            
            createHUD(entity, guiComponent) {
                const hudElement = document.createElement('div');
                hudElement.id = 'hud';
                hudElement.className = 'gui-hud';
                hudElement.style.cssText = `
                    position: fixed;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                `;
                
                // HUD is always visible
                guiComponent.isOpen = true;
                guiComponent.visible = true;
                
                // Initialize HUD content
                const hudInstance = entity.getComponent('HUD');
                if (hudInstance) {
                    const container = hudInstance.createHUDContainer();
                    hudElement.appendChild(container);
                }
                
                return hudElement;
            }
            
            createInventoryWindow(entity, guiComponent) {
                return this.createWindow(entity, guiComponent, 'Inventory', (content) => {
                    const inventoryGUI = entity.getComponent('InventoryGUI');
                    const inventoryComp = this.findInventoryComponent();
                    
                    if (inventoryGUI && inventoryComp) {
                        const grid = inventoryGUI.createInventoryGrid(inventoryComp);
                        content.appendChild(grid);
                        
                        // Add inventory info
                        const info = document.createElement('div');
                        info.style.cssText = 'padding: 10px; color: #aaa; font-size: 12px;';
                        info.innerHTML = `
                            <div>Weight: ${inventoryComp.currentWeight}/${inventoryComp.maxWeight} kg</div>
                            <div>Gold: ${inventoryComp.gold} 🪙</div>
                        `;
                        content.appendChild(info);
                    }
                });
            }
            
            createCharacterWindow(entity, guiComponent) {
                return this.createWindow(entity, guiComponent, 'Character', (content) => {
                    const charGUI = entity.getComponent('CharacterSheetGUI');
                    const charComp = this.findCharacterComponent();
                    
                    if (charGUI && charComp) {
                        const display = charGUI.createCharacterDisplay(charComp);
                        content.appendChild(display);
                    }
                });
            }
            
            createQuestWindow(entity, guiComponent) {
                return this.createWindow(entity, guiComponent, 'Quest Journal', (content) => {
                    const questGUI = entity.getComponent('QuestJournalGUI');
                    const quests = this.findAllQuests();
                    
                    if (questGUI) {
                        const journal = questGUI.createQuestJournal(quests);
                        content.appendChild(journal);
                    }
                });
            }
            
            createDialogueWindow(entity, guiComponent) {
                const window = this.createWindow(entity, guiComponent, 'Dialogue', (content) => {
                    const dialogueGUI = entity.getComponent('DialogueGUI');
                    
                    if (dialogueGUI) {
                        const container = dialogueGUI.createDialogueContainer();
                        content.appendChild(container);
                    }
                });
                
                // Dialogue windows are modal
                window.style.pointerEvents = 'auto';
                return window;
            }
            
            createShopWindow(entity, guiComponent) {
                return this.createWindow(entity, guiComponent, 'Shop', (content) => {
                    const shopGUI = entity.getComponent('ShopGUI');
                    
                    if (shopGUI) {
                        const shop = shopGUI.createShopInterface();
                        content.appendChild(shop);
                    }
                });
            }
            
            createMenuWindow(entity, guiComponent) {
                return this.createWindow(entity, guiComponent, 'Menu', (content) => {
                    // Create main menu buttons
                    const buttons = [
                        { text: 'Resume', action: () => this.closeAllWindows() },
                        { text: 'Settings', action: () => console.log('Settings') },
                        { text: 'Save Game', action: () => this.saveGame() },
                        { text: 'Load Game', action: () => this.loadGame() },
                        { text: 'Exit to Main Menu', action: () => this.exitToMainMenu() }
                    ];
                    
                    buttons.forEach(btn => {
                        const button = document.createElement('button');
                        button.textContent = btn.text;
                        button.style.cssText = `
                            display: block;
                            width: 200px;
                            margin: 10px auto;
                            padding: 10px;
                            background: #2196F3;
                            color: white;
                            border: none;
                            border-radius: 5px;
                            cursor: pointer;
                            font-size: 16px;
                        `;
                        button.onclick = btn.action;
                        content.appendChild(button);
                    });
                });
            }
            
            createWindow(entity, guiComponent, title, contentBuilder) {
                const window = document.createElement('div');
                window.className = `gui-window gui-${guiComponent.guiType}`;
                window.style.cssText = `
                    position: absolute;
                    left: ${guiComponent.position.x}px;
                    top: ${guiComponent.position.y}px;
                    width: ${guiComponent.size.width}px;
                    height: ${guiComponent.size.height}px;
                    background: rgba(20, 20, 20, ${guiComponent.opacity});
                    border: 2px solid #444;
                    border-radius: 10px;
                    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
                    display: none;
                    pointer-events: auto;
                    z-index: ${guiComponent.zIndex};
                `;
                
                // Window header
                const header = document.createElement('div');
                header.className = 'gui-window-header';
                header.style.cssText = `
                    background: rgba(30, 30, 30, 0.9);
                    padding: 10px;
                    border-radius: 8px 8px 0 0;
                    cursor: move;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                `;
                
                const titleElement = document.createElement('span');
                titleElement.textContent = title;
                titleElement.style.cssText = 'color: #fff; font-weight: bold;';
                header.appendChild(titleElement);
                
                const closeButton = document.createElement('button');
                closeButton.textContent = '×';
                closeButton.style.cssText = `
                    background: none;
                    border: none;
                    color: #fff;
                    font-size: 20px;
                    cursor: pointer;
                    padding: 0 5px;
                `;
                closeButton.onclick = () => this.closeWindow(entity, guiComponent);
                header.appendChild(closeButton);
                
                window.appendChild(header);
                
                // Window content
                const content = document.createElement('div');
                content.className = 'gui-window-content';
                content.style.cssText = `
                    padding: 20px;
                    height: calc(100% - 50px);
                    overflow-y: auto;
                    color: #fff;
                `;
                
                guiComponent.content = content;
                contentBuilder(content);
                window.appendChild(content);
                
                // Make window draggable
                if (guiComponent.isDraggable) {
                    this.makeWindowDraggable(window, header, guiComponent);
                }
                
                // Window focus handling
                window.addEventListener('mousedown', () => {
                    this.focusWindow(entity, guiComponent);
                });
                
                return window;
            }
            
            makeWindowDraggable(window, header, guiComponent) {
                let isDragging = false;
                let dragOffset = { x: 0, y: 0 };
                
                header.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    dragOffset.x = e.clientX - guiComponent.position.x;
                    dragOffset.y = e.clientY - guiComponent.position.y;
                    header.style.cursor = 'grabbing';
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    guiComponent.setPosition(
                        e.clientX - dragOffset.x,
                        e.clientY - dragOffset.y
                    );
                });
                
                document.addEventListener('mouseup', () => {
                    isDragging = false;
                    header.style.cursor = 'move';
                });
            }
            
            updateGUIElement(entity, guiComponent) {
                const element = this.guiElements.get(entity.id);
                if (!element) return;
                
                // Update visibility
                element.style.display = guiComponent.isOpen ? 'block' : 'none';
                
                // Update HUD if it's a HUD component
                if (guiComponent.guiType === 'hud' && guiComponent.isOpen) {
                    this.updateHUD(entity, guiComponent);
                }
            }
            
            updateHUD(entity, guiComponent) {
                const hudInstance = entity.getComponent('HUD');
                if (!hudInstance) return;
                
                // Update health bars
                const players = world.query(['CharacterComponent', 'PartyComponent']);
                hudInstance.updateHealthBars(players);
                
                // Update quest tracker
                const activeQuests = this.findActiveQuests();
                hudInstance.updateQuestTracker(activeQuests);
                
                // Update resources
                const resourceEntity = world.query(['ResourceComponent'])[0];
                if (resourceEntity) {
                    const resources = resourceEntity.getComponent('ResourceComponent');
                    hudInstance.updateResources({
                        wood: resources.wood,
                        stone: resources.stone,
                        food: resources.food,
                        gold: resources.gold
                    });
                }
            }
            
            openWindow(entity, guiComponent) {
                guiComponent.open();
                this.openWindows.add(entity.id);
                this.focusWindow(entity, guiComponent);
                
                // Show modal overlay for dialogue
                if (guiComponent.guiType === 'dialogue') {
                    this.modalOverlay.style.display = 'block';
                }
            }
            
            closeWindow(entity, guiComponent) {
                guiComponent.close();
                this.openWindows.delete(entity.id);
                
                // Hide modal overlay if no dialogues open
                if (guiComponent.guiType === 'dialogue') {
                    const hasOpenDialogue = Array.from(this.openWindows).some(id => {
                        const e = world.entities.find(entity => entity.id === id);
                        return e && e.getComponent('GUIComponent').guiType === 'dialogue';
                    });
                    
                    if (!hasOpenDialogue) {
                        this.modalOverlay.style.display = 'none';
                    }
                }
                
                // Focus next window
                if (this.activeWindow === entity.id && this.openWindows.size > 0) {
                    const nextId = Array.from(this.openWindows)[0];
                    const nextEntity = world.entities.find(e => e.id === nextId);
                    if (nextEntity) {
                        this.focusWindow(nextEntity, nextEntity.getComponent('GUIComponent'));
                    }
                }
            }
            
            focusWindow(entity, guiComponent) {
                this.activeWindow = entity.id;
                guiComponent.zIndex = ++this.currentZIndex;
                
                if (guiComponent.element) {
                    guiComponent.element.style.zIndex = guiComponent.zIndex;
                }
            }
            
            closeAllWindows() {
                for (const entityId of this.openWindows) {
                    const entity = world.entities.find(e => e.id === entityId);
                    if (entity) {
                        const gui = entity.getComponent('GUIComponent');
                        if (gui && gui.guiType !== 'hud') {
                            this.closeWindow(entity, gui);
                        }
                    }
                }
            }
            
            handleKeyPress(e) {
                // Don't handle if typing in an input
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                
                const action = this.shortcuts.get(e.key);
                if (!action) return;
                
                e.preventDefault();
                
                if (action === 'closeAll') {
                    this.closeAllWindows();
                    return;
                }
                
                // Toggle window
                const guiEntity = this.findGUIEntity(action);
                if (guiEntity) {
                    const guiComponent = guiEntity.getComponent('GUIComponent');
                    if (guiComponent.isOpen) {
                        this.closeWindow(guiEntity, guiComponent);
                    } else {
                        this.openWindow(guiEntity, guiComponent);
                    }
                }
            }
            
            findGUIEntity(guiType) {
                const entities = world.query(['GUIComponent']);
                return entities.find(e => e.getComponent('GUIComponent').guiType === guiType);
            }
            
            findInventoryComponent() {
                const playerEntity = world.query(['InventoryComponent', 'CharacterComponent'])[0];
                return playerEntity ? playerEntity.getComponent('InventoryComponent') : null;
            }
            
            findCharacterComponent() {
                const playerEntity = world.query(['CharacterComponent', 'PartyComponent'])[0];
                return playerEntity ? playerEntity.getComponent('CharacterComponent') : null;
            }
            
            findAllQuests() {
                const questEntities = world.query(['QuestComponent']);
                return questEntities.map(e => e.getComponent('QuestComponent'));
            }
            
            findActiveQuests() {
                return this.findAllQuests().filter(q => q.status === 'active');
            }
            
            handleInventorySwap(e) {
                const { fromSlot, toSlot } = e.detail;
                const inventory = this.findInventoryComponent();
                
                if (inventory) {
                    // Swap items in the actual inventory component
                    const temp = inventory.slots[fromSlot];
                    inventory.slots[fromSlot] = inventory.slots[toSlot];
                    inventory.slots[toSlot] = temp;
                    
                    // Refresh inventory display
                    const invEntity = this.findGUIEntity('inventory');
                    if (invEntity && invEntity.getComponent('GUIComponent').isOpen) {
                        this.refreshInventoryDisplay(invEntity);
                    }
                }
            }
            
            handleItemClick(e) {
                const { slot, item } = e.detail;
                console.log(`Item clicked: ${item.name} in slot ${slot}`);
                // Could show item tooltip or context menu here
            }
            
            handleDialogueChoice(e) {
                const { choiceIndex } = e.detail;
                const dialogueEntity = this.findGUIEntity('dialogue');
                
                if (dialogueEntity) {
                    const dialogueGUI = dialogueEntity.getComponent('DialogueGUI');
                    const dialogueComp = this.findActiveDialogue();
                    
                    if (dialogueGUI && dialogueComp) {
                        dialogueComp.selectChoice(choiceIndex);
                        dialogueGUI.updateDialogue(dialogueComp);
                    }
                }
            }
            
            findActiveDialogue() {
                const dialogueEntities = world.query(['DialogueComponent']);
                return dialogueEntities.find(e => {
                    const d = e.getComponent('DialogueComponent');
                    return d.isActive;
                })?.getComponent('DialogueComponent');
            }
            
            refreshInventoryDisplay(entity) {
                const guiComponent = entity.getComponent('GUIComponent');
                const inventoryGUI = entity.getComponent('InventoryGUI');
                const inventory = this.findInventoryComponent();
                
                if (guiComponent.content && inventoryGUI && inventory) {
                    guiComponent.content.innerHTML = '';
                    const grid = inventoryGUI.createInventoryGrid(inventory);
                    guiComponent.content.appendChild(grid);
                    
                    // Re-add inventory info
                    const info = document.createElement('div');
                    info.style.cssText = 'padding: 10px; color: #aaa; font-size: 12px;';
                    info.innerHTML = `
                        <div>Weight: ${inventory.currentWeight}/${inventory.maxWeight} kg</div>
                        <div>Gold: ${inventory.gold} 🪙</div>
                    `;
                    guiComponent.content.appendChild(info);
                }
            }
            
            saveGame() {
                console.log('Saving game...');
                // Implement save functionality
            }
            
            loadGame() {
                console.log('Loading game...');
                // Implement load functionality
            }
            
            exitToMainMenu() {
                if (confirm('Are you sure you want to exit to the main menu?')) {
                    console.log('Exiting to main menu...');
                    // Implement exit functionality
                }
            }
        }
        
        // Attach Phase 3 components to window so they can be accessed globally
        window.PartyComponent = PartyComponent;
        window.CharacterComponent = CharacterComponent;
        window.AIComponent = AIComponent;
        window.CombatComponent = CombatComponent;
        window.InventoryComponent = InventoryComponent;
        
        // Attach Phase 4 components to window
        window.VillageComponent = VillageComponent;
        window.BuildingComponent = BuildingComponent;
        window.ResourceComponent = ResourceComponent;
        window.WorkerComponent = WorkerComponent;
        window.EconomyComponent = EconomyComponent;
        
        // Attach Phase 5 components to window
        window.QuestComponent = QuestComponent;
        window.DialogueComponent = DialogueComponent;
        window.NPCComponent = NPCComponent;
        window.EventComponent = EventComponent;
        
        // Attach Phase 6 GUI components to window
        window.GUIComponent = GUIComponent;
        window.InventoryGUI = InventoryGUI;
        window.CharacterSheetGUI = CharacterSheetGUI;
        window.QuestJournalGUI = QuestJournalGUI;
        window.DialogueGUI = DialogueGUI;
        window.ShopGUI = ShopGUI;
        window.HUD = HUD;
        window.GUISystem = GUISystem;
        
        console.log('✅ Phase 3 components attached to window');
        console.log('✅ Phase 4 components attached to window');
        console.log('✅ Phase 5 components attached to window');
        console.log('✅ Phase 6 GUI components attached to window');
        
        // Component Factory for cleaner entity creation
        const ComponentFactory = {
            // Component configurations with default values
            configs: {
                'Movement': () => {
                    const c = new Movement();
                    c.velocity = {
                        x: (Math.random() - 0.5) * 4,
                        y: (Math.random() - 0.5) * 2,
                        z: (Math.random() - 0.5) * 4
                    };
                    return c;
                },
                'Health': () => new Health(),
                'Lifetime': () => new Lifetime(Math.random() * 10 + 5),
                'VisualComponent': () => new VisualComponent(),
                'RigidbodyComponent': () => {
                    const c = new window.RigidbodyComponent();
                    c.mass = 1;
                    c.useGravity = true;
                    c.velocity = new THREE.Vector3((Math.random() - 0.5) * 2, 0, (Math.random() - 0.5) * 2);
                    return c;
                },
                'TweenComponent': () => new window.TweenComponent(),
                'AnimatorComponent': () => new window.AnimatorComponent(),
                'PartyComponent': (entityId) => {
                    const c = new window.PartyComponent();
                    c.addMember(entityId);
                    return c;
                },
                'CharacterComponent': (entityId) => {
                    const c = new window.CharacterComponent();
                    c.name = `Hero ${entityId}`;
                    c.level = Math.floor(Math.random() * 5) + 1;
                    return c;
                },
                'AIComponent': () => {
                    const c = new window.AIComponent();
                    const behaviors = ['follow', 'guard', 'patrol', 'aggressive'];
                    c.behaviorType = behaviors[Math.floor(Math.random() * behaviors.length)];
                    return c;
                },
                'CombatComponent': () => {
                    const c = new window.CombatComponent();
                    c.attackPower = Math.floor(Math.random() * 20) + 10;
                    return c;
                },
                'InventoryComponent': () => {
                    const c = new window.InventoryComponent();
                    c.currency = Math.floor(Math.random() * 100);
                    return c;
                }
                // Add more as needed...
            },
            
            addComponent(entity, componentName) {
                if (!window[componentName]) return false;
                const config = this.configs[componentName];
                if (config) {
                    const component = config(entity.id);
                    entity.addComponent(component);
                    return true;
                }
                return false;
            }
        };
        
        // Global state
        let scene, camera, renderer, world;
        let lastTime = Date.now();
        let selectedEntity = null;
        let raycaster, mouse;
        
        // Component loading state
        let phase2ComponentsLoaded = false;
        let queryTestCount = 0;
        let lastInspectorUpdate = 0;
        
        // Inspector dragging state
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        
        
        
        function init() {
            // Verify Phase 3 components are available at init time
            console.log('  PartyComponent:', !!window.PartyComponent);
            console.log('  CharacterComponent:', !!window.CharacterComponent);
            console.log('  AIComponent:', !!window.AIComponent);
            console.log('  CombatComponent:', !!window.CombatComponent);
            console.log('  InventoryComponent:', !!window.InventoryComponent);
            
            // Initialize Three.js
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2c3e50);
            
            // Create dimetric camera (orthographic projection with 2:1 tile ratio)
            const frustumSize = 20;
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.OrthographicCamera(
                frustumSize * aspect / -2, frustumSize * aspect / 2,
                frustumSize / 2, frustumSize / -2,
                0.1, 1000
            );
            
            // Position for dimetric view (26.57° elevation, 45° azimuth for 2:1 tile ratio)
            const elevation = 26.57 * Math.PI / 180; // 26.57 degrees
            const azimuth = 45 * Math.PI / 180; // 45 degrees
            const distance = 20;
            
            camera.position.set(
                Math.cos(elevation) * Math.sin(azimuth) * distance,
                Math.sin(elevation) * distance,
                Math.cos(elevation) * Math.cos(azimuth) * distance
            );
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Create ground
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(25, 25),
                new THREE.MeshLambertMaterial({ color: 0x34495e })
            );
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Initialize raycaster for mouse picking
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Add mouse event listeners
            renderer.domElement.addEventListener('click', onMouseClick);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            
            // Initialize inspector dragging
            initInspectorDragging();
            
            // Initialize inspector resize observer
            initInspectorResize();
            
            // Initialize UI dragging
            initUIDragging();
            
            // Initialize ECS
            world = new World();
            
            // Load saved panel positions
            loadPanelPositions();
            
            // Load Phase 2 components (physics & animation) at startup
            loadPhase2Components(() => {
                console.log('✅ Phase 2 components are now available in the ECS inspector');
                
                // Load Phase 3 components (party & character systems)
                loadPhase3Components(() => {
                    console.log('✅ Phase 3 components are now available in the ECS inspector');
                    
                    // Create initial entities AFTER all components are loaded
                    console.log('🎯 Creating initial entities with all components...');
                    for (let i = 0; i < 5; i++) {
                        createEntity();
                    }
                    
                    console.log('ECS Demo initialized with', world.entities.length, 'entities with all components');
                });
            });
            
            // Initialize GUI System
            initializeGUISystem();
            
            // Create GUI entities
            createGUIEntities();
            
            // Start game loop immediately
            animate();
            updateStatus();
        }
        
        function createEntity() {
            const entity = world.createEntity();
            
            // Add Transform component
            const transform = new Transform(
                (Math.random() - 0.5) * 10,
                Math.random() * 3 + 1,
                (Math.random() - 0.5) * 10
            );
            entity.addComponent(transform);
            
            // Add Renderable component
            const geometry = Math.random() > 0.5 ? 
                new THREE.BoxGeometry(1, 1, 1) : 
                new THREE.SphereGeometry(0.5, 12, 8);
            const material = new THREE.MeshLambertMaterial({ 
                color: Math.random() * 0xffffff 
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            entity.addComponent(new Renderable(mesh));
            
            // Store entity reference on mesh for picking
            mesh.userData.entity = entity;
            
            scene.add(mesh);
            
            // Add all available components by default
            
            // Add Movement component
            const movement = new Movement();
            movement.velocity = {
                x: (Math.random() - 0.5) * 4,
                y: (Math.random() - 0.5) * 2,
                z: (Math.random() - 0.5) * 4
            };
            entity.addComponent(movement);
            
            // Add Health component
            entity.addComponent(new Health());
            
            // Add Lifetime component
            entity.addComponent(new Lifetime(Math.random() * 10 + 5));
            
            // Add VisualComponent for styling control
            entity.addComponent(new VisualComponent());
            
            // Add physics components if available
            if (phase2ComponentsLoaded) {
                // Add RigidbodyComponent
                const rigidbody = new window.RigidbodyComponent();
                rigidbody.mass = 1;
                rigidbody.useGravity = true;
                rigidbody.velocity = new THREE.Vector3((Math.random() - 0.5) * 2, 0, (Math.random() - 0.5) * 2);
                entity.addComponent(rigidbody);
                
                // Add appropriate collider based on geometry
                if (geometry instanceof THREE.SphereGeometry) {
                    const collider = new window.SphereColliderComponent();
                    collider.setRadius(0.5);
                    entity.addComponent(collider);
                } else {
                    const collider = new window.BoxColliderComponent();
                    collider.setSize(1, 1, 1);
                    entity.addComponent(collider);
                }
                
                // Add TweenComponent 
                const tween = new window.TweenComponent();
                entity.addComponent(tween);
                
                // Add AnimatorComponent
                const animator = new window.AnimatorComponent();
                entity.addComponent(animator);
                
                // Add Phase 3 components if available
                console.log('🔍 Checking Phase 3 components availability:', {
                    PartyComponent: !!window.PartyComponent,
                    CharacterComponent: !!window.CharacterComponent,
                    AIComponent: !!window.AIComponent,
                    CombatComponent: !!window.CombatComponent,
                    InventoryComponent: !!window.InventoryComponent
                });
                
                if (window.PartyComponent) {
                    const party = new window.PartyComponent();
                    party.addMember(entity.id);
                    entity.addComponent(party);
                } else {
                    console.log('❌ PartyComponent not available');
                }
                
                if (window.CharacterComponent) {
                    const character = new window.CharacterComponent();
                    character.name = `Hero ${entity.id}`;
                    character.level = Math.floor(Math.random() * 5) + 1;
                    entity.addComponent(character);
                }
                
                if (window.AIComponent) {
                    const ai = new window.AIComponent();
                    const behaviors = ['follow', 'guard', 'patrol', 'aggressive'];
                    ai.behaviorType = behaviors[Math.floor(Math.random() * behaviors.length)];
                    entity.addComponent(ai);
                }
                
                if (window.CombatComponent) {
                    const combat = new window.CombatComponent();
                    combat.attackPower = Math.floor(Math.random() * 20) + 10;
                    entity.addComponent(combat);
                }
                
                if (window.InventoryComponent) {
                    const inventory = new window.InventoryComponent();
                    inventory.currency = Math.floor(Math.random() * 100);
                    entity.addComponent(inventory);
                }
                
                // Add Phase 4 components if available
                if (window.VillageComponent) {
                    const village = new window.VillageComponent();
                    village.name = `Village ${entity.id}`;
                    village.population = Math.floor(Math.random() * 20) + 5;
                    entity.addComponent(village);
                }
                
                if (window.BuildingComponent) {
                    const building = new window.BuildingComponent();
                    const buildingTypes = ['house', 'farm', 'workshop', 'storage', 'barracks'];
                    building.buildingType = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
                    building.level = Math.floor(Math.random() * 3) + 1;
                    entity.addComponent(building);
                }
                
                if (window.ResourceComponent) {
                    const resource = new window.ResourceComponent();
                    // Randomize starting resources
                    resource.resources.wood = Math.floor(Math.random() * 100) + 20;
                    resource.resources.stone = Math.floor(Math.random() * 80) + 10;
                    resource.resources.food = Math.floor(Math.random() * 60) + 30;
                    entity.addComponent(resource);
                }
                
                if (window.WorkerComponent) {
                    const worker = new window.WorkerComponent();
                    const jobs = ['farmer', 'builder', 'miner', 'soldier', 'merchant'];
                    worker.job = jobs[Math.floor(Math.random() * jobs.length)];
                    worker.skill = Math.floor(Math.random() * 5) + 1;
                    entity.addComponent(worker);
                }
                
                if (window.EconomyComponent) {
                    const economy = new window.EconomyComponent();
                    economy.reputation = Math.floor(Math.random() * 50) + 25;
                    entity.addComponent(economy);
                }
                
                // Phase 5 components
                if (window.QuestComponent) {
                    const quest = new window.QuestComponent();
                    const questTypes = ['kill', 'collect', 'deliver', 'talk', 'explore'];
                    quest.questType = questTypes[Math.floor(Math.random() * questTypes.length)];
                    quest.title = `${quest.questType.charAt(0).toUpperCase() + quest.questType.slice(1)} Quest`;
                    entity.addComponent(quest);
                }
                
                if (window.DialogueComponent) {
                    const dialogue = new window.DialogueComponent();
                    const names = ['Elder Smith', 'Merchant Joe', 'Guard Captain', 'Village Chief', 'Wise Oracle'];
                    dialogue.characterName = names[Math.floor(Math.random() * names.length)];
                    entity.addComponent(dialogue);
                }
                
                if (window.NPCComponent) {
                    const npc = new window.NPCComponent();
                    const types = ['villager', 'merchant', 'guard', 'quest_giver', 'farmer'];
                    npc.npcType = types[Math.floor(Math.random() * types.length)];
                    npc.name = `NPC_${Math.floor(Math.random() * 1000)}`;
                    entity.addComponent(npc);
                }
                
                if (window.EventComponent) {
                    const event = new window.EventComponent();
                    const eventTypes = ['random', 'scripted', 'seasonal', 'triggered'];
                    event.eventType = eventTypes[Math.floor(Math.random() * eventTypes.length)];
                    entity.addComponent(event);
                }
                
                console.log('✅ Created entity with all components including physics, Phases 3, 4, and 5!');
            } else {
                // Add Phase 3 components even if physics components aren't loaded yet
                console.log('🔍 Checking Phase 3 components availability (no physics):', {
                    PartyComponent: !!window.PartyComponent,
                    CharacterComponent: !!window.CharacterComponent,
                    AIComponent: !!window.AIComponent,
                    CombatComponent: !!window.CombatComponent,
                    InventoryComponent: !!window.InventoryComponent
                });
                
                if (window.PartyComponent) {
                    const party = new window.PartyComponent();
                    party.addMember(entity.id);
                    entity.addComponent(party);
                } else {
                    console.log('❌ PartyComponent not available (no physics)');
                }
                
                if (window.CharacterComponent) {
                    const character = new window.CharacterComponent();
                    character.name = `Hero ${entity.id}`;
                    character.level = Math.floor(Math.random() * 5) + 1;
                    entity.addComponent(character);
                }
                
                if (window.AIComponent) {
                    const ai = new window.AIComponent();
                    const behaviors = ['follow', 'guard', 'patrol', 'aggressive'];
                    ai.behaviorType = behaviors[Math.floor(Math.random() * behaviors.length)];
                    entity.addComponent(ai);
                }
                
                if (window.CombatComponent) {
                    const combat = new window.CombatComponent();
                    combat.attackPower = Math.floor(Math.random() * 20) + 10;
                    entity.addComponent(combat);
                }
                
                if (window.InventoryComponent) {
                    const inventory = new window.InventoryComponent();
                    inventory.currency = Math.floor(Math.random() * 100);
                    entity.addComponent(inventory);
                }
                
                // Add Phase 4 components even if physics components aren't loaded yet
                if (window.VillageComponent) {
                    const village = new window.VillageComponent();
                    village.name = `Village ${entity.id}`;
                    village.population = Math.floor(Math.random() * 20) + 5;
                    entity.addComponent(village);
                }
                
                if (window.BuildingComponent) {
                    const building = new window.BuildingComponent();
                    const buildingTypes = ['house', 'farm', 'workshop', 'storage', 'barracks'];
                    building.buildingType = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
                    building.level = Math.floor(Math.random() * 3) + 1;
                    entity.addComponent(building);
                }
                
                if (window.ResourceComponent) {
                    const resource = new window.ResourceComponent();
                    // Randomize starting resources
                    resource.resources.wood = Math.floor(Math.random() * 100) + 20;
                    resource.resources.stone = Math.floor(Math.random() * 80) + 10;
                    resource.resources.food = Math.floor(Math.random() * 60) + 30;
                    entity.addComponent(resource);
                }
                
                if (window.WorkerComponent) {
                    const worker = new window.WorkerComponent();
                    const jobs = ['farmer', 'builder', 'miner', 'soldier', 'merchant'];
                    worker.job = jobs[Math.floor(Math.random() * jobs.length)];
                    worker.skill = Math.floor(Math.random() * 5) + 1;
                    entity.addComponent(worker);
                }
                
                if (window.EconomyComponent) {
                    const economy = new window.EconomyComponent();
                    economy.reputation = Math.floor(Math.random() * 50) + 25;
                    entity.addComponent(economy);
                }
                
                // Phase 5 components (no physics)
                if (window.QuestComponent) {
                    const quest = new window.QuestComponent();
                    const questTypes = ['kill', 'collect', 'deliver', 'talk', 'explore'];
                    quest.questType = questTypes[Math.floor(Math.random() * questTypes.length)];
                    quest.title = `${quest.questType.charAt(0).toUpperCase() + quest.questType.slice(1)} Quest`;
                    entity.addComponent(quest);
                }
                
                if (window.DialogueComponent) {
                    const dialogue = new window.DialogueComponent();
                    const names = ['Elder Smith', 'Merchant Joe', 'Guard Captain', 'Village Chief', 'Wise Oracle'];
                    dialogue.characterName = names[Math.floor(Math.random() * names.length)];
                    entity.addComponent(dialogue);
                }
                
                if (window.NPCComponent) {
                    const npc = new window.NPCComponent();
                    const types = ['villager', 'merchant', 'guard', 'quest_giver', 'farmer'];
                    npc.npcType = types[Math.floor(Math.random() * types.length)];
                    npc.name = `NPC_${Math.floor(Math.random() * 1000)}`;
                    entity.addComponent(npc);
                }
                
                if (window.EventComponent) {
                    const event = new window.EventComponent();
                    const eventTypes = ['random', 'scripted', 'seasonal', 'triggered'];
                    event.eventType = eventTypes[Math.floor(Math.random() * eventTypes.length)];
                    entity.addComponent(event);
                }
                
                console.log('✅ Created entity with basic components, Phases 3, 4, and 5 components (physics components loading...)');
            }
            
            updateStatus();
            return entity;
        }
        
        // GUI Initialization Functions
        function initializeGUISystem() {
            // Add GUI System to world
            const guiSystem = new GUISystem();
            world.systems.push(guiSystem);
            
            // Initialize the GUI system
            guiSystem.init();
            
            console.log('✅ GUI System initialized and added to world');
        }
        
        function createGUIEntities() {
            // Create HUD entity
            const hudEntity = world.createEntity();
            hudEntity.addComponent(new GUIComponent());
            hudEntity.addComponent(new HUD());
            const hudGUI = hudEntity.getComponent('GUIComponent');
            hudGUI.guiType = 'hud';
            hudGUI.isOpen = true; // HUD is always open
            
            // Create inventory window entity
            const invEntity = world.createEntity();
            invEntity.addComponent(new GUIComponent());
            invEntity.addComponent(new InventoryGUI());
            const invGUI = invEntity.getComponent('GUIComponent');
            invGUI.guiType = 'inventory';
            invGUI.position = { x: 100, y: 100 };
            
            // Create character window entity
            const charEntity = world.createEntity();
            charEntity.addComponent(new GUIComponent());
            charEntity.addComponent(new CharacterSheetGUI());
            const charGUI = charEntity.getComponent('GUIComponent');
            charGUI.guiType = 'character';
            charGUI.position = { x: 200, y: 100 };
            
            // Create quest journal entity
            const questEntity = world.createEntity();
            questEntity.addComponent(new GUIComponent());
            questEntity.addComponent(new QuestJournalGUI());
            const questGUI = questEntity.getComponent('GUIComponent');
            questGUI.guiType = 'quest';
            questGUI.position = { x: 300, y: 100 };
            
            // Create dialogue window entity
            const dialogueEntity = world.createEntity();
            dialogueEntity.addComponent(new GUIComponent());
            dialogueEntity.addComponent(new DialogueGUI());
            const dialogueGUI = dialogueEntity.getComponent('GUIComponent');
            dialogueGUI.guiType = 'dialogue';
            dialogueGUI.position = { x: window.innerWidth / 2 - 200, y: window.innerHeight / 2 - 150 };
            
            console.log('✅ Created GUI entities:');
            console.log('  - HUD (always visible)');
            console.log('  - Inventory Window (press "i")');
            console.log('  - Character Sheet (press "c")');
            console.log('  - Quest Journal (press "j")');
            console.log('  - Dialogue Window');
            console.log('  - Press ESC to close all windows');
            
            // Add sample items to first entity with inventory
            setTimeout(() => {
                const invComp = world.query(['InventoryComponent'])[0]?.getComponent('InventoryComponent');
                if (invComp) {
                    invComp.addItem({
                        name: 'Iron Sword',
                        type: 'weapon',
                        weight: 3,
                        value: 50,
                        quantity: 1
                    }, 0);
                    
                    invComp.addItem({
                        name: 'Health Potion',
                        type: 'consumable',
                        weight: 0.5,
                        value: 20,
                        quantity: 5
                    }, 1);
                    
                    invComp.addItem({
                        name: 'Leather Armor',
                        type: 'armor',
                        weight: 5,
                        value: 100,
                        quantity: 1
                    }, 2);
                    
                    console.log('✅ Added sample items to inventory');
                }
            }, 100);
        }
        
        function addComponentToEntity(entity) {
            const componentTypes = ['Movement', 'Health', 'Lifetime', 'RigidbodyComponent', 'BoxColliderComponent', 'SphereColliderComponent', 'TweenComponent', 'AnimatorComponent', 'VisualComponent', 'PartyComponent', 'CharacterComponent', 'AIComponent', 'CombatComponent', 'InventoryComponent', 'VillageComponent', 'BuildingComponent', 'ResourceComponent', 'WorkerComponent', 'EconomyComponent'];
            const availableTypes = componentTypes.filter(type => !entity.hasComponent(type));
            
            if (availableTypes.length === 0) {
                console.log(`⚠️ Entity ${entity.id} already has all possible components`);
                return;
            }
            
            const randomType = availableTypes[Math.floor(Math.random() * availableTypes.length)];
            
            let component;
            switch(randomType) {
                case 'Movement':
                    component = new Movement();
                    component.velocity = {
                        x: (Math.random() - 0.5) * 4,
                        y: (Math.random() - 0.5) * 2,
                        z: (Math.random() - 0.5) * 4
                    };
                    break;
                case 'Health':
                    component = new Health();
                    break;
                case 'Lifetime':
                    component = new Lifetime(Math.random() * 10 + 5);
                    break;
                case 'RigidbodyComponent':
                    component = new window.RigidbodyComponent();
                    component.mass = 1;
                    component.useGravity = true;
                    component.velocity = new THREE.Vector3(0, 0, 0);
                    console.log('🔬 Added physics rigidbody component');
                    break;
                case 'BoxColliderComponent':
                    component = new window.BoxColliderComponent();
                    component.setSize(2, 2, 2);
                    console.log('📦 Added box collider component');
                    break;
                case 'SphereColliderComponent':
                    component = new window.SphereColliderComponent();
                    component.setRadius(1);
                    console.log('⚪ Added sphere collider component');
                    break;
                case 'TweenComponent':
                    component = new window.TweenComponent();
                    console.log('🎬 Added tween animation component');
                    break;
                case 'AnimatorComponent':
                    component = new window.AnimatorComponent();
                    console.log('🎭 Added animator component');
                    break;
                case 'VisualComponent':
                    component = new VisualComponent();
                    console.log('🎨 Added visual styling component');
                    break;
                case 'PartyComponent':
                    component = new PartyComponent();
                    // Auto-add this entity to the party
                    component.addMember(entity.id);
                    console.log('👥 Added party management component');
                    break;
                case 'CharacterComponent':
                    component = new CharacterComponent();
                    component.name = `Hero ${entity.id}`;
                    component.level = Math.floor(Math.random() * 5) + 1;
                    console.log('⚔️ Added character stats component');
                    break;
                case 'AIComponent':
                    component = new AIComponent();
                    const behaviors = ['follow', 'guard', 'patrol', 'aggressive'];
                    component.behaviorType = behaviors[Math.floor(Math.random() * behaviors.length)];
                    console.log(`🤖 Added AI component (${component.behaviorType})`);
                    break;
                case 'CombatComponent':
                    component = new CombatComponent();
                    component.attackPower = Math.floor(Math.random() * 20) + 10;
                    console.log('⚔️ Added combat component');
                    break;
                case 'InventoryComponent':
                    component = new InventoryComponent();
                    component.currency = Math.floor(Math.random() * 100);
                    console.log('🎒 Added inventory component');
                    break;
                case 'VillageComponent':
                    component = new VillageComponent();
                    component.name = `Village ${entity.id}`;
                    component.population = Math.floor(Math.random() * 30) + 5;
                    console.log('🏘️ Added village component');
                    break;
                case 'BuildingComponent':
                    component = new BuildingComponent();
                    const buildingTypes = ['house', 'farm', 'workshop', 'storage', 'barracks'];
                    component.buildingType = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
                    component.level = Math.floor(Math.random() * 3) + 1;
                    console.log('🏗️ Added building component');
                    break;
                case 'ResourceComponent':
                    component = new ResourceComponent();
                    component.resources.wood = Math.floor(Math.random() * 100) + 20;
                    component.resources.stone = Math.floor(Math.random() * 80) + 10;
                    component.resources.food = Math.floor(Math.random() * 60) + 30;
                    console.log('📦 Added resource component');
                    break;
                case 'WorkerComponent':
                    component = new WorkerComponent();
                    const jobs = ['farmer', 'builder', 'miner', 'soldier', 'merchant'];
                    component.job = jobs[Math.floor(Math.random() * jobs.length)];
                    component.skill = Math.floor(Math.random() * 5) + 1;
                    console.log('👷 Added worker component');
                    break;
                case 'EconomyComponent':
                    component = new EconomyComponent();
                    component.reputation = Math.floor(Math.random() * 50) + 25;
                    console.log('💰 Added economy component');
                    break;
            }
            
            entity.addComponent(component);
            console.log(`✅ Added ${randomType} to entity ${entity.id}`);
            updateStatus();
        }
        
        function removeComponentFromEntity(entity) {
            const componentTypes = Array.from(entity.components.keys());
            const removableTypes = componentTypes.filter(type => 
                type !== 'Transform' && type !== 'Renderable'
            );
            
            if (removableTypes.length === 0) {
                console.log(`⚠️ Entity ${entity.id} has no removable components`);
                return;
            }
            
            const typeToRemove = removableTypes[Math.floor(Math.random() * removableTypes.length)];
            entity.removeComponent(typeToRemove);
            console.log(`🗑️ Removed ${typeToRemove} from entity ${entity.id}`);
            updateStatus();
        }
        
        function destroyEntity(entity) {
            // Always clean up visualization helpers for this entity
            removeColliderVisualization(entity);
            
            // Clear selection if this entity is currently selected
            if (selectedEntity && selectedEntity.id === entity.id) {
                selectEntity(null); // This will clear selection properly
            }
            
            world.destroyEntity(entity);
            console.log(`💥 Destroyed entity ${entity.id}`);
            updateStatus();
        }
        
        
        function queryEntities() {
            const queries = [
                ['Transform'],
                ['Transform', 'Movement'],
                ['Transform', 'Health'],
                ['Movement', 'Health'],
                ['Transform', 'Renderable', 'Movement']
            ];
            
            queries.forEach(componentTypes => {
                const result = world.query(componentTypes);
                console.log(`Query [${componentTypes.join(', ')}]: ${result.length} entities`);
            });
            
            queryTestCount++;
            updateStatus();
        }
        
        function stressTest() {
            console.log('Running stress test...');
            const start = performance.now();
            
            // Create 100 entities
            for (let i = 0; i < 100; i++) {
                createEntity();
            }
            
            // Run systems 10 times
            for (let i = 0; i < 10; i++) {
                world.update(0.016);
            }
            
            // Perform queries
            for (let i = 0; i < 50; i++) {
                world.query(['Transform', 'Movement']);
            }
            
            const end = performance.now();
            console.log(`Stress test completed in ${(end - start).toFixed(2)}ms`);
            document.getElementById('performance').textContent = `Stress: ${(end - start).toFixed(2)}ms`;
            updateStatus();
        }
        
        
        function clearAll() {
            // Clear selection first
            selectEntity(null);
            
            while (world.entities.length > 0) {
                world.destroyEntity(world.entities[0]);
            }
            console.log('Cleared all entities');
            updateStatus();
        }
        
        function updateStatus() {
            const stats = world.getStats();
            document.getElementById('entityCount').textContent = stats.entities;
            document.getElementById('componentCount').textContent = stats.components;
            document.getElementById('systemCount').textContent = stats.systems;
            document.getElementById('queryCount').textContent = queryTestCount;
            updateInspector();
        }
        
        
        function onMouseMove(event) {
            // Update mouse position for hover effects
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Update raycaster
            raycaster.setFromCamera(mouse, camera);
            
            // Find intersected objects
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            // Reset all mesh colors first
            world.entities.forEach(entity => {
                const renderable = entity.getComponent('Renderable');
                if (renderable && renderable.mesh && renderable.mesh.userData.entity) {
                    if (selectedEntity && selectedEntity.id === entity.id) {
                        // Keep selected entity highlighted
                        renderable.mesh.material.emissive.setHex(0x004400);
                    } else {
                        // Normal color
                        renderable.mesh.material.emissive.setHex(0x000000);
                    }
                }
            });
            
            // Highlight hovered object
            if (intersects.length > 0) {
                const mesh = intersects[0].object;
                if (mesh.userData.entity && (!selectedEntity || selectedEntity.id !== mesh.userData.entity.id)) {
                    mesh.material.emissive.setHex(0x222222);
                }
                renderer.domElement.style.cursor = 'pointer';
            } else {
                renderer.domElement.style.cursor = 'default';
            }
        }
        
        function onMouseClick(event) {
            // Update mouse position
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Update raycaster
            raycaster.setFromCamera(mouse, camera);
            
            // Find intersected objects
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            if (intersects.length > 0) {
                const mesh = intersects[0].object;
                if (mesh.userData.entity) {
                    console.log(`🎯 Viewport click - selecting entity ${mesh.userData.entity.id}`);
                    selectEntity(mesh.userData.entity);
                }
            } else {
                // Clicked on empty space, deselect
                console.log('🎯 Viewport click - deselecting');
                selectEntity(null);
            }
        }
        
        function selectEntity(entity) {
            console.log(`🔄 selectEntity called with: ${entity ? `entity ${entity.id}` : 'null'}`);
            
            // Clear previous selection highlight
            if (selectedEntity) {
                const prevRenderable = selectedEntity.getComponent('Renderable');
                if (prevRenderable && prevRenderable.mesh) {
                    prevRenderable.mesh.material.emissive.setHex(0x000000);
                }
                
                // Remove collider visualization from previous selection
                removeColliderVisualization(selectedEntity);
            }
            
            selectedEntity = entity;
            
            // Highlight new selection with emissive glow
            if (selectedEntity) {
                const renderable = selectedEntity.getComponent('Renderable');
                if (renderable && renderable.mesh) {
                    // Add emissive glow for selection feedback
                    renderable.mesh.material.emissive.setHex(0x004400);
                }
                
                // Add collider visualization (replaces wireframe)
                addColliderVisualization(selectedEntity);
            }
            
            updateSelectionUI();
            updateInspector(); // This will update the inspector to show the selected state
        }
        
        function updateSelectionUI() {
            const selectionInfo = document.getElementById('selectionInfo');
            
            if (selectionInfo) {
                if (selectedEntity) {
                    const componentTypes = Array.from(selectedEntity.components.keys());
                    const activeCount = componentTypes.filter(type => {
                        const component = selectedEntity.getComponent(type);
                        return component.active !== false;
                    }).length;
                    
                    selectionInfo.innerHTML = `
                        <strong>Selected:</strong> Entity ${selectedEntity.id}<br>
                        <span style="font-size: 10px;">
                            ${componentTypes.length} components, ${activeCount} active
                        </span>
                    `;
                    selectionInfo.style.color = '#4CAF50';
                } else {
                    selectionInfo.textContent = 'Click an entity to select it. Click components to toggle on/off.';
                    selectionInfo.style.color = '#888';
                }
            }
        }
        
        function initInspectorDragging() {
            const inspector = document.getElementById('inspector');
            const header = document.getElementById('inspector-header');
            
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                inspector.classList.add('dragging');
                
                const rect = inspector.getBoundingClientRect();
                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;
                
                document.addEventListener('mousemove', onDrag);
                document.addEventListener('mouseup', onDragEnd);
                
                e.preventDefault();
            });
            
            function onDrag(e) {
                if (!isDragging) return;
                
                const newX = e.clientX - dragOffset.x;
                const newY = e.clientY - dragOffset.y;
                
                // Keep inspector within viewport bounds
                const maxX = window.innerWidth - inspector.offsetWidth;
                const maxY = window.innerHeight - inspector.offsetHeight;
                
                const clampedX = Math.max(0, Math.min(newX, maxX));
                const clampedY = Math.max(0, Math.min(newY, maxY));
                
                inspector.style.left = clampedX + 'px';
                inspector.style.top = clampedY + 'px';
                inspector.style.right = 'auto'; // Remove right positioning
                
                e.preventDefault();
            }
            
            function onDragEnd() {
                isDragging = false;
                inspector.classList.remove('dragging');
                document.removeEventListener('mousemove', onDrag);
                document.removeEventListener('mouseup', onDragEnd);
                
                // Save inspector position
                saveInspectorPosition();
            }
        }
        
        function initInspectorResize() {
            const inspector = document.getElementById('inspector');
            let resizeTimeout;
            
            // Use ResizeObserver to detect when inspector is resized
            if (window.ResizeObserver) {
                const resizeObserver = new ResizeObserver(entries => {
                    // Debounce the save operation
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        saveInspectorScale();
                    }, 100);
                });
                
                resizeObserver.observe(inspector);
            } else {
                // Fallback for older browsers - use window resize event
                let lastWidth = inspector.offsetWidth;
                let lastHeight = inspector.offsetHeight;
                
                window.addEventListener('resize', () => {
                    const currentWidth = inspector.offsetWidth;
                    const currentHeight = inspector.offsetHeight;
                    
                    if (currentWidth !== lastWidth || currentHeight !== lastHeight) {
                        clearTimeout(resizeTimeout);
                        resizeTimeout = setTimeout(() => {
                            saveInspectorScale();
                        }, 100);
                        
                        lastWidth = currentWidth;
                        lastHeight = currentHeight;
                    }
                });
            }
        }
        
        function initUIDragging() {
            const ui = document.getElementById('ui');
            const header = document.getElementById('ui-header');
            let isDraggingUI = false;
            let uiDragOffset = { x: 0, y: 0 };
            
            header.addEventListener('mousedown', (e) => {
                isDraggingUI = true;
                ui.classList.add('dragging');
                
                const rect = ui.getBoundingClientRect();
                uiDragOffset.x = e.clientX - rect.left;
                uiDragOffset.y = e.clientY - rect.top;
                
                document.addEventListener('mousemove', onUIDrag);
                document.addEventListener('mouseup', onUIDragEnd);
                
                e.preventDefault();
            });
            
            function onUIDrag(e) {
                if (!isDraggingUI) return;
                
                const newX = e.clientX - uiDragOffset.x;
                const newY = e.clientY - uiDragOffset.y;
                
                // Keep UI within viewport bounds
                const maxX = window.innerWidth - ui.offsetWidth;
                const maxY = window.innerHeight - ui.offsetHeight;
                
                const clampedX = Math.max(0, Math.min(newX, maxX));
                const clampedY = Math.max(0, Math.min(newY, maxY));
                
                ui.style.left = clampedX + 'px';
                ui.style.top = clampedY + 'px';
                
                e.preventDefault();
            }
            
            function onUIDragEnd() {
                isDraggingUI = false;
                ui.classList.remove('dragging');
                document.removeEventListener('mousemove', onUIDrag);
                document.removeEventListener('mouseup', onUIDragEnd);
                
                // Save UI position
                saveUIPosition();
            }
        }
        
        function saveUIPosition() {
            const ui = document.getElementById('ui');
            const position = {
                left: ui.style.left || '10px',
                top: ui.style.top || '10px'
            };
            localStorage.setItem('ecsUI_position', JSON.stringify(position));
        }
        
        function saveInspectorPosition() {
            const inspector = document.getElementById('inspector');
            const position = {
                left: inspector.style.left || 'auto',
                top: inspector.style.top || '10px',
                right: inspector.style.right || '10px',
                width: inspector.style.width || '320px',
                height: inspector.style.height || '400px'
            };
            localStorage.setItem('ecsInspector_position', JSON.stringify(position));
        }
        
        function saveInspectorScale() {
            const inspector = document.getElementById('inspector');
            const scale = {
                width: inspector.offsetWidth + 'px',
                height: inspector.offsetHeight + 'px'
            };
            localStorage.setItem('ecsInspector_scale', JSON.stringify(scale));
        }
        
        function loadPanelPositions() {
            // Load UI position
            const uiPosition = localStorage.getItem('ecsUI_position');
            if (uiPosition) {
                try {
                    const pos = JSON.parse(uiPosition);
                    const ui = document.getElementById('ui');
                    ui.style.left = pos.left;
                    ui.style.top = pos.top;
                } catch (e) {
                    console.log('Failed to load UI position:', e);
                }
            }
            
            // Load Inspector position
            const inspectorPosition = localStorage.getItem('ecsInspector_position');
            if (inspectorPosition) {
                try {
                    const pos = JSON.parse(inspectorPosition);
                    const inspector = document.getElementById('inspector');
                    
                    // Apply position
                    if (pos.left !== 'auto') {
                        inspector.style.left = pos.left;
                        inspector.style.right = 'auto';
                    } else {
                        inspector.style.right = pos.right;
                    }
                    inspector.style.top = pos.top;
                    inspector.style.width = pos.width;
                    inspector.style.height = pos.height;
                } catch (e) {
                    console.log('Failed to load Inspector position:', e);
                }
            }
            
            // Load Inspector scale
            const inspectorScale = localStorage.getItem('ecsInspector_scale');
            if (inspectorScale) {
                try {
                    const scale = JSON.parse(inspectorScale);
                    const inspector = document.getElementById('inspector');
                    inspector.style.width = scale.width;
                    inspector.style.height = scale.height;
                } catch (e) {
                    console.log('Failed to load Inspector scale:', e);
                }
            }
        }
        
        function updateInspector() {
            // Validate that selected entity still exists
            if (selectedEntity && !world.entities.find(e => e.id === selectedEntity.id)) {
                selectedEntity = null; // Clear selection if entity no longer exists
            }
            
            const entityList = document.getElementById('entityList');
            entityList.innerHTML = '';
            
            console.log(`🔄 Updating inspector, selected entity: ${selectedEntity ? selectedEntity.id : 'none'}`);
            
            // Show ALL entities, not just first 10
            world.entities.forEach(entity => {
                const card = document.createElement('div');
                card.className = 'entity-card';
                
                // Check if this entity is selected and apply style directly
                const isSelected = selectedEntity && selectedEntity.id === entity.id;
                if (isSelected) {
                    card.style.setProperty('background', 'rgba(76,175,80,0.5)', 'important');
                    card.style.setProperty('border', '2px solid #4CAF50', 'important');
                    card.style.setProperty('box-shadow', '0 0 8px rgba(76,175,80,0.6)', 'important');
                    card.style.setProperty('opacity', '1', 'important');
                    card.classList.add('selected');
                } else {
                    card.style.setProperty('background', 'rgba(255,255,255,0.1)', 'important');
                    card.style.setProperty('border', 'none', 'important');
                    card.style.setProperty('box-shadow', 'none', 'important');
                    card.style.setProperty('opacity', '0.6', 'important');
                    card.classList.remove('selected');
                }
                
                // Create header with entity name and buttons
                const header = document.createElement('div');
                header.className = 'entity-header';
                
                const entityName = document.createElement('strong');
                entityName.innerHTML = `<i data-lucide="box" style="width: 18px; height: 18px; vertical-align: text-bottom; margin-right: 6px;"></i>Entity ${entity.id}`;
                entityName.style.cursor = 'pointer';
                entityName.style.zIndex = '10';
                entityName.style.position = 'relative';
                
                // Add direct click handler to entity name
                entityName.addEventListener('click', (e) => {
                    console.log(`🖱️ Entity name clicked for entity ${entity.id}`);
                    selectEntity(entity);
                    e.stopPropagation();
                });
                
                const buttonContainer = document.createElement('div');
                buttonContainer.className = 'entity-buttons';
                
                // Add Component button
                const addBtn = document.createElement('button');
                addBtn.className = 'entity-btn';
                addBtn.innerHTML = '<i data-lucide="plus" style="width: 14px; height: 14px;"></i>';
                addBtn.title = 'Add Component';
                
                const componentTypes = ['Movement', 'Health', 'Lifetime', 'RigidbodyComponent', 'BoxColliderComponent', 'SphereColliderComponent', 'TweenComponent', 'AnimatorComponent', 'VisualComponent', 'PartyComponent', 'CharacterComponent', 'AIComponent', 'CombatComponent', 'InventoryComponent', 'VillageComponent', 'BuildingComponent', 'ResourceComponent', 'WorkerComponent', 'EconomyComponent'];
                const availableTypes = componentTypes.filter(type => !entity.hasComponent(type));
                addBtn.disabled = availableTypes.length === 0;
                
                addBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    addComponentToEntity(entity);
                });
                
                // Remove Component button
                const removeBtn = document.createElement('button');
                removeBtn.className = 'entity-btn remove';
                removeBtn.innerHTML = '<i data-lucide="minus" style="width: 14px; height: 14px;"></i>';
                removeBtn.title = 'Remove Component';
                
                const componentKeys = Array.from(entity.components.keys());
                const removableTypes = componentKeys.filter(type => 
                    type !== 'Transform' && type !== 'Renderable'
                );
                removeBtn.disabled = removableTypes.length === 0;
                
                removeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    removeComponentFromEntity(entity);
                });
                
                // Destroy Entity button
                const destroyBtn = document.createElement('button');
                destroyBtn.className = 'entity-btn destroy';
                destroyBtn.innerHTML = '<i data-lucide="trash-2" style="width: 14px; height: 14px;"></i>';
                destroyBtn.title = 'Destroy Entity';
                
                destroyBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    destroyEntity(entity);
                });
                
                buttonContainer.appendChild(addBtn);
                buttonContainer.appendChild(removeBtn);
                buttonContainer.appendChild(destroyBtn);
                header.appendChild(entityName);
                header.appendChild(buttonContainer);
                
                // Add click handler to header background (not buttons)
                header.addEventListener('click', (e) => {
                    // Only trigger if clicking on header background, not buttons or entity name
                    if (e.target === header) {
                        console.log(`🖱️ Header background clicked for entity ${entity.id}`);
                        selectEntity(entity);
                    }
                });
                
                card.appendChild(header);
                
                // Add components display
                const componentsDiv = document.createElement('div');
                Array.from(entity.components.keys()).forEach(componentType => {
                    const component = entity.components.get(componentType);
                    const cssClass = componentType.toLowerCase();
                    
                    let details = '';
                    if (componentType === 'Transform') {
                        details = `(${component.x.toFixed(1)}, ${component.y.toFixed(1)}, ${component.z.toFixed(1)})`;
                    } else if (componentType === 'Movement') {
                        const speed = Math.sqrt(
                            component.velocity.x ** 2 + 
                            component.velocity.y ** 2 + 
                            component.velocity.z ** 2
                        ).toFixed(1);
                        details = `(speed: ${speed})`;
                    } else if (componentType === 'Health') {
                        details = `(${Math.round(component.current)}/${component.max})`;
                    } else if (componentType === 'Lifetime') {
                        details = `(${component.remaining.toFixed(1)}s)`;
                    } else if (componentType === 'RigidbodyComponent') {
                        const kinematic = component.isKinematic ? 'kinematic' : 'dynamic';
                        const mass = component.mass.toFixed(1);
                        if (!component.isKinematic && component.velocity) {
                            const speed = Math.sqrt(
                                component.velocity.x ** 2 + 
                                component.velocity.y ** 2 + 
                                component.velocity.z ** 2
                            ).toFixed(1);
                            details = `(${kinematic}, v: ${speed})`;
                        } else {
                            details = `(${kinematic}, mass: ${mass})`;
                        }
                    } else if (componentType === 'BoxColliderComponent') {
                        const size = component.size;
                        details = `(${size.x}×${size.y}×${size.z})`;
                    } else if (componentType === 'SphereColliderComponent') {
                        details = `(radius: ${component.radius.toFixed(1)})`;
                    } else if (componentType === 'TweenComponent') {
                        const status = component.isPlaying ? 'playing' : 'stopped';
                        details = `(${status})`;
                    } else if (componentType === 'AnimatorComponent') {
                        const state = component.currentState || 'idle';
                        details = `(${state})`;
                    } else if (componentType === 'VisualComponent') {
                        const modes = [];
                        if (component.wireframe) modes.push('wire');
                        if (component.pointsMode) modes.push('points');
                        if (component.transparent) modes.push('transp');
                        if (!component.visible) modes.push('hidden');
                        details = modes.length > 0 ? `(${modes.join(', ')})` : '(default)';
                    } else if (componentType === 'PartyComponent') {
                        const memberCount = component.members.length;
                        const leader = component.activeLeader;
                        details = `(${memberCount}/${component.maxSize} members, leader: ${leader})`;
                    } else if (componentType === 'CharacterComponent') {
                        const health = `${component.currentHealth}/${component.maxHealth}`;
                        details = `(Lv.${component.level}, HP: ${health})`;
                    } else if (componentType === 'AIComponent') {
                        const state = component.currentState || 'idle';
                        details = `(${component.behaviorType}, ${state})`;
                    } else if (componentType === 'CombatComponent') {
                        const state = component.combatState || 'idle';
                        const power = component.attackPower;
                        details = `(ATK: ${power}, ${state})`;
                    } else if (componentType === 'InventoryComponent') {
                        const itemCount = component.slots.filter(slot => slot !== null).length;
                        const gold = component.currency;
                        details = `(${itemCount}/20 items, ${gold} gold)`;
                    }
                    
                    const componentSpan = document.createElement('span');
                    const isActive = component.active !== false; // Default to true if not set
                    componentSpan.className = `component ${cssClass} ${isActive ? 'active' : 'inactive'}`;
                    componentSpan.textContent = `${componentType} ${details}`;
                    componentSpan.style.cursor = 'pointer';
                    componentSpan.title = `Click to ${isActive ? 'disable' : 'enable'} component`;
                    
                    // Add click handler to toggle component
                    componentSpan.addEventListener('click', (e) => {
                        console.log(`🖠️ Component ${componentType} clicked for entity ${entity.id}`);
                        e.stopPropagation();
                        e.preventDefault();
                        toggleComponent(entity, componentType, component);
                    });
                    
                    componentsDiv.appendChild(componentSpan);
                });
                
                card.appendChild(componentsDiv);
                entityList.appendChild(card);
            });
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const now = Date.now();
            const deltaTime = (now - lastTime) / 1000;
            lastTime = now;
            
            // Update ECS world
            world.update(deltaTime);
            
            // Update physics system if available
            if (world.physicsSystem) {
                world.physicsSystem.update(deltaTime);
            }
            
            // Update Phase 3 systems if available
            if (world.partySystem) {
                world.partySystem.update(deltaTime);
            }
            if (world.characterSystem) {
                world.characterSystem.update(deltaTime);
            }
            if (world.aiSystem) {
                world.aiSystem.update(deltaTime);
            }
            if (world.combatSystem) {
                world.combatSystem.update(deltaTime);
            }
            if (world.inventorySystem) {
                world.inventorySystem.update(deltaTime);
            }
            
            // Update Phase 4 systems if available
            if (world.villageSystem) {
                world.villageSystem.update(deltaTime);
            }
            if (world.buildingSystem) {
                world.buildingSystem.update(deltaTime);
            }
            if (world.resourceSystem) {
                world.resourceSystem.update(deltaTime);
            }
            if (world.workerSystem) {
                world.workerSystem.update(deltaTime);
            }
            if (world.economySystem) {
                world.economySystem.update(deltaTime);
            }
            
            // Phase 5 systems
            if (world.questSystem) {
                world.questSystem.update(deltaTime);
            }
            if (world.dialogueSystem) {
                world.dialogueSystem.update(deltaTime);
            }
            if (world.npcSystem) {
                world.npcSystem.update(deltaTime);
            }
            if (world.eventSystem) {
                world.eventSystem.update(deltaTime);
            }
            
            
            // Update UI less frequently to avoid flickering (every 1000ms)
            if ((now - lastInspectorUpdate) > 1000) {
                updateInspector();
                updateStatus();
                lastInspectorUpdate = now;
            }
            
            // Update collider visualization for selected entity
            if (selectedEntity) {
                updateColliderVisualization(selectedEntity);
            }
            
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            const frustumSize = 20;
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Initialize
        if (typeof THREE !== 'undefined') {
            init();
        } else {
            window.addEventListener('load', init);
        }
        
        // Load Phase 2 components at initialization
        
        function loadPhase2Components(callback) {
            if (phase2ComponentsLoaded) {
                if (callback) callback();
                return;
            }
            
            console.log('📦 Loading Phase 2 components for ECS...');
            
            // Load GameEngine-standalone to get the component classes
            const gameEngineScript = document.createElement('script');
            gameEngineScript.src = './GameEngine-standalone.js';
            gameEngineScript.onload = () => {
                console.log('✅ Phase 2 components loaded and available in ECS');
                phase2ComponentsLoaded = true;
                
                // Add physics system to existing ECS
                addPhysicsSystemToECS();
                
                if (callback) callback();
            };
            gameEngineScript.onerror = () => {
                console.error('❌ Failed to load Phase 2 components');
                if (callback) callback();
            };
            document.head.appendChild(gameEngineScript);
        }
        
        function addPhysicsSystemToECS() {
            // Add a proper physics system based on PhysicsSystem from GameEngine
            if (!world.physicsSystem) {
                world.physicsSystem = {
                    gravity: new THREE.Vector3(0, -9.81, 0),
                    enableGravity: true,
                    requiredComponents: ['Transform', 'RigidbodyComponent'],
                    
                    update: function(deltaTime) {
                        // Process entities using proper ECS pattern
                        world.entities.forEach(entity => {
                            if (!this.entityMatches(entity)) return;
                            
                            const transform = entity.getComponent('Transform');
                            const rigidbody = entity.getComponent('RigidbodyComponent');
                            
                            if (rigidbody.isKinematic || rigidbody.isSleeping || rigidbody.active === false || transform.active === false) return;
                            
                            // Apply gravity
                            if (rigidbody.useGravity && this.enableGravity) {
                                rigidbody.forces = rigidbody.forces || [];
                                const gravityForce = this.gravity.clone().multiplyScalar(rigidbody.mass);
                                rigidbody.forces.push(gravityForce);
                            }
                            
                            // Apply forces to acceleration
                            rigidbody.acceleration = rigidbody.acceleration || new THREE.Vector3(0, 0, 0);
                            rigidbody.acceleration.set(0, 0, 0);
                            
                            if (rigidbody.forces) {
                                rigidbody.forces.forEach(force => {
                                    rigidbody.acceleration.add(force.clone().divideScalar(rigidbody.mass));
                                });
                                rigidbody.forces = []; // Clear forces
                            }
                            
                            // Apply drag
                            if (rigidbody.drag) {
                                const dragForce = rigidbody.velocity.clone().multiplyScalar(-rigidbody.drag);
                                rigidbody.acceleration.add(dragForce);
                            }
                            
                            // Update velocity
                            rigidbody.velocity.add(rigidbody.acceleration.clone().multiplyScalar(deltaTime));
                            
                            // Update position 
                            const deltaPosition = rigidbody.velocity.clone().multiplyScalar(deltaTime);
                            transform.x += deltaPosition.x;
                            transform.y += deltaPosition.y;
                            transform.z += deltaPosition.z;
                            
                            // Simple ground collision with collider detection
                            const sphereCollider = entity.getComponent('SphereColliderComponent');
                            const boxCollider = entity.getComponent('BoxColliderComponent');
                            
                            let colliderRadius = 0.5; // Default
                            if (sphereCollider) {
                                colliderRadius = sphereCollider.radius;
                            } else if (boxCollider) {
                                colliderRadius = Math.min(boxCollider.size.x, boxCollider.size.y, boxCollider.size.z) / 2;
                            }
                            
                            if (transform.y < colliderRadius) {
                                transform.y = colliderRadius;
                                rigidbody.velocity.y = Math.abs(rigidbody.velocity.y) * 0.7; // Bounce with restitution
                                
                                // Wake up if sleeping
                                rigidbody.isSleeping = false;
                            }
                            
                            // Check for sleep threshold
                            if (rigidbody.velocity.length() < (rigidbody.sleepThreshold || 0.01)) {
                                rigidbody.isSleeping = true;
                            }
                        });
                    },
                    
                    entityMatches: function(entity) {
                        return this.requiredComponents.every(componentType => entity.hasComponent(componentType));
                    },
                    
                    getStats: function() {
                        return {
                            gravity: this.gravity.clone(),
                            enableGravity: this.enableGravity
                        };
                    }
                };
                console.log('✅ Proper PhysicsSystem integrated into existing ECS with collision detection');
            }
        }
        
        // === Phase 3 Systems ===
        function addPhase3SystemsToECS() {
            console.log('🎯 Adding Phase 3 systems to ECS...');
            
            // PartySystem
            if (!world.partySystem) {
                world.partySystem = {
                    update: function(deltaTime) {
                        world.entities.forEach(entity => {
                            const party = entity.getComponent('PartyComponent');
                            if (!party || party.active === false) return;
                            
                            this.updatePartyFormation(entity, party);
                            this.updateFollowerPositions(entity, party, deltaTime);
                        });
                    },
                    
                    updatePartyFormation: function(partyEntity, party) {
                        const leaderId = party.getLeader();
                        const leader = world.entities.find(entity => entity.id === leaderId);
                        if (!leader) return;
                        
                        const leaderTransform = leader.getComponent('Transform');
                        if (!leaderTransform) return;
                        
                        // Update formation positions for followers
                        for (let i = 0; i < party.members.length; i++) {
                            if (i === party.activeLeader) continue; // Skip leader
                            
                            const follower = world.entities.find(entity => entity.id === party.members[i]);
                            if (!follower) continue;
                            
                            const followerTransform = follower.getComponent('Transform');
                            if (!followerTransform) continue;
                            
                            // Calculate formation position
                            const formationPos = this.calculateFormationPosition(
                                leaderTransform, i, party.formation, party.spacing
                            );
                            
                            // Set follower target position (will be handled by AI)
                            const ai = follower.getComponent('AIComponent');
                            if (ai) {
                                ai.target = party.getLeader();
                                ai.lastKnownTargetPosition = formationPos;
                            }
                        }
                    },
                    
                    calculateFormationPosition: function(leaderTransform, memberIndex, formation, spacing) {
                        const pos = { x: leaderTransform.x, y: leaderTransform.y, z: leaderTransform.z };
                        
                        switch (formation) {
                            case 'line':
                                pos.x -= spacing * (memberIndex + 1);
                                break;
                            case 'triangle':
                                const side = memberIndex % 2 === 0 ? -1 : 1;
                                pos.x += side * spacing * Math.ceil(memberIndex / 2);
                                pos.z -= spacing * Math.ceil(memberIndex / 2);
                                break;
                            case 'column':
                                pos.z -= spacing * (memberIndex + 1);
                                break;
                        }
                        
                        return pos;
                    },
                    
                    updateFollowerPositions: function(partyEntity, party, deltaTime) {
                        // Smooth movement toward formation positions
                        // This would integrate with movement/AI systems
                    }
                };
            }
            
            // CharacterSystem  
            if (!world.characterSystem) {
                world.characterSystem = {
                    update: function(deltaTime) {
                        world.entities.forEach(entity => {
                            const character = entity.getComponent('CharacterComponent');
                            if (!character || character.active === false) return;
                            
                            this.updateCharacterStats(character);
                            this.processStatusEffects(character, deltaTime);
                        });
                    },
                    
                    updateCharacterStats: function(character) {
                        // Recalculate derived stats if needed
                        character.recalculateStats();
                    },
                    
                    processStatusEffects: function(character, deltaTime) {
                        const combat = character.entity?.getComponent('CombatComponent');
                        if (!combat) return;
                        
                        const now = performance.now() / 1000;
                        combat.statusEffects = combat.statusEffects.filter(effect => {
                            const elapsed = now - effect.startTime;
                            return elapsed < effect.duration;
                        });
                    }
                };
            }
            
            // AISystem
            if (!world.aiSystem) {
                world.aiSystem = {
                    update: function(deltaTime) {
                        world.entities.forEach(entity => {
                            const ai = entity.getComponent('AIComponent');
                            if (!ai || ai.active === false) return;
                            
                            const now = performance.now() / 1000;
                            if ((now - ai.lastDecisionTime) >= ai.decisionCooldown) {
                                this.processAI(entity, ai, deltaTime);
                                ai.lastDecisionTime = now;
                            }
                            
                            ai.stateTimer += deltaTime;
                        });
                    },
                    
                    processAI: function(entity, ai, deltaTime) {
                        const transform = entity.getComponent('Transform');
                        if (!transform) return;
                        
                        switch (ai.behaviorType) {
                            case 'follow':
                                this.processFollowBehavior(entity, ai, transform);
                                break;
                            case 'patrol':
                                this.processPatrolBehavior(entity, ai, transform);
                                break;
                            case 'guard':
                                this.processGuardBehavior(entity, ai, transform);
                                break;
                            case 'aggressive':
                                this.processAggressiveBehavior(entity, ai, transform);
                                break;
                        }
                    },
                    
                    processFollowBehavior: function(entity, ai, transform) {
                        if (!ai.target) return;
                        
                        const targetEntity = world.entities.find(entity => entity.id === ai.target);
                        if (!targetEntity) return;
                        
                        const targetTransform = targetEntity.getComponent('Transform');
                        if (!targetTransform) return;
                        
                        // Calculate distance to target
                        const dx = targetTransform.x - transform.x;
                        const dz = targetTransform.z - transform.z;
                        const distance = Math.sqrt(dx * dx + dz * dz);
                        
                        // Move toward target if too far
                        const movement = entity.getComponent('Movement');
                        if (movement && distance > 2.0) {
                            const moveSpeed = 2.0;
                            movement.velocity.x = (dx / distance) * moveSpeed;
                            movement.velocity.z = (dz / distance) * moveSpeed;
                            ai.setState('moving');
                        } else if (movement) {
                            movement.velocity.x = 0;
                            movement.velocity.z = 0;
                            ai.setState('idle');
                        }
                    },
                    
                    processPatrolBehavior: function(entity, ai, transform) {
                        // Patrol between waypoints
                        if (ai.patrolPoints.length === 0) return;
                        
                        const targetPoint = ai.patrolPoints[ai.currentPatrolIndex];
                        const dx = targetPoint.x - transform.x;
                        const dz = targetPoint.z - transform.z;
                        const distance = Math.sqrt(dx * dx + dz * dz);
                        
                        if (distance < 1.0) {
                            // Reached waypoint, move to next
                            ai.currentPatrolIndex = (ai.currentPatrolIndex + 1) % ai.patrolPoints.length;
                        } else {
                            // Move toward current waypoint
                            const movement = entity.getComponent('Movement');
                            if (movement) {
                                const moveSpeed = 1.5;
                                movement.velocity.x = (dx / distance) * moveSpeed;
                                movement.velocity.z = (dz / distance) * moveSpeed;
                            }
                        }
                    },
                    
                    processGuardBehavior: function(entity, ai, transform) {
                        // Stay in place and watch for threats
                        const movement = entity.getComponent('Movement');
                        if (movement) {
                            movement.velocity.x = 0;
                            movement.velocity.z = 0;
                        }
                        ai.setState('guarding');
                    },
                    
                    processAggressiveBehavior: function(entity, ai, transform) {
                        // Look for targets and attack
                        if (!ai.target) {
                            // Find nearest enemy (for now, just find any other entity)
                            let nearestEntity = null;
                            let nearestDistance = ai.detectionRadius;
                            
                            world.entities.forEach((otherEntity, id) => {
                                if (otherEntity.id === entity.id) return;
                                
                                const otherTransform = otherEntity.getComponent('Transform');
                                if (!otherTransform) return;
                                
                                const dx = otherTransform.x - transform.x;
                                const dz = otherTransform.z - transform.z;
                                const distance = Math.sqrt(dx * dx + dz * dz);
                                
                                if (distance < nearestDistance) {
                                    nearestEntity = otherEntity;
                                    nearestDistance = distance;
                                }
                            });
                            
                            if (nearestEntity) {
                                ai.setTarget(nearestEntity.id);
                            }
                        } else {
                            // Chase and attack target
                            this.processFollowBehavior(entity, ai, transform);
                            
                            const targetEntity = world.entities.find(entity => entity.id === ai.target);
                            if (targetEntity) {
                                const targetTransform = targetEntity.getComponent('Transform');
                                if (targetTransform) {
                                    const dx = targetTransform.x - transform.x;
                                    const dz = targetTransform.z - transform.z;
                                    const distance = Math.sqrt(dx * dx + dz * dz);
                                    
                                    if (distance <= ai.attackRadius) {
                                        const combat = entity.getComponent('CombatComponent');
                                        if (combat && combat.canAttack()) {
                                            const attackResult = combat.attack();
                                            if (attackResult) {
                                                console.log(`🗡️ Entity ${entity.id} attacks for ${attackResult.damage} damage${attackResult.isCritical ? ' (CRITICAL!)' : ''}`);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                };
            }
            
            // CombatSystem
            if (!world.combatSystem) {
                world.combatSystem = {
                    update: function(deltaTime) {
                        world.entities.forEach(entity => {
                            const combat = entity.getComponent('CombatComponent');
                            if (!combat || combat.active === false) return;
                            
                            this.updateCombatState(combat, deltaTime);
                            this.processStatusEffects(combat, deltaTime);
                            this.processCombatCooldowns(combat, deltaTime);
                        });
                    },
                    
                    updateCombatState: function(combat, deltaTime) {
                        // Reset combat state after attacks
                        if (combat.combatState === 'attacking') {
                            const now = performance.now() / 1000;
                            if ((now - combat.lastAttackTime) > 0.5) { // 0.5s attack animation
                                combat.combatState = 'idle';
                            }
                        }
                    },
                    
                    processStatusEffects: function(combat, deltaTime) {
                        const now = performance.now() / 1000;
                        combat.statusEffects = combat.statusEffects.filter(effect => {
                            const elapsed = now - effect.startTime;
                            if (elapsed >= effect.duration) {
                                console.log(`✨ Status effect ${effect.type} expired`);
                                return false;
                            }
                            return true;
                        });
                    },
                    
                    processCombatCooldowns: function(combat, deltaTime) {
                        // Handle ability cooldowns and other timers
                        // This would be expanded with more complex combat mechanics
                    },
                    
                    dealDamage: function(attackerEntity, targetEntity, damage) {
                        const targetCharacter = targetEntity.getComponent('CharacterComponent');
                        const targetHealth = targetEntity.getComponent('Health');
                        
                        if (targetCharacter) {
                            targetCharacter.currentHealth -= damage;
                            console.log(`💥 ${targetEntity.id} takes ${damage} damage (${targetCharacter.currentHealth}/${targetCharacter.maxHealth} HP)`);
                            
                            if (targetCharacter.currentHealth <= 0) {
                                console.log(`💀 Entity ${targetEntity.id} has been defeated!`);
                                // Could trigger death/destruction logic here
                            }
                        } else if (targetHealth) {
                            targetHealth.current -= damage;
                            console.log(`💥 ${targetEntity.id} takes ${damage} damage (${targetHealth.current}/${targetHealth.max} HP)`);
                        }
                    }
                };
            }
            
            // InventorySystem
            if (!world.inventorySystem) {
                world.inventorySystem = {
                    update: function(deltaTime) {
                        world.entities.forEach(entity => {
                            const inventory = entity.getComponent('InventoryComponent');
                            if (!inventory || inventory.active === false) return;
                            
                            this.updateInventoryWeight(inventory);
                        });
                    },
                    
                    updateInventoryWeight: function(inventory) {
                        let totalWeight = 0;
                        inventory.slots.forEach(slot => {
                            if (slot !== null) {
                                totalWeight += (slot.item.weight || 1) * slot.quantity;
                            }
                        });
                        inventory.currentWeight = totalWeight;
                    },
                    
                    transferItem: function(fromInventory, toInventory, fromSlot, toSlot) {
                        const item = fromInventory.slots[fromSlot];
                        if (!item) return false;
                        
                        if (toInventory.slots[toSlot] === null) {
                            toInventory.slots[toSlot] = item;
                            fromInventory.slots[fromSlot] = null;
                            console.log(`📦 Transferred ${item.item.name || 'item'} to new slot`);
                            return true;
                        }
                        return false;
                    },
                    
                    createRandomItem: function() {
                        const items = [
                            { name: 'Sword', weight: 3, value: 50, type: 'weapon' },
                            { name: 'Shield', weight: 5, value: 30, type: 'armor' },
                            { name: 'Potion', weight: 1, value: 10, type: 'consumable' },
                            { name: 'Gold Coin', weight: 0.1, value: 1, type: 'currency' },
                            { name: 'Magic Ring', weight: 0.5, value: 100, type: 'accessory' }
                        ];
                        return items[Math.floor(Math.random() * items.length)];
                    }
                };
            }
            
            console.log('🎯 Phase 3 systems integration complete');
        }
        
        // === Phase 4 Systems: World Building ===
        function addPhase4SystemsToECS() {
            console.log('🏗️ Adding Phase 4 systems to ECS...');
            
            // VillageSystem
            if (!world.villageSystem) {
                world.villageSystem = {
                    update: function(deltaTime) {
                        world.entities.forEach(entity => {
                            const village = entity.getComponent('VillageComponent');
                            if (!village || village.active === false) return;
                            
                            this.updatePopulation(village, deltaTime);
                            this.updateMorale(village);
                            this.processGrowth(village, deltaTime);
                        });
                    },
                    
                    updatePopulation: function(village, deltaTime) {
                        // Natural population growth/decline
                        const timeInDays = deltaTime / (24 * 3600); // Convert to days for growth calculations
                        
                        if (village.morale > 60 && village.population < village.maxPopulation) {
                            // Growth based on morale and current population
                            const growthChance = village.growthRate * timeInDays * (village.morale / 100);
                            if (Math.random() < growthChance * 0.01) { // Very slow growth for demo
                                village.addPopulation(1);
                                console.log(`👶 ${village.name} population grew to ${village.population}`);
                            }
                        } else if (village.morale < 30) {
                            // Population decline due to low morale
                            const declineChance = village.emigrationRate * timeInDays * (1 - village.morale / 100);
                            if (Math.random() < declineChance * 0.01) {
                                village.removePopulation(1);
                                console.log(`😞 ${village.name} population declined to ${village.population}`);
                            }
                        }
                    },
                    
                    updateMorale: function(village) {
                        // Recalculate morale based on village conditions
                        village.calculateMorale();
                        
                        // Random events affecting morale
                        if (Math.random() < 0.001) { // 0.1% chance per update
                            const events = [
                                { name: 'Good Harvest', happiness: 10, prosperity: 5 },
                                { name: 'Festival', happiness: 15, morale: 5 },
                                { name: 'Disease Outbreak', happiness: -15, safety: -10 },
                                { name: 'Bandits Spotted', safety: -10, happiness: -5 },
                                { name: 'Trade Success', prosperity: 10, happiness: 5 }
                            ];
                            
                            const event = events[Math.floor(Math.random() * events.length)];
                            if (event.happiness) village.happiness = Math.max(0, Math.min(100, village.happiness + event.happiness));
                            if (event.prosperity) village.prosperity = Math.max(0, Math.min(100, village.prosperity + event.prosperity));
                            if (event.safety) village.safety = Math.max(0, Math.min(100, village.safety + event.safety));
                            if (event.morale) village.morale = Math.max(0, Math.min(100, village.morale + event.morale));
                            
                            console.log(`📰 ${village.name}: ${event.name}!`);
                        }
                    },
                    
                    processGrowth: function(village, deltaTime) {
                        // Update village age and handle milestones
                        const age = (Date.now() - village.founded) / 1000; // Age in seconds
                        
                        // Unlock population capacity based on age
                        if (age > 300 && village.maxPopulation < 75) { // 5 minutes = small growth
                            village.maxPopulation = 75;
                            console.log(`🏘️ ${village.name} expanded its borders! Max population: ${village.maxPopulation}`);
                        } else if (age > 600 && village.maxPopulation < 100) { // 10 minutes = major growth
                            village.maxPopulation = 100;
                            console.log(`🏘️ ${village.name} became a town! Max population: ${village.maxPopulation}`);
                        }
                    }
                };
            }
            
            // BuildingSystem
            if (!world.buildingSystem) {
                world.buildingSystem = {
                    update: function(deltaTime) {
                        world.entities.forEach(entity => {
                            const building = entity.getComponent('BuildingComponent');
                            if (!building || building.active === false) return;
                            
                            this.updateConstruction(building, deltaTime);
                            this.updateProduction(building, deltaTime);
                            this.updateMaintenance(building, deltaTime);
                        });
                    },
                    
                    updateConstruction: function(building, deltaTime) {
                        if (!building.isConstructed && building.constructionStarted) {
                            building.updateConstruction();
                            
                            if (building.isConstructed) {
                                console.log(`🏗️ ${building.buildingType} construction completed!`);
                            }
                        }
                    },
                    
                    updateProduction: function(building, deltaTime) {
                        if (building.isConstructed && building.produces && building.workersAssigned > 0) {
                            // Calculate efficiency based on workers and skill
                            const baseEfficiency = Math.min(1.0, building.workersAssigned / building.workersRequired);
                            building.efficiency = baseEfficiency * (building.health / building.maxHealth);
                            
                            // Generate resources
                            const productionAmount = building.productionRate * building.efficiency * deltaTime;
                            
                            if (productionAmount > 0) {
                                console.log(`⚙️ ${building.buildingType} produced ${productionAmount.toFixed(2)} ${building.produces}`);
                            }
                        }
                    },
                    
                    updateMaintenance: function(building, deltaTime) {
                        if (building.isConstructed) {
                            // Buildings slowly degrade over time
                            const degradationRate = 0.1; // Health lost per minute
                            building.health -= degradationRate * (deltaTime / 60);
                            building.health = Math.max(0, building.health);
                            
                            if (building.health <= 0 && building.isConstructed) {
                                console.log(`💥 ${building.buildingType} has collapsed due to poor maintenance!`);
                                building.isConstructed = false;
                                building.constructionProgress = 0;
                            } else if (building.health < 25) {
                                console.log(`⚠️ ${building.buildingType} needs urgent repairs!`);
                            }
                        }
                    },
                    
                    startBuilding: function(building, resourceComponent) {
                        if (resourceComponent && resourceComponent.hasResources(building.resourceRequirements)) {
                            if (resourceComponent.consumeResources(building.resourceRequirements)) {
                                building.startConstruction();
                                console.log(`🚧 Started building ${building.buildingType}`);
                                return true;
                            }
                        }
                        return false;
                    }
                };
            }
            
            // ResourceSystem
            if (!world.resourceSystem) {
                world.resourceSystem = {
                    update: function(deltaTime) {
                        world.entities.forEach(entity => {
                            const resource = entity.getComponent('ResourceComponent');
                            if (!resource || resource.active === false) return;
                            
                            this.updateProduction(resource, deltaTime);
                            this.updateConsumption(resource, deltaTime);
                            this.processDecay(resource, deltaTime);
                        });
                    },
                    
                    updateProduction: function(resource, deltaTime) {
                        // Generate resources over time
                        for (const [type, rate] of Object.entries(resource.productionRates)) {
                            if (rate > 0) {
                                const produced = resource.addResource(type, rate * deltaTime);
                                if (produced > 0 && Math.random() < 0.001) { // Occasional logging
                                    console.log(`⛏️ Produced ${produced.toFixed(1)} ${type}`);
                                }
                            }
                        }
                    },
                    
                    updateConsumption: function(resource, deltaTime) {
                        // Consume resources over time
                        for (const [type, rate] of Object.entries(resource.consumptionRates)) {
                            if (rate > 0) {
                                const consumed = resource.removeResource(type, rate * deltaTime);
                                if (consumed > 0 && resource.resources[type] <= 10) {
                                    console.log(`⚠️ Low ${type}! Only ${resource.resources[type].toFixed(1)} remaining`);
                                }
                            }
                        }
                    },
                    
                    processDecay: function(resource, deltaTime) {
                        // Food spoilage
                        if (resource.resources.food > 100) {
                            const spoilage = (resource.resources.food - 100) * 0.01 * deltaTime;
                            resource.removeResource('food', spoilage);
                            if (spoilage > 0.1) {
                                console.log(`🦠 ${spoilage.toFixed(1)} food spoiled due to poor storage`);
                            }
                        }
                    },
                    
                    transferResources: function(fromResource, toResource, transfers) {
                        for (const [type, amount] of Object.entries(transfers)) {
                            const available = fromResource.removeResource(type, amount);
                            toResource.addResource(type, available);
                        }
                    }
                };
            }
            
            // WorkerSystem
            if (!world.workerSystem) {
                world.workerSystem = {
                    update: function(deltaTime) {
                        world.entities.forEach(entity => {
                            const worker = entity.getComponent('WorkerComponent');
                            if (!worker || worker.active === false) return;
                            
                            this.updateWork(worker, deltaTime);
                            this.updateWellbeing(worker, deltaTime);
                            this.processSkillGrowth(worker, deltaTime);
                        });
                    },
                    
                    updateWork: function(worker, deltaTime) {
                        const currentHour = new Date().getHours();
                        const shouldWork = currentHour >= worker.workSchedule.startTime && 
                                         currentHour < worker.workSchedule.endTime && 
                                         currentHour !== worker.workSchedule.breakTime;
                        
                        if (shouldWork && worker.job !== 'unemployed') {
                            const productivity = worker.work(deltaTime);
                            if (productivity > 0 && Math.random() < 0.001) {
                                console.log(`👷 ${worker.name} working as ${worker.job} (productivity: ${productivity.toFixed(2)})`);
                            }
                        } else {
                            worker.rest(deltaTime);
                        }
                    },
                    
                    updateWellbeing: function(worker, deltaTime) {
                        // Happiness affects productivity
                        if (worker.energy < 30) {
                            worker.happiness -= deltaTime * 0.1; // Tired workers become unhappy
                        } else if (worker.energy > 80) {
                            worker.happiness += deltaTime * 0.05; // Well-rested workers are happier
                        }
                        
                        // Loyalty changes based on treatment
                        if (worker.happiness > 80) {
                            worker.loyalty += deltaTime * 0.02;
                        } else if (worker.happiness < 20) {
                            worker.loyalty -= deltaTime * 0.05;
                            
                            if (worker.loyalty < 10 && Math.random() < 0.001) {
                                console.log(`😠 ${worker.name} is considering quitting due to poor conditions`);
                            }
                        }
                        
                        // Clamp values
                        worker.happiness = Math.max(0, Math.min(100, worker.happiness));
                        worker.loyalty = Math.max(0, Math.min(100, worker.loyalty));
                    },
                    
                    processSkillGrowth: function(worker, deltaTime) {
                        // Workers improve skills over time
                        if (worker.isWorking && worker.skill < 10) {
                            const skillGrowthRate = 0.001; // Very slow skill growth
                            worker.experience += skillGrowthRate * deltaTime;
                            
                            const newSkill = Math.min(10, Math.floor(worker.experience / 100) + 1);
                            if (newSkill > worker.skill) {
                                worker.skill = newSkill;
                                worker.productivity = 1.0 + (worker.skill - 1) * 0.1;
                                console.log(`📈 ${worker.name} improved to skill level ${worker.skill}!`);
                            }
                        }
                    },
                    
                    assignWorker: function(worker, building) {
                        if (building && building.workersAssigned < building.workersRequired) {
                            worker.assignToJob(building.buildingType, building);
                            building.workersAssigned++;
                            console.log(`👷 ${worker.name} assigned to work at ${building.buildingType}`);
                            return true;
                        }
                        return false;
                    }
                };
            }
            
            // EconomySystem
            if (!world.economySystem) {
                world.economySystem = {
                    update: function(deltaTime) {
                        world.entities.forEach(entity => {
                            const economy = entity.getComponent('EconomyComponent');
                            if (!economy || economy.active === false) return;
                            
                            this.updateMarket(economy, deltaTime);
                            this.processTrade(economy, deltaTime);
                        });
                    },
                    
                    updateMarket: function(economy, deltaTime) {
                        // Update market prices based on supply and demand
                        economy.updateMarketPrices();
                        
                        // Random market fluctuations
                        if (Math.random() < 0.001) { // 0.1% chance per update
                            const resources = Object.keys(economy.marketPrices);
                            const resource = resources[Math.floor(Math.random() * resources.length)];
                            const fluctuation = (Math.random() - 0.5) * 0.2; // ±10% change
                            
                            economy.marketPrices[resource] *= (1 + fluctuation);
                            economy.marketPrices[resource] = Math.max(0.1, economy.marketPrices[resource]);
                            
                            console.log(`📈 Market: ${resource} price changed to ${economy.marketPrices[resource].toFixed(2)}`);
                        }
                    },
                    
                    processTrade: function(economy, deltaTime) {
                        // Simulate some automatic trading
                        if (Math.random() < 0.0005) { // Very rare automatic trades
                            const resources = Object.keys(economy.marketPrices);
                            const resource = resources[Math.floor(Math.random() * resources.length)];
                            const amount = Math.floor(Math.random() * 10) + 1;
                            const isBuying = Math.random() > 0.5;
                            
                            const price = economy.trade(resource, amount, isBuying);
                            console.log(`💱 Market ${isBuying ? 'bought' : 'sold'} ${amount} ${resource} for ${price.toFixed(2)} gold`);
                        }
                    },
                    
                    calculateTradeValue: function(economy, resource, amount) {
                        const basePrice = economy.marketPrices[resource];
                        const reputationModifier = 0.5 + (economy.reputation / 100); // 50% to 150% based on reputation
                        return basePrice * amount * reputationModifier;
                    }
                };
            }
            
            console.log('🏗️ Phase 4 systems integration complete');
        }
        
        function addPhase5SystemsToECS() {
            console.log('🎯 Adding Phase 5 systems to ECS...');
            
            // Quest System - handles quest progression and objectives
            if (!world.questSystem) {
                world.questSystem = {
                    update: function(deltaTime) {
                        world.entities.forEach(entity => {
                            const quest = entity.getComponent('QuestComponent');
                            if (!quest || quest.active === false) return;
                            
                            this.processQuest(entity, quest, deltaTime);
                        });
                    },
                    
                    processQuest: function(entity, quest, deltaTime) {
                        if (quest.status === 'active') {
                            // Check objective completion conditions
                            quest.objectives.forEach(objective => {
                                if (!objective.completed) {
                                    this.checkObjectiveProgress(objective, entity);
                                }
                            });
                            
                            // Check if quest is completed
                            if (quest.isCompleted() && quest.status === 'active') {
                                this.completeQuest(entity, quest);
                            }
                        }
                    },
                    
                    checkObjectiveProgress: function(objective, questEntity) {
                        // Example: check for kill objectives
                        if (objective.type === 'kill') {
                            // This would integrate with combat system
                            if (Math.random() < 0.001) { // Simulate progress
                                objective.current = Math.min(objective.current + 1, objective.required);
                                objective.completed = objective.current >= objective.required;
                            }
                        }
                    },
                    
                    completeQuest: function(entity, quest) {
                        quest.status = 'completed';
                        quest.completionTime = Date.now();
                        
                        // Grant rewards
                        const character = entity.getComponent('CharacterComponent');
                        if (character && quest.rewards) {
                            if (quest.rewards.experience) {
                                character.experience += quest.rewards.experience;
                            }
                            if (quest.rewards.gold) {
                                character.gold += quest.rewards.gold;
                            }
                        }
                        
                        console.log(`✅ Quest '${quest.title}' completed for entity ${entity.id}`);
                    },
                    
                    startQuest: function(entity, questId) {
                        const quest = entity.getComponent('QuestComponent');
                        if (quest && quest.questId === questId) {
                            quest.status = 'active';
                            quest.startTime = Date.now();
                            console.log(`🎯 Quest '${quest.title}' started for entity ${entity.id}`);
                        }
                    }
                };
            }
            
            // Dialogue System - manages conversation flow
            if (!world.dialogueSystem) {
                world.dialogueSystem = {
                    activeDialogues: new Map(), // Entity ID -> dialogue state
                    
                    update: function(deltaTime) {
                        world.entities.forEach(entity => {
                            const dialogue = entity.getComponent('DialogueComponent');
                            if (!dialogue || dialogue.active === false) return;
                            
                            this.processDialogue(entity, dialogue, deltaTime);
                        });
                    },
                    
                    processDialogue: function(entity, dialogue, deltaTime) {
                        // Update relationship values over time
                        if (dialogue.lastInteraction) {
                            const timeSinceInteraction = Date.now() - dialogue.lastInteraction;
                            
                            // Relationships naturally decay over time
                            if (timeSinceInteraction > 86400000) { // 24 hours
                                Object.keys(dialogue.relationship).forEach(rel => {
                                    dialogue.relationship[rel] = Math.max(0, 
                                        dialogue.relationship[rel] - 0.1 * deltaTime);
                                });
                            }
                        }
                    },
                    
                    startConversation: function(entity, playerEntity = null) {
                        const dialogue = entity.getComponent('DialogueComponent');
                        if (!dialogue) return null;
                        
                        const conversation = dialogue.startDialogue();
                        this.activeDialogues.set(entity.id, {
                            entity: entity,
                            player: playerEntity,
                            currentNode: conversation
                        });
                        
                        console.log(`💬 Started conversation with ${dialogue.characterName}`);
                        return conversation;
                    },
                    
                    makeChoice: function(entityId, choiceIndex) {
                        const activeDialogue = this.activeDialogues.get(entityId);
                        if (!activeDialogue) return null;
                        
                        const dialogue = activeDialogue.entity.getComponent('DialogueComponent');
                        const nextNode = dialogue.chooseOption(choiceIndex);
                        
                        if (nextNode) {
                            activeDialogue.currentNode = nextNode;
                        } else {
                            // Conversation ended
                            this.activeDialogues.delete(entityId);
                            console.log(`💬 Conversation with ${dialogue.characterName} ended`);
                        }
                        
                        return nextNode;
                    }
                };
            }
            
            // NPC System - advanced NPC behaviors and scheduling
            if (!world.npcSystem) {
                world.npcSystem = {
                    gameTime: 0, // Simulated game time in seconds
                    
                    update: function(deltaTime) {
                        this.gameTime += deltaTime;
                        
                        world.entities.forEach(entity => {
                            const npc = entity.getComponent('NPCComponent');
                            if (!npc || npc.active === false) return;
                            
                            this.processNPC(entity, npc, deltaTime);
                        });
                    },
                    
                    processNPC: function(entity, npc, deltaTime) {
                        // Update needs
                        npc.updateNeeds(deltaTime);
                        
                        // Update current activity based on schedule
                        const currentActivity = npc.getCurrentActivity(this.gameTime);
                        if (npc.currentActivity !== currentActivity.activity) {
                            npc.currentActivity = currentActivity.activity;
                            npc.activityStartTime = this.gameTime;
                            console.log(`🤖 ${npc.name} is now ${currentActivity.activity} at ${currentActivity.location}`);
                        }
                        
                        // Process social interactions
                        this.processSocialBehavior(entity, npc, deltaTime);
                        
                        // Economic decision making
                        this.processEconomicBehavior(entity, npc, deltaTime);
                    },
                    
                    processSocialBehavior: function(entity, npc, deltaTime) {
                        // NPCs seek social interaction based on their needs
                        if (npc.needs.social < 30 && Math.random() < 0.001) {
                            // Look for nearby NPCs to socialize with
                            const nearbyNPCs = world.entities.filter(other => 
                                other !== entity && 
                                other.getComponent('NPCComponent') &&
                                other.getComponent('Transform')
                            );
                            
                            if (nearbyNPCs.length > 0) {
                                npc.needs.social += 10;
                                console.log(`😊 ${npc.name} socialized and feels better`);
                            }
                        }
                    },
                    
                    processEconomicBehavior: function(entity, npc, deltaTime) {
                        // NPCs make economic decisions based on their profession and needs
                        if (npc.needs.food < 50 && Math.random() < 0.0001) {
                            const economy = entity.getComponent('EconomyComponent');
                            if (economy && economy.marketPrices.food) {
                                // Buy food
                                const foodCost = economy.marketPrices.food * 5;
                                npc.needs.food += 20;
                                console.log(`🍞 ${npc.name} bought food for ${foodCost.toFixed(2)} gold`);
                            }
                        }
                    }
                };
            }
            
            // Event System - handles random and scripted world events
            if (!world.eventSystem) {
                world.eventSystem = {
                    activeEvents: [],
                    eventTimer: 0,
                    eventFrequency: 30, // Seconds between potential events
                    
                    update: function(deltaTime) {
                        this.eventTimer += deltaTime;
                        
                        // Process active events
                        this.activeEvents.forEach(event => {
                            event.processEvent(deltaTime, world);
                        });
                        
                        // Remove completed events
                        this.activeEvents = this.activeEvents.filter(event => 
                            event.status === 'active'
                        );
                        
                        // Check for new random events
                        if (this.eventTimer >= this.eventFrequency) {
                            this.eventTimer = 0;
                            this.checkForRandomEvents();
                        }
                        
                        // Process entity events
                        world.entities.forEach(entity => {
                            const eventComp = entity.getComponent('EventComponent');
                            if (!eventComp || eventComp.active === false) return;
                            
                            this.processEntityEvent(entity, eventComp, deltaTime);
                        });
                    },
                    
                    checkForRandomEvents: function() {
                        if (Math.random() < 0.3) { // 30% chance every interval
                            const eventEntities = world.entities.filter(entity => 
                                entity.getComponent('EventComponent')
                            );
                            
                            if (eventEntities.length > 0) {
                                const randomEntity = eventEntities[Math.floor(Math.random() * eventEntities.length)];
                                const eventComp = randomEntity.getComponent('EventComponent');
                                const triggeredEvent = eventComp.triggerRandomEvent();
                                
                                if (triggeredEvent) {
                                    this.activeEvents.push(eventComp);
                                    console.log(`🎲 Random event triggered: ${triggeredEvent.name}`);
                                }
                            }
                        }
                    },
                    
                    processEntityEvent: function(entity, eventComp, deltaTime) {
                        if (eventComp.status === 'active') {
                            eventComp.processEvent(deltaTime, world);
                            
                            // Apply event effects to nearby entities
                            if (eventComp.effects.moodModifiers) {
                                this.applyMoodEffects(entity, eventComp.effects.moodModifiers);
                            }
                        }
                    },
                    
                    applyMoodEffects: function(sourceEntity, moodModifiers) {
                        const transform = sourceEntity.getComponent('Transform');
                        if (!transform) return;
                        
                        // Affect nearby NPCs
                        world.entities.forEach(entity => {
                            const npc = entity.getComponent('NPCComponent');
                            const entityTransform = entity.getComponent('Transform');
                            
                            if (npc && entityTransform && entity !== sourceEntity) {
                                const distance = Math.sqrt(
                                    Math.pow(transform.x - entityTransform.x, 2) +
                                    Math.pow(transform.z - entityTransform.z, 2)
                                );
                                
                                if (distance < 10) { // Within 10 units
                                    Object.keys(moodModifiers).forEach(mood => {
                                        if (npc.needs[mood] !== undefined) {
                                            npc.needs[mood] = Math.max(0, Math.min(100, 
                                                npc.needs[mood] + moodModifiers[mood]
                                            ));
                                        }
                                    });
                                }
                            }
                        });
                    }
                };
            }
            
            console.log('🎯 Phase 5 systems integration complete');
        }
        
        // Load Phase 3 components and systems
        function loadPhase3Components(callback) {
            console.log('📦 Loading Phase 3 components for ECS...');
            
            // Verify Phase 3 components are available
            const componentsAvailable = [
                'PartyComponent',
                'CharacterComponent', 
                'AIComponent',
                'CombatComponent',
                'InventoryComponent'
            ].every(name => {
                const available = !!window[name];
                console.log(`  ${available ? '✅' : '❌'} ${name}: ${available ? 'Available' : 'Not found'}`);
                return available;
            });
            
            if (!componentsAvailable) {
                console.error('❌ Some Phase 3 components are not available on window!');
            }
            
            // Add Phase 3 systems to existing ECS
            addPhase3SystemsToECS();
            
            // Add Phase 4 systems to existing ECS
            addPhase4SystemsToECS();
            
            // Add Phase 5 systems to existing ECS
            addPhase5SystemsToECS();
            
            console.log('✅ Phase 3 components and systems loaded');
            console.log('✅ Phase 4 components and systems loaded');
            console.log('✅ Phase 5 components and systems loaded');
            if (callback) callback();
        }
        
        
        // Collider visualization
        function addColliderVisualization(entity) {
            if (!entity) return;
            
            const transform = entity.getComponent('Transform');
            if (!transform) return;
            
            // Always create visualizations - they show component state, not movement state
            
            // Remove existing collider visualizations
            removeColliderVisualization(entity);
            
            // Visualize SphereColliderComponent
            const sphereCollider = entity.getComponent('SphereColliderComponent');
            if (sphereCollider && sphereCollider.active !== false && !entity.sphereColliderHelper) {
                const geometry = new THREE.SphereGeometry(sphereCollider.radius, 16, 12);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x00ff88,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.6
                });
                const sphereHelper = new THREE.Mesh(geometry, material);
                
                // Position the helper
                sphereHelper.position.set(transform.x, transform.y, transform.z);
                sphereHelper.position.add(sphereCollider.center);
                
                // Store reference and add to scene
                entity.sphereColliderHelper = sphereHelper;
                scene.add(sphereHelper);
                
            }
            
            // Visualize BoxColliderComponent
            const boxCollider = entity.getComponent('BoxColliderComponent');
            if (boxCollider && boxCollider.active !== false && !entity.boxColliderHelper) {
                const geometry = new THREE.BoxGeometry(boxCollider.size.x, boxCollider.size.y, boxCollider.size.z);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x0088ff,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.6
                });
                const boxHelper = new THREE.Mesh(geometry, material);
                
                // Position the helper
                boxHelper.position.set(transform.x, transform.y, transform.z);
                boxHelper.position.add(boxCollider.center);
                
                // Store reference and add to scene
                entity.boxColliderHelper = boxHelper;
                scene.add(boxHelper);
                
            }
            
            // Visualize TweenComponent
            const tweenComponent = entity.getComponent('TweenComponent');
            if (tweenComponent && tweenComponent.active !== false) {
                // Create a pulsing ring around the entity to show it has tweening
                const ringGeometry = new THREE.RingGeometry(1.5, 2.0, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff44ff,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide
                });
                const ringHelper = new THREE.Mesh(ringGeometry, ringMaterial);
                
                // Position the ring horizontally around the entity
                ringHelper.position.set(transform.x, transform.y + 1, transform.z);
                ringHelper.rotation.x = Math.PI / 2; // Make it horizontal
                
                // Store reference and add to scene
                entity.tweenHelper = ringHelper;
                scene.add(ringHelper);
                
            }
            
            // Visualize AnimatorComponent
            const animatorComponent = entity.getComponent('AnimatorComponent');
            if (animatorComponent && animatorComponent.active !== false) {
                // Create rotating wireframe octahedron to show animation state
                const geometry = new THREE.OctahedronGeometry(1.2);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xaa44ff,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.8
                });
                const animatorHelper = new THREE.Mesh(geometry, material);
                
                // Position above the entity
                animatorHelper.position.set(transform.x, transform.y + 2.5, transform.z);
                
                // Store reference and add to scene
                entity.animatorHelper = animatorHelper;
                scene.add(animatorHelper);
                
            }
            
            // Visualize PartyComponent
            const party = entity.getComponent('PartyComponent');
            if (party && party.active !== false) {
                // Create party leadership indicator (crown)
                const crownGeometry = new THREE.ConeGeometry(0.2, 0.4, 6);
                const crownMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffd700,
                    transparent: true,
                    opacity: 0.9
                });
                const crownHelper = new THREE.Mesh(crownGeometry, crownMaterial);
                crownHelper.position.set(transform.x, transform.y + 2, transform.z);
                
                entity.partyHelper = crownHelper;
                scene.add(crownHelper);
                
            }
            
            // Visualize CharacterComponent
            const character = entity.getComponent('CharacterComponent');
            if (character && character.active !== false) {
                // Create health bar
                const healthBarGeometry = new THREE.PlaneGeometry(1, 0.1);
                const healthPercent = character.currentHealth / character.maxHealth;
                const healthColor = healthPercent > 0.5 ? 0x4caf50 : healthPercent > 0.2 ? 0xffeb3b : 0xf44336;
                const healthBarMaterial = new THREE.MeshBasicMaterial({ 
                    color: healthColor,
                    transparent: true,
                    opacity: 0.8
                });
                const healthBar = new THREE.Mesh(healthBarGeometry, healthBarMaterial);
                healthBar.position.set(transform.x, transform.y + 1.8, transform.z);
                healthBar.lookAt(camera.position);
                
                // Create level indicator
                const levelGeometry = new THREE.RingGeometry(0.15, 0.25, 8);
                const levelMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x2196f3,
                    transparent: true,
                    opacity: 0.7
                });
                const levelHelper = new THREE.Mesh(levelGeometry, levelMaterial);
                levelHelper.position.set(transform.x + 0.7, transform.y + 1.8, transform.z);
                levelHelper.lookAt(camera.position);
                
                entity.healthBarHelper = healthBar;
                entity.levelHelper = levelHelper;
                scene.add(healthBar);
                scene.add(levelHelper);
                
            }
            
            // Visualize AIComponent
            const ai = entity.getComponent('AIComponent');
            if (ai && ai.active !== false) {
                // Create behavior state indicator
                const behaviorGeometry = new THREE.SphereGeometry(0.15, 8, 6);
                let behaviorColor;
                switch(ai.behaviorType) {
                    case 'follow': behaviorColor = 0x4caf50; break;
                    case 'guard': behaviorColor = 0xff9800; break;
                    case 'patrol': behaviorColor = 0x2196f3; break;
                    case 'aggressive': behaviorColor = 0xf44336; break;
                    default: behaviorColor = 0x9e9e9e;
                }
                const behaviorMaterial = new THREE.MeshBasicMaterial({ 
                    color: behaviorColor,
                    transparent: true,
                    opacity: 0.8
                });
                const behaviorHelper = new THREE.Mesh(behaviorGeometry, behaviorMaterial);
                behaviorHelper.position.set(transform.x - 0.7, transform.y + 1.8, transform.z);
                
                entity.aiHelper = behaviorHelper;
                scene.add(behaviorHelper);
                
            }
            
            // Visualize CombatComponent
            const combat = entity.getComponent('CombatComponent');
            if (combat && combat.active !== false) {
                // Create attack range indicator
                const rangeGeometry = new THREE.RingGeometry(1.5, 1.7, 16);
                const rangeMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xf44336,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                const rangeHelper = new THREE.Mesh(rangeGeometry, rangeMaterial);
                rangeHelper.position.set(transform.x, transform.y + 0.1, transform.z);
                rangeHelper.rotation.x = -Math.PI / 2;
                
                entity.combatHelper = rangeHelper;
                scene.add(rangeHelper);
                
            }
            
            // Visualize InventoryComponent
            const inventory = entity.getComponent('InventoryComponent');
            if (inventory && inventory.active !== false) {
                // Create inventory bag indicator
                const bagGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                const bagMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x8d6e63,
                    transparent: true,
                    opacity: 0.9
                });
                const bagHelper = new THREE.Mesh(bagGeometry, bagMaterial);
                bagHelper.position.set(transform.x + 0.7, transform.y + 1.2, transform.z);
                
                entity.inventoryHelper = bagHelper;
                scene.add(bagHelper);
                
            }
            
            // Visualize Phase 4 Components
            
            // Visualize VillageComponent
            const village = entity.getComponent('VillageComponent');
            if (village && village.active !== false) {
                // Create village indicator (small house)
                const houseGeometry = new THREE.BoxGeometry(0.4, 0.4, 0.4);
                const houseMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x8bc34a,
                    transparent: true,
                    opacity: 0.9
                });
                const houseHelper = new THREE.Mesh(houseGeometry, houseMaterial);
                houseHelper.position.set(transform.x - 1.0, transform.y + 1.5, transform.z);
                
                // Add roof
                const roofGeometry = new THREE.ConeGeometry(0.3, 0.3, 4);
                const roofMaterial = new THREE.MeshBasicMaterial({ color: 0x795548 });
                const roofHelper = new THREE.Mesh(roofGeometry, roofMaterial);
                roofHelper.position.set(transform.x - 1.0, transform.y + 1.8, transform.z);
                
                entity.villageHelper = houseHelper;
                entity.villageRoofHelper = roofHelper;
                scene.add(houseHelper);
                scene.add(roofHelper);
                
            }
            
            // Visualize BuildingComponent
            const building = entity.getComponent('BuildingComponent');
            if (building && building.active !== false) {
                // Create building indicator based on type
                let buildingColor;
                switch(building.buildingType) {
                    case 'house': buildingColor = 0x8bc34a; break;
                    case 'farm': buildingColor = 0x4caf50; break;
                    case 'workshop': buildingColor = 0x795548; break;
                    case 'storage': buildingColor = 0xff9800; break;
                    case 'barracks': buildingColor = 0xf44336; break;
                    default: buildingColor = 0x607d8b;
                }
                
                const buildingGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.6);
                const buildingMaterial = new THREE.MeshBasicMaterial({ 
                    color: buildingColor,
                    transparent: true,
                    opacity: building.isConstructed ? 0.8 : 0.4
                });
                const buildingHelper = new THREE.Mesh(buildingGeometry, buildingMaterial);
                buildingHelper.position.set(transform.x + 1.0, transform.y + 1.4, transform.z);
                
                entity.buildingHelper = buildingHelper;
                scene.add(buildingHelper);
                
            }
            
            // Visualize ResourceComponent
            const resource = entity.getComponent('ResourceComponent');
            if (resource && resource.active !== false) {
                // Create resource stack indicator
                const stackGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.5, 8);
                const stackMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff9800,
                    transparent: true,
                    opacity: 0.8
                });
                const stackHelper = new THREE.Mesh(stackGeometry, stackMaterial);
                stackHelper.position.set(transform.x, transform.y + 2.2, transform.z + 1.0);
                
                entity.resourceHelper = stackHelper;
                scene.add(stackHelper);
                
            }
            
            // Visualize WorkerComponent
            const worker = entity.getComponent('WorkerComponent');
            if (worker && worker.active !== false) {
                // Create worker tool indicator
                const toolGeometry = new THREE.BoxGeometry(0.1, 0.6, 0.1);
                const toolMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x607d8b,
                    transparent: true,
                    opacity: 0.9
                });
                const toolHelper = new THREE.Mesh(toolGeometry, toolMaterial);
                toolHelper.position.set(transform.x - 0.5, transform.y + 1.5, transform.z - 0.5);
                toolHelper.rotation.z = Math.PI / 4; // Lean the tool
                
                entity.workerHelper = toolHelper;
                scene.add(toolHelper);
                
            }
            
            // Visualize EconomyComponent
            const economy = entity.getComponent('EconomyComponent');
            if (economy && economy.active !== false) {
                // Store all coin helpers in an array
                entity.economyHelpers = [];
                
                // Stack multiple coins - create separate geometry and material for each
                for (let i = 0; i < 3; i++) {
                    const coinGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.05, 12);
                    const coinMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffc107,
                        transparent: true,
                        opacity: 0.9
                    });
                    
                    const coinHelper = new THREE.Mesh(coinGeometry, coinMaterial);
                    coinHelper.position.set(transform.x + 0.5, transform.y + 1.0 + (i * 0.1), transform.z + 0.5);
                    
                    entity.economyHelpers.push(coinHelper);
                    scene.add(coinHelper);
                }
                
                // Keep reference to first coin for easy access in updates
                entity.economyHelper = entity.economyHelpers[0];
                
            }
            
            // ===== PHASE 5 VISUALIZATIONS =====
            
            // Visualize QuestComponent
            const quest = entity.getComponent('QuestComponent');
            if (quest && quest.active !== false) {
                // Create quest indicator based on status
                let questColor;
                switch(quest.status) {
                    case 'available': questColor = 0xffeb3b; break; // Yellow
                    case 'active': questColor = 0x2196f3; break;    // Blue
                    case 'completed': questColor = 0x4caf50; break; // Green
                    case 'failed': questColor = 0xf44336; break;    // Red
                    default: questColor = 0x9e9e9e;                // Gray
                }
                
                const questGeometry = new THREE.ConeGeometry(0.2, 0.8, 4);
                const questMaterial = new THREE.MeshBasicMaterial({ 
                    color: questColor,
                    transparent: true,
                    opacity: 0.8
                });
                const questHelper = new THREE.Mesh(questGeometry, questMaterial);
                questHelper.position.set(transform.x - 1.0, transform.y + 1.5, transform.z);
                questHelper.rotation.x = Math.PI; // Point upward
                
                entity.questHelper = questHelper;
                scene.add(questHelper);
                
            }
            
            // Visualize DialogueComponent
            const dialogue = entity.getComponent('DialogueComponent');
            if (dialogue && dialogue.active !== false) {
                // Create speech bubble indicator
                const bubbleGeometry = new THREE.SphereGeometry(0.3, 8, 6);
                const bubbleMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xe1f5fe,
                    transparent: true,
                    opacity: 0.7
                });
                const bubbleHelper = new THREE.Mesh(bubbleGeometry, bubbleMaterial);
                bubbleHelper.position.set(transform.x + 1.5, transform.y + 1.8, transform.z);
                
                entity.dialogueHelper = bubbleHelper;
                scene.add(bubbleHelper);
                
            }
            
            // Visualize NPCComponent
            const npc = entity.getComponent('NPCComponent');
            if (npc && npc.active !== false) {
                // Create NPC type indicator
                let npcColor;
                switch(npc.npcType) {
                    case 'villager': npcColor = 0x8bc34a; break;   // Light green
                    case 'merchant': npcColor = 0xffc107; break;   // Amber
                    case 'guard': npcColor = 0x607d8b; break;      // Blue gray
                    case 'quest_giver': npcColor = 0x9c27b0; break; // Purple
                    case 'farmer': npcColor = 0x795548; break;     // Brown
                    default: npcColor = 0x2196f3;                 // Blue
                }
                
                const npcGeometry = new THREE.OctahedronGeometry(0.25, 0);
                const npcMaterial = new THREE.MeshBasicMaterial({ 
                    color: npcColor,
                    transparent: true,
                    opacity: 0.8
                });
                const npcHelper = new THREE.Mesh(npcGeometry, npcMaterial);
                npcHelper.position.set(transform.x, transform.y + 2.0, transform.z + 1.0);
                
                entity.npcHelper = npcHelper;
                scene.add(npcHelper);
                
            }
            
            // Visualize EventComponent
            const event = entity.getComponent('EventComponent');
            if (event && event.active !== false) {
                // Create event indicator based on type and status
                let eventColor;
                if (event.status === 'active') {
                    eventColor = 0xff5722; // Deep orange for active events
                } else {
                    switch(event.eventType) {
                        case 'random': eventColor = 0x4caf50; break;    // Green
                        case 'scripted': eventColor = 0x2196f3; break;  // Blue
                        case 'seasonal': eventColor = 0xff9800; break;  // Orange
                        case 'triggered': eventColor = 0x9c27b0; break; // Purple
                        default: eventColor = 0x607d8b;                // Blue gray
                    }
                }
                
                const eventGeometry = new THREE.TetrahedronGeometry(0.4, 0);
                const eventMaterial = new THREE.MeshBasicMaterial({ 
                    color: eventColor,
                    transparent: true,
                    opacity: event.status === 'active' ? 0.9 : 0.6
                });
                const eventHelper = new THREE.Mesh(eventGeometry, eventMaterial);
                eventHelper.position.set(transform.x - 1.5, transform.y + 2.2, transform.z);
                
                entity.eventHelper = eventHelper;
                scene.add(eventHelper);
                
            }
        }
        
        function removeColliderVisualization(entity) {
            if (!entity) return;
            
            // Remove sphere collider helper
            if (entity.sphereColliderHelper) {
                scene.remove(entity.sphereColliderHelper);
                entity.sphereColliderHelper.geometry.dispose();
                entity.sphereColliderHelper.material.dispose();
                delete entity.sphereColliderHelper;
            }
            
            // Remove box collider helper
            if (entity.boxColliderHelper) {
                scene.remove(entity.boxColliderHelper);
                entity.boxColliderHelper.geometry.dispose();
                entity.boxColliderHelper.material.dispose();
                delete entity.boxColliderHelper;
            }
            
            // Remove tween helper
            if (entity.tweenHelper) {
                scene.remove(entity.tweenHelper);
                entity.tweenHelper.geometry.dispose();
                entity.tweenHelper.material.dispose();
                delete entity.tweenHelper;
            }
            
            // Remove animator helper
            if (entity.animatorHelper) {
                scene.remove(entity.animatorHelper);
                entity.animatorHelper.geometry.dispose();
                entity.animatorHelper.material.dispose();
                delete entity.animatorHelper;
            }
            
            // Remove Phase 3 component helpers
            if (entity.partyHelper) {
                scene.remove(entity.partyHelper);
                entity.partyHelper.geometry.dispose();
                entity.partyHelper.material.dispose();
                delete entity.partyHelper;
            }
            
            if (entity.healthBarHelper) {
                scene.remove(entity.healthBarHelper);
                entity.healthBarHelper.geometry.dispose();
                entity.healthBarHelper.material.dispose();
                delete entity.healthBarHelper;
            }
            
            if (entity.levelHelper) {
                scene.remove(entity.levelHelper);
                entity.levelHelper.geometry.dispose();
                entity.levelHelper.material.dispose();
                delete entity.levelHelper;
            }
            
            if (entity.aiHelper) {
                scene.remove(entity.aiHelper);
                entity.aiHelper.geometry.dispose();
                entity.aiHelper.material.dispose();
                delete entity.aiHelper;
            }
            
            if (entity.combatHelper) {
                scene.remove(entity.combatHelper);
                entity.combatHelper.geometry.dispose();
                entity.combatHelper.material.dispose();
                delete entity.combatHelper;
            }
            
            if (entity.inventoryHelper) {
                scene.remove(entity.inventoryHelper);
                entity.inventoryHelper.geometry.dispose();
                entity.inventoryHelper.material.dispose();
                delete entity.inventoryHelper;
            }
            
            // Remove Phase 4 component helpers
            if (entity.villageHelper) {
                scene.remove(entity.villageHelper);
                entity.villageHelper.geometry.dispose();
                entity.villageHelper.material.dispose();
                delete entity.villageHelper;
            }
            
            if (entity.villageRoofHelper) {
                scene.remove(entity.villageRoofHelper);
                entity.villageRoofHelper.geometry.dispose();
                entity.villageRoofHelper.material.dispose();
                delete entity.villageRoofHelper;
            }
            
            if (entity.buildingHelper) {
                scene.remove(entity.buildingHelper);
                entity.buildingHelper.geometry.dispose();
                entity.buildingHelper.material.dispose();
                delete entity.buildingHelper;
            }
            
            if (entity.resourceHelper) {
                scene.remove(entity.resourceHelper);
                entity.resourceHelper.geometry.dispose();
                entity.resourceHelper.material.dispose();
                delete entity.resourceHelper;
            }
            
            if (entity.workerHelper) {
                scene.remove(entity.workerHelper);
                entity.workerHelper.geometry.dispose();
                entity.workerHelper.material.dispose();
                delete entity.workerHelper;
            }
            
            // Remove all economy helpers (multiple coins)
            if (entity.economyHelpers) {
                entity.economyHelpers.forEach(coinHelper => {
                    scene.remove(coinHelper);
                    coinHelper.geometry.dispose();
                    coinHelper.material.dispose();
                });
                delete entity.economyHelpers;
                delete entity.economyHelper; // Remove the reference to first coin too
            }
            
            // Phase 5 cleanup
            if (entity.questHelper) {
                scene.remove(entity.questHelper);
                entity.questHelper.geometry.dispose();
                entity.questHelper.material.dispose();
                delete entity.questHelper;
            }
            
            if (entity.dialogueHelper) {
                scene.remove(entity.dialogueHelper);
                entity.dialogueHelper.geometry.dispose();
                entity.dialogueHelper.material.dispose();
                delete entity.dialogueHelper;
            }
            
            if (entity.npcHelper) {
                scene.remove(entity.npcHelper);
                entity.npcHelper.geometry.dispose();
                entity.npcHelper.material.dispose();
                delete entity.npcHelper;
            }
            
            if (entity.eventHelper) {
                scene.remove(entity.eventHelper);
                entity.eventHelper.geometry.dispose();
                entity.eventHelper.material.dispose();
                delete entity.eventHelper;
            }
        }
        
        function updateColliderVisualization(entity) {
            if (!entity || entity !== selectedEntity) return;
            
            const transform = entity.getComponent('Transform');
            if (!transform || transform.active === false) return;
            
            const now = Date.now();
            
            // Update sphere collider position
            if (entity.sphereColliderHelper) {
                const sphereCollider = entity.getComponent('SphereColliderComponent');
                if (sphereCollider) {
                    entity.sphereColliderHelper.position.set(transform.x, transform.y, transform.z);
                    entity.sphereColliderHelper.position.add(sphereCollider.center);
                }
            }
            
            // Update box collider position
            if (entity.boxColliderHelper) {
                const boxCollider = entity.getComponent('BoxColliderComponent');
                if (boxCollider) {
                    entity.boxColliderHelper.position.set(transform.x, transform.y, transform.z);
                    entity.boxColliderHelper.position.add(boxCollider.center);
                }
            }
            
            // Update tween helper with pulsing animation
            if (entity.tweenHelper) {
                entity.tweenHelper.position.set(transform.x, transform.y + 1, transform.z);
                
                // Pulsing effect
                const pulse = Math.sin(now * 0.005) * 0.3 + 0.7;
                entity.tweenHelper.material.opacity = pulse;
                
                // Slow rotation
                entity.tweenHelper.rotation.z += 0.02;
            }
            
            // Update animator helper with rotation
            if (entity.animatorHelper) {
                entity.animatorHelper.position.set(transform.x, transform.y + 2.5, transform.z);
                
                // Continuous rotation on multiple axes
                entity.animatorHelper.rotation.x += 0.03;
                entity.animatorHelper.rotation.y += 0.02;
                entity.animatorHelper.rotation.z += 0.01;
            }
            
            // Update Phase 3 component helpers
            if (entity.partyHelper) {
                entity.partyHelper.position.set(transform.x, transform.y + 2, transform.z);
                
                // Gentle bobbing animation for crown
                const bob = Math.sin(now * 0.003) * 0.1;
                entity.partyHelper.position.y += bob;
                
                // Slow rotation
                entity.partyHelper.rotation.y += 0.01;
            }
            
            if (entity.healthBarHelper) {
                entity.healthBarHelper.position.set(transform.x, transform.y + 1.8, transform.z);
                entity.healthBarHelper.lookAt(camera.position);
                
                // Update health bar color based on current health
                const character = entity.getComponent('CharacterComponent');
                if (character) {
                    const healthPercent = character.currentHealth / character.maxHealth;
                    const healthColor = healthPercent > 0.5 ? 0x4caf50 : healthPercent > 0.2 ? 0xffeb3b : 0xf44336;
                    entity.healthBarHelper.material.color.setHex(healthColor);
                    
                    // Scale health bar based on health percentage
                    entity.healthBarHelper.scale.x = healthPercent;
                }
            }
            
            if (entity.levelHelper) {
                entity.levelHelper.position.set(transform.x + 0.7, transform.y + 1.8, transform.z);
                entity.levelHelper.lookAt(camera.position);
                
                // Gentle pulsing for level indicator
                const pulse = Math.sin(now * 0.004) * 0.1 + 0.9;
                entity.levelHelper.scale.setScalar(pulse);
            }
            
            if (entity.aiHelper) {
                entity.aiHelper.position.set(transform.x - 0.7, transform.y + 1.8, transform.z);
                
                // Behavior-specific animations
                const ai = entity.getComponent('AIComponent');
                if (ai) {
                    switch(ai.behaviorType) {
                        case 'follow':
                            // Gentle floating motion
                            entity.aiHelper.position.y += Math.sin(now * 0.005) * 0.1;
                            break;
                        case 'guard':
                            // Steady pulsing
                            const guardPulse = Math.sin(now * 0.003) * 0.2 + 0.8;
                            entity.aiHelper.material.opacity = guardPulse;
                            break;
                        case 'patrol':
                            // Rotating motion
                            entity.aiHelper.rotation.y += 0.02;
                            break;
                        case 'aggressive':
                            // Rapid pulsing
                            const aggroPulse = Math.sin(now * 0.01) * 0.3 + 0.7;
                            entity.aiHelper.material.opacity = aggroPulse;
                            break;
                    }
                }
            }
            
            if (entity.combatHelper) {
                entity.combatHelper.position.set(transform.x, transform.y + 0.1, transform.z);
                
                // Pulsing attack range
                const rangePulse = Math.sin(now * 0.002) * 0.1 + 0.9;
                entity.combatHelper.scale.setScalar(rangePulse);
                
                // Slow rotation
                entity.combatHelper.rotation.z += 0.005;
            }
            
            if (entity.inventoryHelper) {
                entity.inventoryHelper.position.set(transform.x + 0.7, transform.y + 1.2, transform.z);
                
                // Gentle swaying motion
                const sway = Math.sin(now * 0.003) * 0.05;
                entity.inventoryHelper.rotation.z = sway;
                
                // Subtle scaling based on inventory state
                const inventory = entity.getComponent('InventoryComponent');
                if (inventory) {
                    const fillPercent = inventory.currentWeight / inventory.maxWeight;
                    const scale = 0.8 + (fillPercent * 0.4); // Scale from 0.8 to 1.2
                    entity.inventoryHelper.scale.setScalar(scale);
                }
            }
            
            // Update Phase 4 component helpers
            if (entity.villageHelper) {
                entity.villageHelper.position.set(transform.x - 1.0, transform.y + 1.5, transform.z);
                entity.villageRoofHelper.position.set(transform.x - 1.0, transform.y + 1.8, transform.z);
                
                // Gentle house breathing animation
                const breathe = Math.sin(now * 0.002) * 0.05 + 1.0;
                entity.villageHelper.scale.setScalar(breathe);
                
                // Roof sways slightly
                entity.villageRoofHelper.rotation.z = Math.sin(now * 0.001) * 0.02;
            }
            
            if (entity.buildingHelper) {
                entity.buildingHelper.position.set(transform.x + 1.0, transform.y + 1.4, transform.z);
                
                // Update building opacity based on construction progress
                const building = entity.getComponent('BuildingComponent');
                if (building) {
                    const opacity = building.isConstructed ? 0.8 : 0.4 + (building.constructionProgress / 100) * 0.4;
                    entity.buildingHelper.material.opacity = opacity;
                    
                    // Building under construction flickers
                    if (!building.isConstructed && building.constructionStarted) {
                        const flicker = Math.sin(now * 0.01) * 0.1 + 0.9;
                        entity.buildingHelper.material.opacity *= flicker;
                    }
                }
            }
            
            if (entity.resourceHelper) {
                entity.resourceHelper.position.set(transform.x, transform.y + 2.2, transform.z + 1.0);
                
                // Resource stack height based on total resources
                const resource = entity.getComponent('ResourceComponent');
                if (resource) {
                    const totalResources = Object.values(resource.resources).reduce((sum, amount) => sum + amount, 0);
                    const stackHeight = Math.max(0.3, Math.min(1.5, totalResources / 200));
                    entity.resourceHelper.scale.y = stackHeight;
                }
                
                // Gentle rotation
                entity.resourceHelper.rotation.y += 0.005;
            }
            
            if (entity.workerHelper) {
                entity.workerHelper.position.set(transform.x - 0.5, transform.y + 1.5, transform.z - 0.5);
                
                // Tool animation based on work state
                const worker = entity.getComponent('WorkerComponent');
                if (worker && worker.isWorking) {
                    // Working animation - tool moves up and down
                    const workMotion = Math.sin(now * 0.008) * 0.2;
                    entity.workerHelper.position.y += workMotion;
                    entity.workerHelper.rotation.z = Math.PI / 4 + Math.sin(now * 0.008) * 0.3;
                } else {
                    // Idle animation - gentle sway
                    entity.workerHelper.rotation.z = Math.PI / 4 + Math.sin(now * 0.002) * 0.1;
                }
            }
            
            // Update ALL economy coin helpers
            if (entity.economyHelpers && entity.economyHelpers.length > 0) {
                const economy = entity.getComponent('EconomyComponent');
                const economicActivity = economy && Math.random() < 0.001;
                const glint = Math.sin(now * 0.003) * 0.3 + 0.9;
                
                entity.economyHelpers.forEach((coinHelper, index) => {
                    // Update position with stacked height
                    coinHelper.position.set(
                        transform.x + 0.5, 
                        transform.y + 1.0 + (index * 0.1), 
                        transform.z + 0.5
                    );
                    
                    // Coins glint animation (slight variation per coin)
                    const coinGlint = Math.sin(now * 0.003 + index * 0.5) * 0.3 + 0.9;
                    coinHelper.material.opacity = coinGlint;
                    
                    // Slight rotation (different speed per coin)
                    coinHelper.rotation.y += 0.01 + (index * 0.002);
                    
                    // Economic activity causes coins to bounce
                    if (economicActivity) {
                        const bounce = Math.sin(now * 0.02 + index * 0.3) * 0.1;
                        coinHelper.position.y += bounce;
                    }
                });
            }
            
            // Phase 5 visualization updates
            if (entity.questHelper) {
                entity.questHelper.position.set(transform.x - 1.0, transform.y + 1.5, transform.z);
                
                // Quest indicator animation - gentle bobbing
                const questBob = Math.sin(now * 0.003) * 0.1;
                entity.questHelper.position.y += questBob;
                
                // Rotate quest indicator
                entity.questHelper.rotation.y += 0.01;
                
                // Update color based on quest status
                const quest = entity.getComponent('QuestComponent');
                if (quest) {
                    let questColor;
                    switch(quest.status) {
                        case 'available': questColor = 0xffeb3b; break; // Yellow
                        case 'active': questColor = 0x2196f3; break;    // Blue
                        case 'completed': questColor = 0x4caf50; break; // Green
                        case 'failed': questColor = 0xf44336; break;    // Red
                        default: questColor = 0x9e9e9e;                // Gray
                    }
                    entity.questHelper.material.color.setHex(questColor);
                }
            }
            
            if (entity.dialogueHelper) {
                entity.dialogueHelper.position.set(transform.x + 1.5, transform.y + 1.8, transform.z);
                
                // Speech bubble animation - floating and pulsing
                const bubbleFloat = Math.sin(now * 0.004) * 0.15;
                entity.dialogueHelper.position.y += bubbleFloat;
                
                const bubblePulse = 0.8 + Math.sin(now * 0.006) * 0.2;
                entity.dialogueHelper.scale.setScalar(bubblePulse);
                
                // Dialogue activity indicator
                const dialogue = entity.getComponent('DialogueComponent');
                if (dialogue && dialogue.currentDialogue) {
                    entity.dialogueHelper.material.opacity = 0.9;
                } else {
                    entity.dialogueHelper.material.opacity = 0.7;
                }
            }
            
            if (entity.npcHelper) {
                entity.npcHelper.position.set(transform.x, transform.y + 2.0, transform.z + 1.0);
                
                // NPC indicator animation - rotation and activity-based movement
                entity.npcHelper.rotation.x += 0.02;
                entity.npcHelper.rotation.y += 0.015;
                
                const npc = entity.getComponent('NPCComponent');
                if (npc) {
                    // Activity-based animation
                    if (npc.currentActivity === 'work') {
                        const workMotion = Math.sin(now * 0.01) * 0.1;
                        entity.npcHelper.position.y += workMotion;
                    } else if (npc.currentActivity === 'socializing') {
                        const socialSway = Math.sin(now * 0.005) * 0.05;
                        entity.npcHelper.position.x += socialSway;
                    }
                    
                    // Mood-based opacity
                    const averageMood = Object.values(npc.needs).reduce((sum, need) => sum + need, 0) / Object.keys(npc.needs).length;
                    entity.npcHelper.material.opacity = 0.5 + (averageMood / 100) * 0.4;
                }
            }
            
            if (entity.eventHelper) {
                entity.eventHelper.position.set(transform.x - 1.5, transform.y + 2.2, transform.z);
                
                // Event indicator animation
                entity.eventHelper.rotation.x += 0.03;
                entity.eventHelper.rotation.y += 0.02;
                entity.eventHelper.rotation.z += 0.01;
                
                const event = entity.getComponent('EventComponent');
                if (event) {
                    if (event.status === 'active') {
                        // Active events pulse more intensely
                        const activePulse = 0.8 + Math.sin(now * 0.01) * 0.4;
                        entity.eventHelper.scale.setScalar(activePulse);
                        entity.eventHelper.material.opacity = 0.9;
                    } else {
                        // Inactive events gentle pulse
                        const gentlePulse = 0.9 + Math.sin(now * 0.003) * 0.1;
                        entity.eventHelper.scale.setScalar(gentlePulse);
                        entity.eventHelper.material.opacity = 0.6;
                    }
                }
            }
        }
        
        // Component toggle functionality
        function toggleComponent(entity, componentType, component) {
            const wasActive = component.active !== false;
            component.active = !wasActive;
            
            
            // If this is the selected entity, update its visualizations immediately
            if (entity === selectedEntity) {
                // Always refresh visualizations to sync with component active states
                removeColliderVisualization(entity);
                addColliderVisualization(entity);
                
                // Maintain entity selection
                selectedEntity = entity;
            }
            
            // Force immediate update after toggle to show the change
            setTimeout(() => {
                updateInspector();
                updateSelectionUI();
            }, 0);
        }
        
        // Physics and animation components are now integrated directly into ECS
        // Users can add physics/animation components via the inspector using the + button
        
        // Initialize Lucide icons when they're loaded
        window.addEventListener('load', () => {
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
                
                // Re-create icons whenever the inspector updates
                const originalUpdateInspector = updateInspector;
                updateInspector = function() {
                    originalUpdateInspector();
                    setTimeout(() => lucide.createIcons(), 0);
                };
            }
        });
    </script>
</body>
</html>