<!DOCTYPE html>
<html>
<head>
    <title>NeverEverLand v003 - ECS Demo</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="container">
        <div id="ui">
            <div id="ui-header">
                <h3>🎮 ECS Engine Demo</h3>
                <span style="font-size: 10px; color: #888;"><i data-lucide="move" style="width: 12px; height: 12px;"></i> Drag to move</span>
            </div>
            <p>Entity Component System in action</p>
            
            <div id="selectionInfo" style="margin: 5px 0; font-size: 11px; color: #888;">
Click an entity to select it. Click components to toggle on/off.
            </div>
            
            <div>
                <button onclick="queryEntities()">Query Test</button>
                <button onclick="stressTest()">Stress Test</button>
            </div>
            
            <div>
                <button class="danger" onclick="clearAll()">Clear All</button>
            </div>
            
            
            <div id="status">
                <div>Entities: <span id="entityCount">0</span></div>
                <div>Components: <span id="componentCount">0</span></div>
                <div>Systems: <span id="systemCount">4</span></div>
                <div>Queries: <span id="queryCount">0</span></div>
                <div>Performance: <span id="performance">--</span></div>
            </div>
            
            <div style="margin-top: 10px; font-size: 10px; color: #888;">
                <strong>ECS Architecture:</strong><br>
                • Entities are just IDs<br>
                • Components hold data<br>
                • Systems process components<br>
                • Queries find entities by components<br><br>
                <strong style="color: #4CAF50;">🚀 Physics & Animation Integrated!</strong><br>
                Use the + button in the inspector to add physics/animation components!
            </div>
        </div>
        
        <div id="inspector">
            <div id="inspector-header">
                <span><i data-lucide="search" style="width: 16px; height: 16px; vertical-align: text-bottom;"></i> Component Inspector</span>
                <span style="font-size: 10px; color: #888;"><i data-lucide="move" style="width: 12px; height: 12px;"></i> Drag to move • <i data-lucide="maximize-2" style="width: 12px; height: 12px;"></i> Resize corner</span>
            </div>
            <div id="inspector-content">
                <button onclick="createEntity()" style="width: 100%; margin-bottom: 10px; padding: 8px; background: #4CAF50; color: white; border: none; border-radius: 3px; cursor: pointer; font-family: monospace; display: flex; align-items: center; justify-content: center; gap: 5px;"><i data-lucide="plus" style="width: 16px; height: 16px;"></i> Create Entity</button>
                <div id="entityList"></div>
            </div>
        </div>
    </div>

    <script src="./three.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    
    <script>
        // Simple ECS Implementation
        class Entity {
            static nextId = 1;
            constructor() {
                this.id = Entity.nextId++;
                this.components = new Map();
                this.active = true;
            }
            
            addComponent(component) {
                this.components.set(component.constructor.name, component);
                return this;
            }
            
            removeComponent(componentType) {
                this.components.delete(componentType);
                return this;
            }
            
            getComponent(componentType) {
                return this.components.get(componentType);
            }
            
            hasComponent(componentType) {
                return this.components.has(componentType);
            }
        }
        
        // Components (data only)
        class Transform {
            constructor(x = 0, y = 0, z = 0) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.rotation = { x: 0, y: 0, z: 0 };
                this.scale = { x: 1, y: 1, z: 1 };
            }
        }
        
        class Renderable {
            constructor(mesh) {
                this.mesh = mesh;
                this.visible = true;
            }
        }
        
        class Movement {
            constructor() {
                this.velocity = { x: 0, y: 0, z: 0 };
                this.speed = Math.random() * 2 + 1;
            }
        }
        
        class Health {
            constructor() {
                this.current = 100;
                this.max = 100;
            }
        }
        
        class Lifetime {
            constructor(duration = 5) {
                this.remaining = duration;
            }
        }
        
        class VisualComponent {
            constructor() {
                this.wireframe = false;
                this.wireframeColor = 0x00ff00;
                this.vertexColors = false;
                this.pointsMode = false;
                this.pointSize = 3;
                this.pointColor = 0xff0000;
                this.opacity = 1.0;
                this.transparent = false;
                this.emissive = 0x000000;
                this.emissiveIntensity = 0.5;
                this.flatShading = false;
                this.doubleSided = false;
                this.visible = true;
            }
        }
        
        // Visual System to apply VisualComponent settings
        class VisualSystem {
            update(entities, deltaTime) {
                entities.forEach(entity => {
                    const visual = entity.getComponent('VisualComponent');
                    const renderable = entity.getComponent('Renderable');
                    
                    if (visual && visual.active !== false && renderable && renderable.mesh) {
                        const mesh = renderable.mesh;
                        
                        // Apply visual properties
                        mesh.material.wireframe = visual.wireframe;
                        mesh.material.transparent = visual.transparent;
                        mesh.material.opacity = visual.opacity;
                        mesh.material.emissive.setHex(visual.emissive);
                        mesh.material.side = visual.doubleSided ? THREE.DoubleSide : THREE.FrontSide;
                        mesh.visible = visual.visible;
                        
                        // Handle points mode (requires material change)
                        if (visual.pointsMode && !mesh.userData.isPointsMaterial) {
                            const pointsMaterial = new THREE.PointsMaterial({ 
                                color: visual.pointColor,
                                size: visual.pointSize
                            });
                            const points = new THREE.Points(mesh.geometry, pointsMaterial);
                            points.position.copy(mesh.position);
                            points.rotation.copy(mesh.rotation);
                            points.scale.copy(mesh.scale);
                            
                            // Replace mesh with points temporarily
                            mesh.parent.add(points);
                            mesh.visible = false;
                            mesh.userData.pointsHelper = points;
                            mesh.userData.isPointsMaterial = true;
                        } else if (!visual.pointsMode && mesh.userData.pointsHelper) {
                            // Remove points and show original mesh
                            mesh.parent.remove(mesh.userData.pointsHelper);
                            mesh.userData.pointsHelper.geometry.dispose();
                            mesh.userData.pointsHelper.material.dispose();
                            delete mesh.userData.pointsHelper;
                            delete mesh.userData.isPointsMaterial;
                            mesh.visible = visual.visible;
                        }
                        
                        // Mark material as needing update
                        mesh.material.needsUpdate = true;
                    }
                });
            }
        }
        
        // Systems (logic only)
        class MovementSystem {
            update(entities, deltaTime) {
                entities.forEach(entity => {
                    const transform = entity.getComponent('Transform');
                    const movement = entity.getComponent('Movement');
                    
                    // Only update if both components exist and movement is active
                    if (transform && movement && movement.active !== false) {
                        // Update position based on velocity
                        transform.x += movement.velocity.x * deltaTime;
                        transform.y += movement.velocity.y * deltaTime;
                        transform.z += movement.velocity.z * deltaTime;
                        
                        // Bounce off boundaries
                        if (Math.abs(transform.x) > 10) movement.velocity.x *= -1;
                        if (Math.abs(transform.z) > 10) movement.velocity.z *= -1;
                        if (transform.y < 0.5) movement.velocity.y = Math.abs(movement.velocity.y);
                        if (transform.y > 5) movement.velocity.y = -Math.abs(movement.velocity.y);
                        
                        // Update 3D mesh position
                        const renderable = entity.getComponent('Renderable');
                        if (renderable && renderable.mesh) {
                            renderable.mesh.position.set(transform.x, transform.y, transform.z);
                        }
                    }
                });
            }
        }
        
        class RenderSystem {
            update(entities) {
                entities.forEach(entity => {
                    const transform = entity.getComponent('Transform');
                    const renderable = entity.getComponent('Renderable');
                    
                    if (transform && renderable && renderable.mesh) {
                        // Update mesh transform
                        renderable.mesh.position.set(transform.x, transform.y, transform.z);
                        renderable.mesh.rotation.set(transform.rotation.x, transform.rotation.y, transform.rotation.z);
                        renderable.mesh.scale.set(transform.scale.x, transform.scale.y, transform.scale.z);
                        renderable.mesh.visible = renderable.visible;
                        
                        // Update wireframe edges if they exist (for selected entity)
                        if (renderable.wireframeHelper) {
                            renderable.wireframeHelper.position.copy(renderable.mesh.position);
                            renderable.wireframeHelper.rotation.copy(renderable.mesh.rotation);
                            renderable.wireframeHelper.scale.copy(renderable.mesh.scale);
                        }
                    }
                });
            }
        }
        
        class LifetimeSystem {
            update(entities, deltaTime) {
                const toDestroy = [];
                entities.forEach(entity => {
                    const lifetime = entity.getComponent('Lifetime');
                    if (lifetime && lifetime.active !== false) {
                        lifetime.remaining -= deltaTime;
                        if (lifetime.remaining <= 0) {
                            toDestroy.push(entity);
                        }
                    }
                });
                
                toDestroy.forEach(entity => {
                    // Clear selection if this entity is currently selected
                    if (selectedEntity && selectedEntity.id === entity.id) {
                        selectEntity(null);
                    }
                    world.destroyEntity(entity);
                });
            }
        }
        
        class HealthSystem {
            update(entities, deltaTime) {
                entities.forEach(entity => {
                    const health = entity.getComponent('Health');
                    const renderable = entity.getComponent('Renderable');
                    
                    if (health && health.active !== false && renderable && renderable.mesh) {
                        // Color based on health
                        const healthPercent = health.current / health.max;
                        if (healthPercent > 0.5) {
                            renderable.mesh.material.color.setHex(0x4CAF50); // Green
                        } else if (healthPercent > 0.2) {
                            renderable.mesh.material.color.setHex(0xFFEB3B); // Yellow
                        } else {
                            renderable.mesh.material.color.setHex(0xF44336); // Red
                        }
                        
                        // Slowly lose health
                        health.current = Math.max(0, health.current - deltaTime * 5);
                    }
                });
            }
        }
        
        // World (ECS coordinator)
        class World {
            constructor() {
                this.entities = [];
                this.systems = [
                    new MovementSystem(),
                    new VisualSystem(),
                    new RenderSystem(),
                    new LifetimeSystem(),
                    new HealthSystem()
                ];
                this.queryCache = new Map();
            }
            
            createEntity() {
                const entity = new Entity();
                this.entities.push(entity);
                this.clearQueryCache();
                return entity;
            }
            
            destroyEntity(entity) {
                // Remove from scene if it has a mesh
                const renderable = entity.getComponent('Renderable');
                if (renderable && renderable.mesh) {
                    scene.remove(renderable.mesh);
                    
                    // Clean up wireframe edges if they exist
                    if (renderable.wireframeHelper) {
                        scene.remove(renderable.wireframeHelper);
                        renderable.wireframeHelper.geometry.dispose();
                        renderable.wireframeHelper.material.dispose();
                        renderable.wireframeHelper = null;
                    }
                }
                
                const index = this.entities.indexOf(entity);
                if (index > -1) {
                    this.entities.splice(index, 1);
                }
                this.clearQueryCache();
            }
            
            query(componentTypes) {
                const key = componentTypes.sort().join(',');
                if (this.queryCache.has(key)) {
                    return this.queryCache.get(key);
                }
                
                const result = this.entities.filter(entity => 
                    componentTypes.every(type => entity.hasComponent(type))
                );
                
                this.queryCache.set(key, result);
                return result;
            }
            
            clearQueryCache() {
                this.queryCache.clear();
            }
            
            update(deltaTime) {
                this.systems.forEach(system => {
                    system.update(this.entities, deltaTime);
                });
            }
            
            getStats() {
                let componentCount = 0;
                this.entities.forEach(entity => {
                    componentCount += entity.components.size;
                });
                
                return {
                    entities: this.entities.length,
                    components: componentCount,
                    systems: this.systems.length,
                    queries: this.queryCache.size
                };
            }
        }
        
        // Global state
        let scene, camera, renderer, world;
        let lastTime = Date.now();
        let queryTestCount = 0;
        let selectedEntity = null;
        let raycaster, mouse;
        
        // Phase 2 demo variables
        let currentPhase2Demo = null;
        let currentGameEngine = null;
        let phase2ComponentsLoaded = false;
        let lastInspectorUpdate = 0;
        
        // Inspector dragging state
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        
        
        
        function init() {
            // Initialize Three.js
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2c3e50);
            
            // Create dimetric camera (orthographic projection with 2:1 tile ratio)
            const frustumSize = 20;
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.OrthographicCamera(
                frustumSize * aspect / -2, frustumSize * aspect / 2,
                frustumSize / 2, frustumSize / -2,
                0.1, 1000
            );
            
            // Position for dimetric view (26.57° elevation, 45° azimuth for 2:1 tile ratio)
            const elevation = 26.57 * Math.PI / 180; // 26.57 degrees
            const azimuth = 45 * Math.PI / 180; // 45 degrees
            const distance = 20;
            
            camera.position.set(
                Math.cos(elevation) * Math.sin(azimuth) * distance,
                Math.sin(elevation) * distance,
                Math.cos(elevation) * Math.cos(azimuth) * distance
            );
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Create ground
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(25, 25),
                new THREE.MeshLambertMaterial({ color: 0x34495e })
            );
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Initialize raycaster for mouse picking
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Add mouse event listeners
            renderer.domElement.addEventListener('click', onMouseClick);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            
            // Initialize inspector dragging
            initInspectorDragging();
            
            // Initialize inspector resize observer
            initInspectorResize();
            
            // Initialize UI dragging
            initUIDragging();
            
            // Initialize ECS
            world = new World();
            
            // Load saved panel positions
            loadPanelPositions();
            
            // Load Phase 2 components (physics & animation) at startup
            loadPhase2Components(() => {
                console.log('✅ Phase 2 components are now available in the ECS inspector');
                
                // Create initial entities AFTER components are loaded
                console.log('🎯 Creating initial entities with all components...');
                for (let i = 0; i < 5; i++) {
                    createEntity();
                }
                
                console.log('ECS Demo initialized with', world.entities.length, 'entities with all components');
            });
            
            // Start game loop immediately
            animate();
            updateStatus();
        }
        
        function createEntity() {
            const entity = world.createEntity();
            
            // Add Transform component
            const transform = new Transform(
                (Math.random() - 0.5) * 10,
                Math.random() * 3 + 1,
                (Math.random() - 0.5) * 10
            );
            entity.addComponent(transform);
            
            // Add Renderable component
            const geometry = Math.random() > 0.5 ? 
                new THREE.BoxGeometry(1, 1, 1) : 
                new THREE.SphereGeometry(0.5, 12, 8);
            const material = new THREE.MeshLambertMaterial({ 
                color: Math.random() * 0xffffff 
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            entity.addComponent(new Renderable(mesh));
            
            // Store entity reference on mesh for picking
            mesh.userData.entity = entity;
            
            scene.add(mesh);
            
            // Add all available components by default
            
            // Add Movement component
            const movement = new Movement();
            movement.velocity = {
                x: (Math.random() - 0.5) * 4,
                y: (Math.random() - 0.5) * 2,
                z: (Math.random() - 0.5) * 4
            };
            entity.addComponent(movement);
            
            // Add Health component
            entity.addComponent(new Health());
            
            // Add Lifetime component
            entity.addComponent(new Lifetime(Math.random() * 10 + 5));
            
            // Add VisualComponent for styling control
            entity.addComponent(new VisualComponent());
            
            // Add physics components if available
            if (phase2ComponentsLoaded) {
                // Add RigidbodyComponent
                const rigidbody = new window.RigidbodyComponent();
                rigidbody.mass = 1;
                rigidbody.useGravity = true;
                rigidbody.velocity = new THREE.Vector3((Math.random() - 0.5) * 2, 0, (Math.random() - 0.5) * 2);
                entity.addComponent(rigidbody);
                
                // Add appropriate collider based on geometry
                if (geometry instanceof THREE.SphereGeometry) {
                    const collider = new window.SphereColliderComponent();
                    collider.setRadius(0.5);
                    entity.addComponent(collider);
                } else {
                    const collider = new window.BoxColliderComponent();
                    collider.setSize(1, 1, 1);
                    entity.addComponent(collider);
                }
                
                // Add TweenComponent 
                const tween = new window.TweenComponent();
                entity.addComponent(tween);
                
                // Add AnimatorComponent
                const animator = new window.AnimatorComponent();
                entity.addComponent(animator);
                
                console.log('✅ Created entity with all components including physics!');
            } else {
                console.log('✅ Created entity with basic components (physics components loading...)');
            }
            
            updateStatus();
            return entity;
        }
        
        function addComponentToEntity(entity) {
            const componentTypes = ['Movement', 'Health', 'Lifetime', 'RigidbodyComponent', 'BoxColliderComponent', 'SphereColliderComponent', 'TweenComponent', 'AnimatorComponent'];
            const availableTypes = componentTypes.filter(type => !entity.hasComponent(type));
            
            if (availableTypes.length === 0) {
                console.log(`⚠️ Entity ${entity.id} already has all possible components`);
                return;
            }
            
            const randomType = availableTypes[Math.floor(Math.random() * availableTypes.length)];
            
            let component;
            switch(randomType) {
                case 'Movement':
                    component = new Movement();
                    component.velocity = {
                        x: (Math.random() - 0.5) * 4,
                        y: (Math.random() - 0.5) * 2,
                        z: (Math.random() - 0.5) * 4
                    };
                    break;
                case 'Health':
                    component = new Health();
                    break;
                case 'Lifetime':
                    component = new Lifetime(Math.random() * 10 + 5);
                    break;
                case 'RigidbodyComponent':
                    component = new window.RigidbodyComponent();
                    component.mass = 1;
                    component.useGravity = true;
                    component.velocity = new THREE.Vector3(0, 0, 0);
                    console.log('🔬 Added physics rigidbody component');
                    break;
                case 'BoxColliderComponent':
                    component = new window.BoxColliderComponent();
                    component.setSize(2, 2, 2);
                    console.log('📦 Added box collider component');
                    break;
                case 'SphereColliderComponent':
                    component = new window.SphereColliderComponent();
                    component.setRadius(1);
                    console.log('⚪ Added sphere collider component');
                    break;
                case 'TweenComponent':
                    component = new window.TweenComponent();
                    console.log('🎬 Added tween animation component');
                    break;
                case 'AnimatorComponent':
                    component = new window.AnimatorComponent();
                    console.log('🎭 Added animator component');
                    break;
                case 'VisualComponent':
                    component = new VisualComponent();
                    console.log('🎨 Added visual styling component');
                    break;
            }
            
            entity.addComponent(component);
            console.log(`✅ Added ${randomType} to entity ${entity.id}`);
            updateStatus();
        }
        
        function removeComponentFromEntity(entity) {
            const componentTypes = Array.from(entity.components.keys());
            const removableTypes = componentTypes.filter(type => 
                type !== 'Transform' && type !== 'Renderable'
            );
            
            if (removableTypes.length === 0) {
                console.log(`⚠️ Entity ${entity.id} has no removable components`);
                return;
            }
            
            const typeToRemove = removableTypes[Math.floor(Math.random() * removableTypes.length)];
            entity.removeComponent(typeToRemove);
            console.log(`🗑️ Removed ${typeToRemove} from entity ${entity.id}`);
            updateStatus();
        }
        
        function destroyEntity(entity) {
            // Clear selection if this entity is currently selected
            if (selectedEntity && selectedEntity.id === entity.id) {
                selectEntity(null); // This will clear wireframes and selection properly
            }
            
            world.destroyEntity(entity);
            console.log(`💥 Destroyed entity ${entity.id}`);
            updateStatus();
        }
        
        
        function queryEntities() {
            const queries = [
                ['Transform'],
                ['Transform', 'Movement'],
                ['Transform', 'Health'],
                ['Movement', 'Health'],
                ['Transform', 'Renderable', 'Movement']
            ];
            
            queries.forEach(componentTypes => {
                const result = world.query(componentTypes);
                console.log(`Query [${componentTypes.join(', ')}]: ${result.length} entities`);
            });
            
            queryTestCount++;
            updateStatus();
        }
        
        function stressTest() {
            console.log('Running stress test...');
            const start = performance.now();
            
            // Create 100 entities
            for (let i = 0; i < 100; i++) {
                createEntity();
            }
            
            // Run systems 10 times
            for (let i = 0; i < 10; i++) {
                world.update(0.016);
            }
            
            // Perform queries
            for (let i = 0; i < 50; i++) {
                world.query(['Transform', 'Movement']);
            }
            
            const end = performance.now();
            console.log(`Stress test completed in ${(end - start).toFixed(2)}ms`);
            document.getElementById('performance').textContent = `Stress: ${(end - start).toFixed(2)}ms`;
            updateStatus();
        }
        
        function destroyRandomEntity() {
            if (world.entities.length > 0) {
                const entity = world.entities[Math.floor(Math.random() * world.entities.length)];
                world.destroyEntity(entity);
                console.log(`Destroyed entity ${entity.id}`);
                updateStatus();
            }
        }
        
        function clearAll() {
            while (world.entities.length > 0) {
                world.destroyEntity(world.entities[0]);
            }
            console.log('Cleared all entities');
            updateStatus();
        }
        
        function updateStatus() {
            const stats = world.getStats();
            document.getElementById('entityCount').textContent = stats.entities;
            document.getElementById('componentCount').textContent = stats.components;
            document.getElementById('systemCount').textContent = stats.systems;
            document.getElementById('queryCount').textContent = queryTestCount;
            updateInspector();
        }
        
        
        function onMouseMove(event) {
            // Update mouse position for hover effects
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Update raycaster
            raycaster.setFromCamera(mouse, camera);
            
            // Find intersected objects
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            // Reset all mesh colors first
            world.entities.forEach(entity => {
                const renderable = entity.getComponent('Renderable');
                if (renderable && renderable.mesh && renderable.mesh.userData.entity) {
                    if (selectedEntity && selectedEntity.id === entity.id) {
                        // Keep selected entity highlighted
                        renderable.mesh.material.emissive.setHex(0x004400);
                    } else {
                        // Normal color
                        renderable.mesh.material.emissive.setHex(0x000000);
                    }
                }
            });
            
            // Highlight hovered object
            if (intersects.length > 0) {
                const mesh = intersects[0].object;
                if (mesh.userData.entity && (!selectedEntity || selectedEntity.id !== mesh.userData.entity.id)) {
                    mesh.material.emissive.setHex(0x222222);
                }
                renderer.domElement.style.cursor = 'pointer';
            } else {
                renderer.domElement.style.cursor = 'default';
            }
        }
        
        function onMouseClick(event) {
            // Update mouse position
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Update raycaster
            raycaster.setFromCamera(mouse, camera);
            
            // Find intersected objects
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            if (intersects.length > 0) {
                const mesh = intersects[0].object;
                if (mesh.userData.entity) {
                    console.log(`🎯 Viewport click - selecting entity ${mesh.userData.entity.id}`);
                    selectEntity(mesh.userData.entity);
                }
            } else {
                // Clicked on empty space, deselect
                console.log('🎯 Viewport click - deselecting');
                selectEntity(null);
            }
        }
        
        function selectEntity(entity) {
            console.log(`🔄 selectEntity called with: ${entity ? `entity ${entity.id}` : 'null'}`);
            
            // Clear previous selection highlight and edges
            if (selectedEntity) {
                const prevRenderable = selectedEntity.getComponent('Renderable');
                if (prevRenderable && prevRenderable.mesh) {
                    prevRenderable.mesh.material.emissive.setHex(0x000000);
                    
                    // Remove wireframe edges if they exist
                    if (prevRenderable.wireframeHelper) {
                        scene.remove(prevRenderable.wireframeHelper);
                        prevRenderable.wireframeHelper.geometry.dispose();
                        prevRenderable.wireframeHelper.material.dispose();
                        prevRenderable.wireframeHelper = null;
                    }
                }
                
                // Remove collider visualization from previous selection
                removeColliderVisualization(selectedEntity);
            }
            
            selectedEntity = entity;
            
            // Highlight new selection with glow and edges
            if (selectedEntity) {
                const renderable = selectedEntity.getComponent('Renderable');
                if (renderable && renderable.mesh) {
                    // Add emissive glow
                    renderable.mesh.material.emissive.setHex(0x004400);
                    
                    // Add wireframe edges
                    const edgesGeometry = new THREE.EdgesGeometry(renderable.mesh.geometry);
                    const edgesMaterial = new THREE.LineBasicMaterial({ 
                        color: 0x00ff00, 
                        linewidth: 2,
                        transparent: true,
                        opacity: 0.8
                    });
                    const wireframeHelper = new THREE.LineSegments(edgesGeometry, edgesMaterial);
                    
                    // Match the mesh's transform
                    wireframeHelper.position.copy(renderable.mesh.position);
                    wireframeHelper.rotation.copy(renderable.mesh.rotation);
                    wireframeHelper.scale.copy(renderable.mesh.scale);
                    
                    // Store reference and add to scene
                    renderable.wireframeHelper = wireframeHelper;
                    scene.add(wireframeHelper);
                }
                
                // Add collider visualization
                addColliderVisualization(selectedEntity);
            }
            
            updateSelectionUI();
            updateInspector(); // This will update the CI to show the selected state
        }
        
        function updateSelectionUI() {
            const selectionInfo = document.getElementById('selectionInfo');
            
            if (selectionInfo) {
                if (selectedEntity) {
                    const componentTypes = Array.from(selectedEntity.components.keys());
                    const activeCount = componentTypes.filter(type => {
                        const component = selectedEntity.getComponent(type);
                        return component.active !== false;
                    }).length;
                    
                    selectionInfo.innerHTML = `
                        <strong>Selected:</strong> Entity ${selectedEntity.id}<br>
                        <span style="font-size: 10px;">
                            ${componentTypes.length} components, ${activeCount} active
                        </span>
                    `;
                    selectionInfo.style.color = '#4CAF50';
                } else {
                    selectionInfo.textContent = 'Click an entity to select it. Click components to toggle on/off.';
                    selectionInfo.style.color = '#888';
                }
            }
        }
        
        function initInspectorDragging() {
            const inspector = document.getElementById('inspector');
            const header = document.getElementById('inspector-header');
            
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                inspector.classList.add('dragging');
                
                const rect = inspector.getBoundingClientRect();
                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;
                
                document.addEventListener('mousemove', onDrag);
                document.addEventListener('mouseup', onDragEnd);
                
                e.preventDefault();
            });
            
            function onDrag(e) {
                if (!isDragging) return;
                
                const newX = e.clientX - dragOffset.x;
                const newY = e.clientY - dragOffset.y;
                
                // Keep inspector within viewport bounds
                const maxX = window.innerWidth - inspector.offsetWidth;
                const maxY = window.innerHeight - inspector.offsetHeight;
                
                const clampedX = Math.max(0, Math.min(newX, maxX));
                const clampedY = Math.max(0, Math.min(newY, maxY));
                
                inspector.style.left = clampedX + 'px';
                inspector.style.top = clampedY + 'px';
                inspector.style.right = 'auto'; // Remove right positioning
                
                e.preventDefault();
            }
            
            function onDragEnd() {
                isDragging = false;
                inspector.classList.remove('dragging');
                document.removeEventListener('mousemove', onDrag);
                document.removeEventListener('mouseup', onDragEnd);
                
                // Save inspector position
                saveInspectorPosition();
            }
        }
        
        function initInspectorResize() {
            const inspector = document.getElementById('inspector');
            let resizeTimeout;
            
            // Use ResizeObserver to detect when inspector is resized
            if (window.ResizeObserver) {
                const resizeObserver = new ResizeObserver(entries => {
                    // Debounce the save operation
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        saveInspectorScale();
                    }, 100);
                });
                
                resizeObserver.observe(inspector);
            } else {
                // Fallback for older browsers - use window resize event
                let lastWidth = inspector.offsetWidth;
                let lastHeight = inspector.offsetHeight;
                
                window.addEventListener('resize', () => {
                    const currentWidth = inspector.offsetWidth;
                    const currentHeight = inspector.offsetHeight;
                    
                    if (currentWidth !== lastWidth || currentHeight !== lastHeight) {
                        clearTimeout(resizeTimeout);
                        resizeTimeout = setTimeout(() => {
                            saveInspectorScale();
                        }, 100);
                        
                        lastWidth = currentWidth;
                        lastHeight = currentHeight;
                    }
                });
            }
        }
        
        function initUIDragging() {
            const ui = document.getElementById('ui');
            const header = document.getElementById('ui-header');
            let isDraggingUI = false;
            let uiDragOffset = { x: 0, y: 0 };
            
            header.addEventListener('mousedown', (e) => {
                isDraggingUI = true;
                ui.classList.add('dragging');
                
                const rect = ui.getBoundingClientRect();
                uiDragOffset.x = e.clientX - rect.left;
                uiDragOffset.y = e.clientY - rect.top;
                
                document.addEventListener('mousemove', onUIDrag);
                document.addEventListener('mouseup', onUIDragEnd);
                
                e.preventDefault();
            });
            
            function onUIDrag(e) {
                if (!isDraggingUI) return;
                
                const newX = e.clientX - uiDragOffset.x;
                const newY = e.clientY - uiDragOffset.y;
                
                // Keep UI within viewport bounds
                const maxX = window.innerWidth - ui.offsetWidth;
                const maxY = window.innerHeight - ui.offsetHeight;
                
                const clampedX = Math.max(0, Math.min(newX, maxX));
                const clampedY = Math.max(0, Math.min(newY, maxY));
                
                ui.style.left = clampedX + 'px';
                ui.style.top = clampedY + 'px';
                
                e.preventDefault();
            }
            
            function onUIDragEnd() {
                isDraggingUI = false;
                ui.classList.remove('dragging');
                document.removeEventListener('mousemove', onUIDrag);
                document.removeEventListener('mouseup', onUIDragEnd);
                
                // Save UI position
                saveUIPosition();
            }
        }
        
        function saveUIPosition() {
            const ui = document.getElementById('ui');
            const position = {
                left: ui.style.left || '10px',
                top: ui.style.top || '10px'
            };
            localStorage.setItem('ecsUI_position', JSON.stringify(position));
        }
        
        function saveInspectorPosition() {
            const inspector = document.getElementById('inspector');
            const position = {
                left: inspector.style.left || 'auto',
                top: inspector.style.top || '10px',
                right: inspector.style.right || '10px',
                width: inspector.style.width || '320px',
                height: inspector.style.height || '400px'
            };
            localStorage.setItem('ecsInspector_position', JSON.stringify(position));
        }
        
        function saveInspectorScale() {
            const inspector = document.getElementById('inspector');
            const scale = {
                width: inspector.offsetWidth + 'px',
                height: inspector.offsetHeight + 'px'
            };
            localStorage.setItem('ecsInspector_scale', JSON.stringify(scale));
        }
        
        function loadPanelPositions() {
            // Load UI position
            const uiPosition = localStorage.getItem('ecsUI_position');
            if (uiPosition) {
                try {
                    const pos = JSON.parse(uiPosition);
                    const ui = document.getElementById('ui');
                    ui.style.left = pos.left;
                    ui.style.top = pos.top;
                } catch (e) {
                    console.log('Failed to load UI position:', e);
                }
            }
            
            // Load Inspector position
            const inspectorPosition = localStorage.getItem('ecsInspector_position');
            if (inspectorPosition) {
                try {
                    const pos = JSON.parse(inspectorPosition);
                    const inspector = document.getElementById('inspector');
                    
                    // Apply position
                    if (pos.left !== 'auto') {
                        inspector.style.left = pos.left;
                        inspector.style.right = 'auto';
                    } else {
                        inspector.style.right = pos.right;
                    }
                    inspector.style.top = pos.top;
                    inspector.style.width = pos.width;
                    inspector.style.height = pos.height;
                } catch (e) {
                    console.log('Failed to load Inspector position:', e);
                }
            }
            
            // Load Inspector scale
            const inspectorScale = localStorage.getItem('ecsInspector_scale');
            if (inspectorScale) {
                try {
                    const scale = JSON.parse(inspectorScale);
                    const inspector = document.getElementById('inspector');
                    inspector.style.width = scale.width;
                    inspector.style.height = scale.height;
                } catch (e) {
                    console.log('Failed to load Inspector scale:', e);
                }
            }
        }
        
        function updateInspector() {
            // Validate that selected entity still exists
            if (selectedEntity && !world.entities.find(e => e.id === selectedEntity.id)) {
                selectedEntity = null; // Clear selection if entity no longer exists
            }
            
            const entityList = document.getElementById('entityList');
            entityList.innerHTML = '';
            
            console.log(`🔄 Updating inspector, selected entity: ${selectedEntity ? selectedEntity.id : 'none'}`);
            
            // Show ALL entities, not just first 10
            world.entities.forEach(entity => {
                const card = document.createElement('div');
                card.className = 'entity-card';
                
                // Check if this entity is selected and apply style directly
                const isSelected = selectedEntity && selectedEntity.id === entity.id;
                if (isSelected) {
                    card.style.setProperty('background', 'rgba(76,175,80,0.5)', 'important');
                    card.style.setProperty('border', '2px solid #4CAF50', 'important');
                    card.style.setProperty('box-shadow', '0 0 8px rgba(76,175,80,0.6)', 'important');
                    card.style.setProperty('opacity', '1', 'important');
                    card.classList.add('selected');
                } else {
                    card.style.setProperty('background', 'rgba(255,255,255,0.1)', 'important');
                    card.style.setProperty('border', 'none', 'important');
                    card.style.setProperty('box-shadow', 'none', 'important');
                    card.style.setProperty('opacity', '0.6', 'important');
                    card.classList.remove('selected');
                }
                
                // Create header with entity name and buttons
                const header = document.createElement('div');
                header.className = 'entity-header';
                
                const entityName = document.createElement('strong');
                entityName.innerHTML = `<i data-lucide="box" style="width: 18px; height: 18px; vertical-align: text-bottom; margin-right: 6px;"></i>Entity ${entity.id}`;
                entityName.style.cursor = 'pointer';
                entityName.style.zIndex = '10';
                entityName.style.position = 'relative';
                
                // Add direct click handler to entity name
                entityName.addEventListener('click', (e) => {
                    console.log(`🖱️ Entity name clicked for entity ${entity.id}`);
                    selectEntity(entity);
                    e.stopPropagation();
                });
                
                const buttonContainer = document.createElement('div');
                buttonContainer.className = 'entity-buttons';
                
                // Add Component button
                const addBtn = document.createElement('button');
                addBtn.className = 'entity-btn';
                addBtn.innerHTML = '<i data-lucide="plus" style="width: 14px; height: 14px;"></i>';
                addBtn.title = 'Add Component';
                
                const componentTypes = ['Movement', 'Health', 'Lifetime', 'RigidbodyComponent', 'BoxColliderComponent', 'SphereColliderComponent', 'TweenComponent', 'AnimatorComponent', 'VisualComponent'];
                const availableTypes = componentTypes.filter(type => !entity.hasComponent(type));
                addBtn.disabled = availableTypes.length === 0;
                
                addBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    addComponentToEntity(entity);
                });
                
                // Remove Component button
                const removeBtn = document.createElement('button');
                removeBtn.className = 'entity-btn remove';
                removeBtn.innerHTML = '<i data-lucide="minus" style="width: 14px; height: 14px;"></i>';
                removeBtn.title = 'Remove Component';
                
                const componentKeys = Array.from(entity.components.keys());
                const removableTypes = componentKeys.filter(type => 
                    type !== 'Transform' && type !== 'Renderable'
                );
                removeBtn.disabled = removableTypes.length === 0;
                
                removeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    removeComponentFromEntity(entity);
                });
                
                // Destroy Entity button
                const destroyBtn = document.createElement('button');
                destroyBtn.className = 'entity-btn destroy';
                destroyBtn.innerHTML = '<i data-lucide="trash-2" style="width: 14px; height: 14px;"></i>';
                destroyBtn.title = 'Destroy Entity';
                
                destroyBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    destroyEntity(entity);
                });
                
                buttonContainer.appendChild(addBtn);
                buttonContainer.appendChild(removeBtn);
                buttonContainer.appendChild(destroyBtn);
                header.appendChild(entityName);
                header.appendChild(buttonContainer);
                
                // Add click handler to header background (not buttons)
                header.addEventListener('click', (e) => {
                    // Only trigger if clicking on header background, not buttons or entity name
                    if (e.target === header) {
                        console.log(`🖱️ Header background clicked for entity ${entity.id}`);
                        selectEntity(entity);
                    }
                });
                
                card.appendChild(header);
                
                // Add components display
                const componentsDiv = document.createElement('div');
                Array.from(entity.components.keys()).forEach(componentType => {
                    const component = entity.components.get(componentType);
                    const cssClass = componentType.toLowerCase();
                    
                    let details = '';
                    if (componentType === 'Transform') {
                        details = `(${component.x.toFixed(1)}, ${component.y.toFixed(1)}, ${component.z.toFixed(1)})`;
                    } else if (componentType === 'Movement') {
                        const speed = Math.sqrt(
                            component.velocity.x ** 2 + 
                            component.velocity.y ** 2 + 
                            component.velocity.z ** 2
                        ).toFixed(1);
                        details = `(speed: ${speed})`;
                    } else if (componentType === 'Health') {
                        details = `(${Math.round(component.current)}/${component.max})`;
                    } else if (componentType === 'Lifetime') {
                        details = `(${component.remaining.toFixed(1)}s)`;
                    } else if (componentType === 'RigidbodyComponent') {
                        const kinematic = component.isKinematic ? 'kinematic' : 'dynamic';
                        const mass = component.mass.toFixed(1);
                        if (!component.isKinematic && component.velocity) {
                            const speed = Math.sqrt(
                                component.velocity.x ** 2 + 
                                component.velocity.y ** 2 + 
                                component.velocity.z ** 2
                            ).toFixed(1);
                            details = `(${kinematic}, v: ${speed})`;
                        } else {
                            details = `(${kinematic}, mass: ${mass})`;
                        }
                    } else if (componentType === 'BoxColliderComponent') {
                        const size = component.size;
                        details = `(${size.x}×${size.y}×${size.z})`;
                    } else if (componentType === 'SphereColliderComponent') {
                        details = `(radius: ${component.radius.toFixed(1)})`;
                    } else if (componentType === 'TweenComponent') {
                        const status = component.isPlaying ? 'playing' : 'stopped';
                        details = `(${status})`;
                    } else if (componentType === 'AnimatorComponent') {
                        const state = component.currentState || 'idle';
                        details = `(${state})`;
                    } else if (componentType === 'VisualComponent') {
                        const modes = [];
                        if (component.wireframe) modes.push('wire');
                        if (component.pointsMode) modes.push('points');
                        if (component.transparent) modes.push('transp');
                        if (!component.visible) modes.push('hidden');
                        details = modes.length > 0 ? `(${modes.join(', ')})` : '(default)';
                    }
                    
                    const componentSpan = document.createElement('span');
                    const isActive = component.active !== false; // Default to true if not set
                    componentSpan.className = `component ${cssClass} ${isActive ? 'active' : 'inactive'}`;
                    componentSpan.textContent = `${componentType} ${details}`;
                    componentSpan.style.cursor = 'pointer';
                    componentSpan.title = `Click to ${isActive ? 'disable' : 'enable'} component`;
                    
                    // Add click handler to toggle component
                    componentSpan.addEventListener('click', (e) => {
                        console.log(`🖠️ Component ${componentType} clicked for entity ${entity.id}`);
                        e.stopPropagation();
                        e.preventDefault();
                        toggleComponent(entity, componentType, component);
                    });
                    
                    componentsDiv.appendChild(componentSpan);
                });
                
                card.appendChild(componentsDiv);
                entityList.appendChild(card);
            });
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const now = Date.now();
            const deltaTime = (now - lastTime) / 1000;
            lastTime = now;
            
            // Update ECS world
            world.update(deltaTime);
            
            // Update physics system if available
            if (world.physicsSystem) {
                world.physicsSystem.update(deltaTime);
            }
            
            // Update Phase 2 demo if active
            if (currentPhase2Demo && currentPhase2Demo.update) {
                currentPhase2Demo.update(deltaTime);
            }
            
            // Update UI less frequently to avoid flickering (every 1000ms)
            if (world.entities.length > 0 && (now - lastInspectorUpdate) > 1000) {
                updateInspector();
                updateStatus();
                lastInspectorUpdate = now;
            }
            
            // Update collider visualization for selected entity
            if (selectedEntity) {
                updateColliderVisualization(selectedEntity);
            }
            
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            const frustumSize = 20;
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Initialize
        if (typeof THREE !== 'undefined') {
            init();
        } else {
            window.addEventListener('load', init);
        }
        
        // Load Phase 2 components at initialization
        
        function loadPhase2Components(callback) {
            if (phase2ComponentsLoaded) {
                if (callback) callback();
                return;
            }
            
            console.log('📦 Loading Phase 2 components for ECS...');
            
            // Load GameEngine-standalone to get the component classes
            const gameEngineScript = document.createElement('script');
            gameEngineScript.src = './GameEngine-standalone.js';
            gameEngineScript.onload = () => {
                console.log('✅ Phase 2 components loaded and available in ECS');
                phase2ComponentsLoaded = true;
                
                // Add physics system to existing ECS
                addPhysicsSystemToECS();
                
                if (callback) callback();
            };
            gameEngineScript.onerror = () => {
                console.error('❌ Failed to load Phase 2 components');
                if (callback) callback();
            };
            document.head.appendChild(gameEngineScript);
        }
        
        function addPhysicsSystemToECS() {
            // Add a physics system to the existing ECS world
            if (!world.physicsSystem) {
                world.physicsSystem = {
                    update: function(deltaTime) {
                        world.entities.forEach(entity => {
                            const rigidbody = entity.getComponent('RigidbodyComponent');
                            const transform = entity.getComponent('Transform');
                            
                            if (rigidbody && rigidbody.active !== false && transform && !rigidbody.isKinematic) {
                                // Apply gravity
                                if (rigidbody.useGravity) {
                                    rigidbody.velocity.y -= 9.81 * deltaTime;
                                }
                                
                                // Update position
                                transform.x += rigidbody.velocity.x * deltaTime;
                                transform.y += rigidbody.velocity.y * deltaTime;
                                transform.z += rigidbody.velocity.z * deltaTime;
                                
                                // Simple ground collision
                                if (transform.y < 0) {
                                    transform.y = 0;
                                    rigidbody.velocity.y = Math.abs(rigidbody.velocity.y) * 0.7; // Bounce
                                }
                            }
                        });
                    }
                };
                console.log('🔬 Physics system integrated into existing ECS');
            }
        }
        
        function loadPhase2Scripts(callback) {
            // This function now loads the demo scripts for the demo buttons
            console.log('📦 Loading Phase 2 demo scripts...');
            
            // Load Physics Demo
            const physicsScript = document.createElement('script');
            physicsScript.src = './physics-demo-standalone.js';
            physicsScript.onload = () => {
                console.log('✅ Physics Demo loaded');
                
                // Load Animation Demo
                const animationScript = document.createElement('script');
                animationScript.src = './animation-demo-standalone.js';
                animationScript.onload = () => {
                    console.log('✅ Animation Demo loaded');
                    callback();
                };
                animationScript.onerror = () => {
                    console.error('❌ Failed to load Animation Demo script');
                };
                document.head.appendChild(animationScript);
            };
            physicsScript.onerror = () => {
                console.error('❌ Failed to load Physics Demo script');
            };
            document.head.appendChild(physicsScript);
        }
        
        function loadPhysicsDemo() {
            console.log('🔬 Loading Physics Demo...');
            switchToPhase2Demo('physics');
        }
        
        // Collider visualization
        function addColliderVisualization(entity) {
            if (!entity) return;
            
            const transform = entity.getComponent('Transform');
            if (!transform) return;
            
            // Remove existing collider visualizations
            removeColliderVisualization(entity);
            
            // Visualize SphereColliderComponent
            const sphereCollider = entity.getComponent('SphereColliderComponent');
            if (sphereCollider && sphereCollider.active !== false) {
                const geometry = new THREE.SphereGeometry(sphereCollider.radius, 16, 12);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x00ff88,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.6
                });
                const sphereHelper = new THREE.Mesh(geometry, material);
                
                // Position the helper
                sphereHelper.position.set(transform.x, transform.y, transform.z);
                sphereHelper.position.add(sphereCollider.center);
                
                // Store reference and add to scene
                entity.sphereColliderHelper = sphereHelper;
                scene.add(sphereHelper);
                
                console.log(`🔵 Added sphere collider visualization for entity ${entity.id}`);
            }
            
            // Visualize BoxColliderComponent
            const boxCollider = entity.getComponent('BoxColliderComponent');
            if (boxCollider && boxCollider.active !== false) {
                const geometry = new THREE.BoxGeometry(boxCollider.size.x, boxCollider.size.y, boxCollider.size.z);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x0088ff,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.6
                });
                const boxHelper = new THREE.Mesh(geometry, material);
                
                // Position the helper
                boxHelper.position.set(transform.x, transform.y, transform.z);
                boxHelper.position.add(boxCollider.center);
                
                // Store reference and add to scene
                entity.boxColliderHelper = boxHelper;
                scene.add(boxHelper);
                
                console.log(`🟦 Added box collider visualization for entity ${entity.id}`);
            }
            
            // Visualize TweenComponent
            const tweenComponent = entity.getComponent('TweenComponent');
            if (tweenComponent && tweenComponent.active !== false) {
                // Create a pulsing ring around the entity to show it has tweening
                const ringGeometry = new THREE.RingGeometry(1.5, 2.0, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff44ff,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide
                });
                const ringHelper = new THREE.Mesh(ringGeometry, ringMaterial);
                
                // Position the ring horizontally around the entity
                ringHelper.position.set(transform.x, transform.y + 1, transform.z);
                ringHelper.rotation.x = Math.PI / 2; // Make it horizontal
                
                // Store reference and add to scene
                entity.tweenHelper = ringHelper;
                scene.add(ringHelper);
                
                console.log(`🟠 Added tween visualization for entity ${entity.id}`);
            }
            
            // Visualize AnimatorComponent
            const animatorComponent = entity.getComponent('AnimatorComponent');
            if (animatorComponent && animatorComponent.active !== false) {
                // Create rotating wireframe octahedron to show animation state
                const geometry = new THREE.OctahedronGeometry(1.2);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xaa44ff,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.8
                });
                const animatorHelper = new THREE.Mesh(geometry, material);
                
                // Position above the entity
                animatorHelper.position.set(transform.x, transform.y + 2.5, transform.z);
                
                // Store reference and add to scene
                entity.animatorHelper = animatorHelper;
                scene.add(animatorHelper);
                
                console.log(`🎭 Added animator visualization for entity ${entity.id}`);
            }
        }
        
        function removeColliderVisualization(entity) {
            if (!entity) return;
            
            // Remove sphere collider helper
            if (entity.sphereColliderHelper) {
                scene.remove(entity.sphereColliderHelper);
                entity.sphereColliderHelper.geometry.dispose();
                entity.sphereColliderHelper.material.dispose();
                delete entity.sphereColliderHelper;
            }
            
            // Remove box collider helper
            if (entity.boxColliderHelper) {
                scene.remove(entity.boxColliderHelper);
                entity.boxColliderHelper.geometry.dispose();
                entity.boxColliderHelper.material.dispose();
                delete entity.boxColliderHelper;
            }
            
            // Remove tween helper
            if (entity.tweenHelper) {
                scene.remove(entity.tweenHelper);
                entity.tweenHelper.geometry.dispose();
                entity.tweenHelper.material.dispose();
                delete entity.tweenHelper;
            }
            
            // Remove animator helper
            if (entity.animatorHelper) {
                scene.remove(entity.animatorHelper);
                entity.animatorHelper.geometry.dispose();
                entity.animatorHelper.material.dispose();
                delete entity.animatorHelper;
            }
        }
        
        function updateColliderVisualization(entity) {
            if (!entity || entity !== selectedEntity) return;
            
            const transform = entity.getComponent('Transform');
            if (!transform) return;
            
            const now = Date.now();
            
            // Update sphere collider position
            if (entity.sphereColliderHelper) {
                const sphereCollider = entity.getComponent('SphereColliderComponent');
                if (sphereCollider) {
                    entity.sphereColliderHelper.position.set(transform.x, transform.y, transform.z);
                    entity.sphereColliderHelper.position.add(sphereCollider.center);
                }
            }
            
            // Update box collider position
            if (entity.boxColliderHelper) {
                const boxCollider = entity.getComponent('BoxColliderComponent');
                if (boxCollider) {
                    entity.boxColliderHelper.position.set(transform.x, transform.y, transform.z);
                    entity.boxColliderHelper.position.add(boxCollider.center);
                }
            }
            
            // Update tween helper with pulsing animation
            if (entity.tweenHelper) {
                entity.tweenHelper.position.set(transform.x, transform.y + 1, transform.z);
                
                // Pulsing effect
                const pulse = Math.sin(now * 0.005) * 0.3 + 0.7;
                entity.tweenHelper.material.opacity = pulse;
                
                // Slow rotation
                entity.tweenHelper.rotation.z += 0.02;
            }
            
            // Update animator helper with rotation
            if (entity.animatorHelper) {
                entity.animatorHelper.position.set(transform.x, transform.y + 2.5, transform.z);
                
                // Continuous rotation on multiple axes
                entity.animatorHelper.rotation.x += 0.03;
                entity.animatorHelper.rotation.y += 0.02;
                entity.animatorHelper.rotation.z += 0.01;
            }
        }
        
        // Component toggle functionality
        function toggleComponent(entity, componentType, component) {
            const wasActive = component.active !== false;
            component.active = !wasActive;
            
            console.log(`🔄 ${wasActive ? 'Disabled' : 'Enabled'} ${componentType} for entity ${entity.id}`);
            
            // Force immediate update after toggle to show the change
            setTimeout(() => {
                updateInspector();
                updateSelectionUI();
            }, 0);
        }
        
        // Demo functions removed - components are now integrated directly into ECS
        
        function switchToPhase2Demo(demoType) {
            try {
                // Instead of creating a new engine, extend the existing ECS demo
                // Load required scripts if not already loaded
                loadPhase2Scripts(() => {
                    // Store current ECS state
                    window.ecsBackupState = {
                        entities: world.entities.slice(),
                        selectedEntity: selectedEntity
                    };
                    
                    // Clear current entities but keep the ECS infrastructure
                    clearAll();
                    
                    // Add physics/animation components to existing ECS
                    addPhase2ComponentsToECS();
                    
                    // Create demo using existing ECS infrastructure
                    if (demoType === 'physics') {
                        currentPhase2Demo = createPhysicsDemoInECS();
                    } else if (demoType === 'animation') {
                        currentPhase2Demo = createAnimationDemoInECS();
                    }
                    
                    // Update UI to show Phase 2 controls
                    showPhase2UI(demoType);
                    
                    console.log(`✅ ${demoType} demo loaded in existing ECS!`);
                });
                
            } catch (error) {
                console.error(`❌ Failed to load ${demoType} demo:`, error);
                alert(`Failed to load ${demoType} demo. Check console for details.`);
            }
        }
        
        function addPhase2ComponentsToECS() {
            // Add physics and animation component classes to the existing ECS
            window.RigidbodyComponent = window.RigidbodyComponent;
            window.BoxColliderComponent = window.BoxColliderComponent;
            window.SphereColliderComponent = window.SphereColliderComponent;
            window.PhysicsMaterialComponent = window.PhysicsMaterialComponent;
            window.TweenComponent = window.TweenComponent;
            window.AnimatorComponent = window.AnimatorComponent;
            
            console.log('Phase 2 components added to ECS');
        }
        
        function createPhysicsDemoInECS() {
            // Create physics demo entities using proper ECS components
            const demo = {
                objects: [],
                currentMode: 1,
                spawnTimer: 0,
                spawnInterval: 1.0,
                
                initialize: function() {
                    // Add a simple physics system to the existing ECS
                    this.addPhysicsSystemToECS();
                    this.createGround();
                    this.createWalls();
                    this.setMode(1);
                    console.log('Physics demo created in existing ECS with proper components');
                },
                
                addPhysicsSystemToECS: function() {
                    // Add a simple physics system that processes RigidbodyComponent
                    if (!world.physicsSystem) {
                        world.physicsSystem = {
                            update: function(deltaTime) {
                                world.entities.forEach(entity => {
                                    const rigidbody = entity.getComponent('RigidbodyComponent');
                                    const transform = entity.getComponent('Transform');
                                    
                                    if (rigidbody && transform && !rigidbody.isKinematic) {
                                        // Apply gravity
                                        if (rigidbody.useGravity) {
                                            rigidbody.velocity.y -= 9.81 * deltaTime;
                                        }
                                        
                                        // Update position
                                        transform.x += rigidbody.velocity.x * deltaTime;
                                        transform.y += rigidbody.velocity.y * deltaTime;
                                        transform.z += rigidbody.velocity.z * deltaTime;
                                        
                                        // Simple ground collision
                                        if (transform.y < 0) {
                                            transform.y = 0;
                                            rigidbody.velocity.y = Math.abs(rigidbody.velocity.y) * 0.7; // Bounce with restitution
                                        }
                                    }
                                });
                            }
                        };
                        console.log('✅ Physics system added to ECS');
                    }
                },
                
                createGround: function() {
                    const ground = world.createEntity();
                    
                    // Add Transform component
                    const transform = new Transform(0, -1, 0);
                    ground.addComponent(transform);
                    
                    // Add Renderable component
                    const renderable = new Renderable(
                        new THREE.BoxGeometry(40, 2, 40),
                        new THREE.MeshLambertMaterial({ color: 0x8B4513 })
                    );
                    ground.addComponent(renderable);
                    
                    // Add proper RigidbodyComponent (kinematic ground)
                    const rigidbody = new window.RigidbodyComponent();
                    rigidbody.isKinematic = true;
                    rigidbody.mass = 0;
                    rigidbody.useGravity = false;
                    ground.addComponent(rigidbody);
                    
                    // Add BoxColliderComponent
                    const collider = new window.BoxColliderComponent();
                    collider.setSize(40, 2, 40);
                    ground.addComponent(collider);
                    
                    console.log('✅ Ground created with proper physics components');
                },
                
                createWalls: function() {
                    const wallPositions = [
                        { pos: [0, 5, 20], size: [40, 10, 2] },   // Back
                        { pos: [0, 5, -20], size: [40, 10, 2] },  // Front  
                        { pos: [20, 5, 0], size: [2, 10, 40] },   // Right
                        { pos: [-20, 5, 0], size: [2, 10, 40] }   // Left
                    ];
                    
                    wallPositions.forEach((wall, index) => {
                        const entity = world.createEntity();
                        
                        // Add Transform component
                        const transform = new Transform(wall.pos[0], wall.pos[1], wall.pos[2]);
                        entity.addComponent(transform);
                        
                        // Add Renderable component
                        const renderable = new Renderable(
                            new THREE.BoxGeometry(...wall.size),
                            new THREE.MeshLambertMaterial({ 
                                color: 0x666666,
                                transparent: true,
                                opacity: 0.3
                            })
                        );
                        entity.addComponent(renderable);
                        
                        // Add proper RigidbodyComponent (kinematic walls)
                        const rigidbody = new window.RigidbodyComponent();
                        rigidbody.isKinematic = true;
                        rigidbody.mass = 0;
                        rigidbody.useGravity = false;
                        entity.addComponent(rigidbody);
                        
                        // Add BoxColliderComponent
                        const collider = new window.BoxColliderComponent();
                        collider.setSize(...wall.size);
                        entity.addComponent(collider);
                    });
                    console.log('✅ Walls created with proper physics components');
                },
                
                setMode: function(mode) {
                    this.currentMode = mode;
                    // Clear existing dynamic physics objects
                    this.objects.forEach(obj => {
                        if (obj.getComponent('RigidbodyComponent') && !obj.getComponent('RigidbodyComponent').isKinematic) {
                            world.destroyEntity(obj);
                        }
                    });
                    this.objects = [];
                    
                    // Create initial objects for the mode
                    for (let i = 0; i < 3; i++) {
                        this.spawnBall();
                    }
                },
                
                spawnBall: function() {
                    const ball = world.createEntity();
                    
                    // Add Transform component
                    const transform = new Transform(
                        (Math.random() - 0.5) * 30, 
                        10 + Math.random() * 10, 
                        (Math.random() - 0.5) * 30
                    );
                    ball.addComponent(transform);
                    
                    // Add Renderable component
                    const renderable = new Renderable(
                        new THREE.SphereGeometry(0.5, 16, 16),
                        new THREE.MeshLambertMaterial({ 
                            color: [0xff4444, 0x44ff44, 0x4444ff, 0xffff44, 0xff44ff, 0x44ffff][Math.floor(Math.random() * 6)]
                        })
                    );
                    ball.addComponent(renderable);
                    
                    // Add proper RigidbodyComponent (dynamic ball)
                    const rigidbody = new window.RigidbodyComponent();
                    rigidbody.isKinematic = false;
                    rigidbody.mass = 1;
                    rigidbody.useGravity = true;
                    rigidbody.velocity = new THREE.Vector3(0, 0, 0);
                    ball.addComponent(rigidbody);
                    
                    // Add SphereColliderComponent
                    const collider = new window.SphereColliderComponent();
                    collider.setRadius(0.5);
                    ball.addComponent(collider);
                    
                    this.objects.push(ball);
                    console.log('✅ Ball spawned with proper physics components:', {
                        'Transform': !!ball.getComponent('Transform'),
                        'Renderable': !!ball.getComponent('Renderable'),
                        'RigidbodyComponent': !!ball.getComponent('RigidbodyComponent'),
                        'SphereColliderComponent': !!ball.getComponent('SphereColliderComponent')
                    });
                },
                
                update: function(deltaTime) {
                    // Update physics using the proper physics system
                    if (world.physicsSystem) {
                        world.physicsSystem.update(deltaTime);
                    }
                    
                    // Remove balls that fall too far
                    this.objects = this.objects.filter(obj => {
                        const transform = obj.getComponent('Transform');
                        if (transform && transform.y < -20) {
                            world.destroyEntity(obj);
                            return false;
                        }
                        return true;
                    });
                },
                
                onKeyPress: function(key) {
                    if (key === ' ') {
                        this.spawnBall();
                        console.log('🏀 Spawned ball with proper physics components');
                    }
                }
            };
            
            return demo;
        }
        
        function createAnimationDemoInECS() {
            // Similar structure for animation demo
            return {
                initialize: function() {
                    console.log('Animation demo would be created in ECS here');
                },
                update: function(deltaTime) {},
                onKeyPress: function(key) {}
            };
        }
        
        function showPhase2UI(demoType) {
            // Update UI to show Phase 2 controls while keeping ECS inspector
            document.getElementById('ui').style.display = 'block';
            document.getElementById('inspector').style.display = 'block';
            
            // Add Phase 2 info overlay
            addPhase2DemoInfo(demoType, currentPhase2Demo);
            
            // Add input handling
            window.addEventListener('keydown', handlePhase2Input);
        }
        
        function switchToECSDemo() {
            // Clean up Phase 2 demo
            if (currentPhase2Demo) {
                currentPhase2Demo = null;
            }
            
            // Remove Phase 2 event listeners
            window.removeEventListener('keydown', handlePhase2Input);
            
            // Remove demo info
            const demoInfo = document.getElementById('phase2-demo-info');
            if (demoInfo) {
                demoInfo.remove();
            }
            
            // Restore original ECS entities if we backed them up
            if (window.ecsBackupState) {
                world.entities = window.ecsBackupState.entities.slice();
                selectedEntity = window.ecsBackupState.selectedEntity;
                window.ecsBackupState = null;
            } else {
                // If no backup, restart fresh
                clearAll();
                // Recreate initial entities
                for (let i = 0; i < 5; i++) {
                    createEntity();
                }
            }
            
            // Make sure UI is visible
            document.getElementById('ui').style.display = 'block';
            document.getElementById('inspector').style.display = 'block';
            
            console.log('✅ Switched back to ECS demo');
        }
        
        function handlePhase2Input(event) {
            if (currentPhase2Demo && currentPhase2Demo.onKeyPress) {
                // Convert event.code to the format expected by demos
                let key = event.key;
                if (event.code === 'Space') key = ' ';
                console.log('🎮 Key pressed:', event.code, '→', key);
                currentPhase2Demo.onKeyPress(key);
            }
        }
        
        function handlePhase2Click(event) {
            if (!currentGameEngine || !currentPhase2Demo) return;
            
            // Simple click handling - just pass the event to the demo
            if (currentPhase2Demo.onClick) {
                currentPhase2Demo.onClick(event);
            }
        }
        
        function addPhase2DemoInfo(demoType, demo) {
            // Remove existing info
            const existingInfo = document.getElementById('phase2-demo-info');
            if (existingInfo) {
                existingInfo.remove();
            }
            
            // Create new info panel
            const infoPanel = document.createElement('div');
            infoPanel.id = 'phase2-demo-info';
            infoPanel.style.cssText = `
                position: absolute;
                top: 10px;
                left: 10px;
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 15px;
                border-radius: 5px;
                border: 2px solid #4CAF50;
                font-family: monospace;
                font-size: 12px;
                z-index: 1000;
                max-width: 300px;
            `;
            
            const demoName = demoType.charAt(0).toUpperCase() + demoType.slice(1);
            const controls = getPhase2DemoControls(demoType);
            
            infoPanel.innerHTML = `
                <h3 style="margin: 0 0 10px 0; color: #4CAF50;">🎮 ${demoName} Demo</h3>
                <p style="margin: 0 0 10px 0; font-size: 11px; color: #ccc;">Phase 2 ECS Engine Demo</p>
                <div style="margin-bottom: 10px;">
                    <button onclick="resetToECSDemo()" style="padding: 5px 10px; background: #F44336; color: white; border: none; border-radius: 3px; cursor: pointer; font-family: monospace;">← Back to ECS Demo</button>
                </div>
                <div style="font-size: 10px; color: #888;">
                    <strong>Controls:</strong><br>
                    ${controls}
                </div>
            `;
            
            document.body.appendChild(infoPanel);
        }
        
        function getPhase2DemoControls(demoType) {
            if (demoType === 'physics') {
                return `
                    • 1-5: Switch demo modes<br>
                    • Space: Spawn ball<br>
                    • Click: Apply impulse<br>
                    • G: Toggle gravity<br>
                    • C: Clear objects<br>
                    • M: Next mode<br>
                    • R: Reset mode<br>
                    • H: Help
                `;
            } else if (demoType === 'animation') {
                return `
                    • 1-5: Switch demo types<br>
                    • Space: Pause/Resume<br>
                    • ↑/↓: Speed up/down<br>
                    • Click: Select object<br>
                    • M: Next demo<br>
                    • R: Restart demo<br>
                    • H: Help
                `;
            }
            return 'See console for controls (press H)';
        }
        
        // Initialize Lucide icons when they're loaded
        window.addEventListener('load', () => {
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
                
                // Re-create icons whenever the inspector updates
                const originalUpdateInspector = updateInspector;
                updateInspector = function() {
                    originalUpdateInspector();
                    setTimeout(() => lucide.createIcons(), 0);
                };
            }
        });
    </script>
</body>
</html>