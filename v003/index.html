<!DOCTYPE html>
<html>
<head>
    <title>NeverEverLand v003 - ECS Demo</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="container">
        <div id="ui">
            <div id="ui-header">
                <h3>üéÆ ECS Engine Demo</h3>
                <span style="font-size: 10px; color: #888;"><i data-lucide="move" style="width: 12px; height: 12px;"></i> Drag to move</span>
            </div>
            <p>Entity Component System in action</p>
            
            <div id="selectionInfo" style="margin: 5px 0; font-size: 11px; color: #888;">
Click an entity to select it. Click components to toggle on/off.
            </div>
            
            <div>
                <button onclick="queryEntities()">Query Test</button>
                <button onclick="stressTest()">Stress Test</button>
            </div>
            
            
            
            <div id="status">
                <div>Entities: <span id="entityCount">0</span></div>
                <div>Components: <span id="componentCount">0</span></div>
                <div>Systems: <span id="systemCount">4</span></div>
                <div>Queries: <span id="queryCount">0</span></div>
                <div>Performance: <span id="performance">--</span></div>
            </div>
            
            <div style="margin-top: 10px; font-size: 10px; color: #888;">
                <strong>ECS Architecture:</strong><br>
                ‚Ä¢ Entities are just IDs<br>
                ‚Ä¢ Components hold data<br>
                ‚Ä¢ Systems process components<br>
                ‚Ä¢ Queries find entities by components<br><br>
                <strong style="color: #4CAF50;">üöÄ Physics, Animation & World Building Components Available!</strong><br>
                <strong style="color: #FFC107;">üèóÔ∏è Phase 4: Village, Building, Resource, Worker & Economy Systems!</strong><br>
                <strong style="color: #FF5722;">üéØ Phase 5: Quest, Dialogue, NPC & Event Systems!</strong><br>
                Use the + button in the inspector to add any component!
            </div>
        </div>
        
        <div id="inspector">
            <div id="inspector-header">
                <span><i data-lucide="search" style="width: 16px; height: 16px; vertical-align: text-bottom;"></i> Component Inspector</span>
                <span style="font-size: 10px; color: #888;"><i data-lucide="move" style="width: 12px; height: 12px;"></i> Drag to move ‚Ä¢ <i data-lucide="maximize-2" style="width: 12px; height: 12px;"></i> Resize corner</span>
            </div>
            <div id="inspector-content">
                <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                    <button onclick="createEntity()" style="flex: 1; padding: 8px; background: #4CAF50; color: white; border: none; border-radius: 3px; cursor: pointer; font-family: monospace; display: flex; align-items: center; justify-content: center; gap: 5px;"><i data-lucide="plus" style="width: 16px; height: 16px;"></i> Create Entity</button>
                    <button onclick="clearAll()" style="padding: 8px 12px; background: #F44336; color: white; border: none; border-radius: 3px; cursor: pointer; font-family: monospace; display: flex; align-items: center; justify-content: center; gap: 5px;"><i data-lucide="trash-2" style="width: 16px; height: 16px;"></i> Clear All</button>
                </div>
                <div id="entityList"></div>
            </div>
        </div>
    </div>

    <script src="./three.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    
    <script>
        // Simple ECS Implementation
        class Entity {
            static nextId = 1;
            constructor() {
                this.id = Entity.nextId++;
                this.components = new Map();
                this.active = true;
            }
            
            addComponent(component) {
                this.components.set(component.constructor.name, component);
                return this;
            }
            
            removeComponent(componentType) {
                this.components.delete(componentType);
                return this;
            }
            
            getComponent(componentType) {
                return this.components.get(componentType);
            }
            
            hasComponent(componentType) {
                return this.components.has(componentType);
            }
        }
        
        // Components (data only)
        class Transform {
            constructor(x = 0, y = 0, z = 0) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.rotation = { x: 0, y: 0, z: 0 };
                this.scale = { x: 1, y: 1, z: 1 };
            }
        }
        
        class Renderable {
            constructor(mesh) {
                this.mesh = mesh;
                this.visible = true;
            }
        }
        
        class Movement {
            constructor() {
                this.velocity = { x: 0, y: 0, z: 0 };
                this.speed = Math.random() * 2 + 1;
            }
        }
        
        class Health {
            constructor() {
                this.current = 100;
                this.max = 100;
            }
        }
        
        class Lifetime {
            constructor(duration = 5) {
                this.remaining = duration;
            }
        }
        
        class VisualComponent {
            constructor() {
                this.wireframe = false;
                this.wireframeColor = 0x00ff00;
                this.vertexColors = false;
                this.pointsMode = false;
                this.pointSize = 3;
                this.pointColor = 0xff0000;
                this.opacity = 1.0;
                this.transparent = false;
                this.emissive = 0x000000;
                this.emissiveIntensity = 0.5;
                this.flatShading = false;
                this.doubleSided = false;
                this.visible = true;
            }
        }
        
        // Visual System to apply VisualComponent settings
        class VisualSystem {
            update(entities, deltaTime) {
                entities.forEach(entity => {
                    const visual = entity.getComponent('VisualComponent');
                    const renderable = entity.getComponent('Renderable');
                    
                    if (visual && visual.active !== false && renderable && renderable.mesh) {
                        const mesh = renderable.mesh;
                        
                        // Apply visual properties
                        mesh.material.wireframe = visual.wireframe;
                        mesh.material.transparent = visual.transparent;
                        mesh.material.opacity = visual.opacity;
                        mesh.material.emissive.setHex(visual.emissive);
                        mesh.material.side = visual.doubleSided ? THREE.DoubleSide : THREE.FrontSide;
                        mesh.visible = visual.visible;
                        
                        // Handle points mode (requires material change)
                        if (visual.pointsMode && !mesh.userData.isPointsMaterial) {
                            const pointsMaterial = new THREE.PointsMaterial({ 
                                color: visual.pointColor,
                                size: visual.pointSize
                            });
                            const points = new THREE.Points(mesh.geometry, pointsMaterial);
                            points.position.copy(mesh.position);
                            points.rotation.copy(mesh.rotation);
                            points.scale.copy(mesh.scale);
                            
                            // Replace mesh with points temporarily
                            mesh.parent.add(points);
                            mesh.visible = false;
                            mesh.userData.pointsHelper = points;
                            mesh.userData.isPointsMaterial = true;
                        } else if (!visual.pointsMode && mesh.userData.pointsHelper) {
                            // Remove points and show original mesh
                            mesh.parent.remove(mesh.userData.pointsHelper);
                            mesh.userData.pointsHelper.geometry.dispose();
                            mesh.userData.pointsHelper.material.dispose();
                            delete mesh.userData.pointsHelper;
                            delete mesh.userData.isPointsMaterial;
                            mesh.visible = visual.visible;
                        }
                        
                        // Mark material as needing update
                        mesh.material.needsUpdate = true;
                    }
                });
            }
        }
        
        // Systems (logic only)
        class MovementSystem {
            update(entities, deltaTime) {
                entities.forEach(entity => {
                    const transform = entity.getComponent('Transform');
                    const movement = entity.getComponent('Movement');
                    
                    // Only update if both components exist and both are active
                    if (transform && transform.active !== false && movement && movement.active !== false) {
                        // Update position based on velocity
                        transform.x += movement.velocity.x * deltaTime;
                        transform.y += movement.velocity.y * deltaTime;
                        transform.z += movement.velocity.z * deltaTime;
                        
                        // Bounce off boundaries
                        if (Math.abs(transform.x) > 10) movement.velocity.x *= -1;
                        if (Math.abs(transform.z) > 10) movement.velocity.z *= -1;
                        if (transform.y < 0.5) movement.velocity.y = Math.abs(movement.velocity.y);
                        if (transform.y > 5) movement.velocity.y = -Math.abs(movement.velocity.y);
                        
                        // Update 3D mesh position
                        const renderable = entity.getComponent('Renderable');
                        if (renderable && renderable.mesh) {
                            renderable.mesh.position.set(transform.x, transform.y, transform.z);
                        }
                    }
                });
            }
        }
        
        class RenderSystem {
            update(entities) {
                entities.forEach(entity => {
                    const transform = entity.getComponent('Transform');
                    const renderable = entity.getComponent('Renderable');
                    
                    if (transform && transform.active !== false && renderable && renderable.mesh) {
                        // Update mesh transform
                        renderable.mesh.position.set(transform.x, transform.y, transform.z);
                        renderable.mesh.rotation.set(transform.rotation.x, transform.rotation.y, transform.rotation.z);
                        renderable.mesh.scale.set(transform.scale.x, transform.scale.y, transform.scale.z);
                        renderable.mesh.visible = renderable.visible;
                    }
                });
            }
        }
        
        class LifetimeSystem {
            update(entities, deltaTime) {
                const toDestroy = [];
                entities.forEach(entity => {
                    const lifetime = entity.getComponent('Lifetime');
                    if (lifetime && lifetime.active !== false) {
                        lifetime.remaining -= deltaTime;
                        if (lifetime.remaining <= 0) {
                            toDestroy.push(entity);
                        }
                    }
                });
                
                toDestroy.forEach(entity => {
                    // Clear selection if this entity is currently selected
                    if (selectedEntity && selectedEntity.id === entity.id) {
                        selectEntity(null);
                    }
                    world.destroyEntity(entity);
                });
                
                // Force inspector update if entities were destroyed
                if (toDestroy.length > 0) {
                    updateInspector();
                    updateStatus();
                }
            }
        }
        
        class HealthSystem {
            update(entities, deltaTime) {
                entities.forEach(entity => {
                    const health = entity.getComponent('Health');
                    const renderable = entity.getComponent('Renderable');
                    
                    if (health && health.active !== false && renderable && renderable.mesh) {
                        // Color based on health
                        const healthPercent = health.current / health.max;
                        if (healthPercent > 0.5) {
                            renderable.mesh.material.color.setHex(0x4CAF50); // Green
                        } else if (healthPercent > 0.2) {
                            renderable.mesh.material.color.setHex(0xFFEB3B); // Yellow
                        } else {
                            renderable.mesh.material.color.setHex(0xF44336); // Red
                        }
                        
                        // Slowly lose health
                        health.current = Math.max(0, health.current - deltaTime * 5);
                    }
                });
            }
        }
        
        // World (ECS coordinator)
        class World {
            constructor() {
                this.entities = [];
                this.systems = [
                    new MovementSystem(),
                    new VisualSystem(),
                    new RenderSystem(),
                    new LifetimeSystem(),
                    new HealthSystem()
                ];
                this.queryCache = new Map();
            }
            
            createEntity() {
                const entity = new Entity();
                this.entities.push(entity);
                this.clearQueryCache();
                return entity;
            }
            
            destroyEntity(entity) {
                // Remove from scene if it has a mesh
                const renderable = entity.getComponent('Renderable');
                if (renderable && renderable.mesh) {
                    scene.remove(renderable.mesh);
                }
                
                // Clean up all visualization helpers
                removeColliderVisualization(entity);
                
                // Clear selection if this entity is currently selected
                if (selectedEntity && selectedEntity.id === entity.id) {
                    selectEntity(null);
                }
                
                const index = this.entities.indexOf(entity);
                if (index > -1) {
                    this.entities.splice(index, 1);
                }
                this.clearQueryCache();
            }
            
            query(componentTypes) {
                const key = componentTypes.sort().join(',');
                if (this.queryCache.has(key)) {
                    return this.queryCache.get(key);
                }
                
                const result = this.entities.filter(entity => 
                    componentTypes.every(type => entity.hasComponent(type))
                );
                
                this.queryCache.set(key, result);
                return result;
            }
            
            clearQueryCache() {
                this.queryCache.clear();
            }
            
            update(deltaTime) {
                this.systems.forEach(system => {
                    system.update(this.entities, deltaTime);
                });
            }
            
            getStats() {
                let componentCount = 0;
                this.entities.forEach(entity => {
                    componentCount += entity.components.size;
                });
                
                return {
                    entities: this.entities.length,
                    components: componentCount,
                    systems: this.systems.length,
                    queries: this.queryCache.size
                };
            }
        }
        
        // === Phase 3 Components ===
        class PartyComponent {
            constructor() {
                this.members = []; // Array of entity IDs
                this.activeLeader = 0; // Index of current leader
                this.maxSize = 3;
                this.formation = 'line'; // 'line', 'triangle', 'column'
                this.spacing = 2.0; // Distance between party members
                this.followDistance = 1.5; // How close followers stay to leader
                this.active = true;
            }
            
            addMember(entityId) {
                if (this.members.length < this.maxSize && !this.members.includes(entityId)) {
                    this.members.push(entityId);
                    return true;
                }
                return false;
            }
            
            removeMember(entityId) {
                const index = this.members.indexOf(entityId);
                if (index !== -1) {
                    this.members.splice(index, 1);
                    if (this.activeLeader >= this.members.length) {
                        this.activeLeader = Math.max(0, this.members.length - 1);
                    }
                    return true;
                }
                return false;
            }
            
            getLeader() {
                return this.members[this.activeLeader] || null;
            }
            
            switchLeader(newLeaderIndex) {
                if (newLeaderIndex >= 0 && newLeaderIndex < this.members.length) {
                    this.activeLeader = newLeaderIndex;
                    return true;
                }
                return false;
            }
        }
        
        class CharacterComponent {
            constructor() {
                this.name = 'Hero';
                this.level = 1;
                this.experience = 0;
                this.experienceToNext = 100;
                
                // Core stats
                this.stats = {
                    strength: 10,
                    dexterity: 10,
                    intelligence: 10,
                    vitality: 10
                };
                
                // Derived stats
                this.maxHealth = 100;
                this.currentHealth = 100;
                this.maxMana = 50;
                this.currentMana = 50;
                this.moveSpeed = 5.0;
                this.attackPower = 15;
                this.defense = 5;
                
                // Equipment slots
                this.equipment = {
                    weapon: null,
                    armor: null,
                    accessory: null
                };
                
                // Abilities
                this.abilities = [];
                this.activeAbility = null;
                
                this.active = true;
            }
            
            levelUp() {
                this.level++;
                this.experience = 0;
                this.experienceToNext = Math.floor(this.experienceToNext * 1.5);
                
                // Increase stats
                this.stats.strength += 2;
                this.stats.dexterity += 2;
                this.stats.intelligence += 1;
                this.stats.vitality += 3;
                
                this.recalculateStats();
            }
            
            addExperience(amount) {
                this.experience += amount;
                while (this.experience >= this.experienceToNext) {
                    this.levelUp();
                }
            }
            
            recalculateStats() {
                this.maxHealth = 100 + (this.stats.vitality * 10);
                this.maxMana = 50 + (this.stats.intelligence * 5);
                this.attackPower = 15 + (this.stats.strength * 2);
                this.defense = 5 + (this.stats.vitality * 1);
                this.moveSpeed = 5.0 + (this.stats.dexterity * 0.1);
            }
        }
        
        class AIComponent {
            constructor() {
                this.behaviorType = 'follow'; // 'follow', 'guard', 'patrol', 'aggressive'
                this.currentState = 'idle';
                this.target = null; // Target entity ID
                this.lastKnownTargetPosition = null;
                this.detectionRadius = 5.0;
                this.attackRadius = 1.5;
                this.patrolPoints = []; // Array of Vector3 positions
                this.currentPatrolIndex = 0;
                this.stateTimer = 0;
                this.decisionCooldown = 0.5; // How often to make new decisions
                this.lastDecisionTime = 0;
                this.active = true;
            }
            
            setState(newState) {
                this.currentState = newState;
                this.stateTimer = 0;
            }
            
            setTarget(entityId) {
                this.target = entityId;
            }
            
            addPatrolPoint(position) {
                this.patrolPoints.push(position.clone());
            }
        }
        
        class CombatComponent {
            constructor() {
                this.attackPower = 15;
                this.attackSpeed = 1.0; // Attacks per second
                this.attackRange = 1.5;
                this.lastAttackTime = 0;
                this.combatState = 'idle'; // 'idle', 'attacking', 'blocking', 'stunned'
                this.statusEffects = []; // Array of active status effects
                this.immunities = []; // Array of immunity types
                this.weaknesses = []; // Array of weakness types
                this.criticalChance = 0.05; // 5% chance
                this.criticalMultiplier = 2.0;
                this.active = true;
            }
            
            canAttack() {
                const now = performance.now() / 1000;
                return (now - this.lastAttackTime) >= (1.0 / this.attackSpeed) && 
                       this.combatState !== 'stunned';
            }
            
            attack() {
                if (this.canAttack()) {
                    this.lastAttackTime = performance.now() / 1000;
                    this.combatState = 'attacking';
                    
                    // Calculate damage with critical chance
                    let damage = this.attackPower;
                    if (Math.random() < this.criticalChance) {
                        damage *= this.criticalMultiplier;
                        return { damage, isCritical: true };
                    }
                    
                    return { damage, isCritical: false };
                }
                return null;
            }
            
            addStatusEffect(effect) {
                this.statusEffects.push({
                    type: effect.type,
                    duration: effect.duration,
                    value: effect.value,
                    startTime: performance.now() / 1000
                });
            }
        }
        
        class InventoryComponent {
            constructor() {
                this.slots = new Array(20).fill(null); // 20 inventory slots
                this.maxWeight = 100;
                this.currentWeight = 0;
                this.currency = 0; // Gold or other currency
                this.active = true;
            }
            
            addItem(item, quantity = 1) {
                // Find first empty slot
                for (let i = 0; i < this.slots.length; i++) {
                    if (this.slots[i] === null) {
                        this.slots[i] = {
                            item: item,
                            quantity: quantity
                        };
                        this.currentWeight += item.weight * quantity;
                        return true;
                    }
                }
                return false; // Inventory full
            }
            
            removeItem(slotIndex, quantity = 1) {
                if (this.slots[slotIndex] !== null) {
                    const stack = this.slots[slotIndex];
                    const removeQty = Math.min(quantity, stack.quantity);
                    
                    this.currentWeight -= stack.item.weight * removeQty;
                    stack.quantity -= removeQty;
                    
                    if (stack.quantity <= 0) {
                        this.slots[slotIndex] = null;
                    }
                    
                    return removeQty;
                }
                return 0;
            }
            
            hasSpace() {
                return this.slots.some(slot => slot === null);
            }
        }
        
        // === Phase 4 Components: World Building Systems ===
        
        class VillageComponent {
            constructor() {
                this.name = 'New Village';
                this.population = 5; // Starting population
                this.maxPopulation = 50;
                this.morale = 75; // 0-100, affects productivity
                this.founded = Date.now();
                
                // Population tracking
                this.adults = 3;
                this.children = 2;
                this.elderly = 0;
                
                // Village stats
                this.happiness = 70; // 0-100
                this.prosperity = 50; // 0-100
                this.safety = 60; // 0-100
                
                // Growth factors
                this.growthRate = 0.1; // Population growth per day
                this.immigrationRate = 0.05;
                this.emigrationRate = 0.02;
                
                this.active = true;
            }
            
            addPopulation(count = 1) {
                if (this.population + count <= this.maxPopulation) {
                    this.population += count;
                    this.adults += count;
                    return true;
                }
                return false;
            }
            
            removePopulation(count = 1) {
                if (this.population - count >= 0) {
                    this.population -= count;
                    this.adults = Math.max(0, this.adults - count);
                    return true;
                }
                return false;
            }
            
            calculateMorale() {
                // Morale based on happiness, safety, and prosperity
                this.morale = Math.round((this.happiness + this.safety + this.prosperity) / 3);
                return this.morale;
            }
        }
        
        class BuildingComponent {
            constructor() {
                this.buildingType = 'house'; // house, farm, workshop, storage, etc.
                this.level = 1;
                this.maxLevel = 5;
                this.health = 100; // Building durability
                this.maxHealth = 100;
                
                // Construction state
                this.isConstructed = false;
                this.constructionProgress = 0; // 0-100%
                this.constructionTime = 10; // Seconds to build
                this.constructionStarted = null;
                
                // Resource requirements
                this.resourceRequirements = {
                    wood: 10,
                    stone: 5,
                    gold: 20
                };
                
                // Production capabilities
                this.produces = null; // What this building produces
                this.productionRate = 1; // Per second
                this.capacity = 100; // Storage/housing capacity
                this.occupied = 0; // Current occupancy
                
                // Worker requirements
                this.workersRequired = 1;
                this.workersAssigned = 0;
                this.efficiency = 1.0; // 0.0-2.0 based on workers/morale
                
                this.active = true;
            }
            
            startConstruction() {
                if (!this.isConstructed && this.constructionProgress === 0) {
                    this.constructionStarted = Date.now();
                    return true;
                }
                return false;
            }
            
            updateConstruction() {
                if (this.constructionStarted && !this.isConstructed) {
                    const elapsed = (Date.now() - this.constructionStarted) / 1000;
                    this.constructionProgress = Math.min(100, (elapsed / this.constructionTime) * 100);
                    
                    if (this.constructionProgress >= 100) {
                        this.isConstructed = true;
                        this.health = this.maxHealth;
                    }
                }
            }
            
            upgrade() {
                if (this.level < this.maxLevel && this.isConstructed) {
                    this.level++;
                    this.capacity = Math.floor(this.capacity * 1.5);
                    this.productionRate *= 1.3;
                    this.maxHealth = Math.floor(this.maxHealth * 1.2);
                    this.health = this.maxHealth;
                    return true;
                }
                return false;
            }
        }
        
        class ResourceComponent {
            constructor() {
                this.resources = {
                    wood: 50,
                    stone: 30,
                    food: 40,
                    gold: 100,
                    iron: 0,
                    tools: 5
                };
                
                this.maxStorage = {
                    wood: 500,
                    stone: 500,
                    food: 200,
                    gold: 1000,
                    iron: 300,
                    tools: 50
                };
                
                // Resource generation rates (per second)
                this.productionRates = {
                    wood: 0.1,
                    stone: 0.05,
                    food: 0.2,
                    gold: 0.02,
                    iron: 0.01,
                    tools: 0.005
                };
                
                // Resource consumption rates (per second)
                this.consumptionRates = {
                    food: 0.1, // Population consumes food
                    tools: 0.001 // Tools wear out
                };
                
                this.active = true;
            }
            
            addResource(type, amount) {
                if (this.resources.hasOwnProperty(type)) {
                    const maxAmount = this.maxStorage[type];
                    const currentAmount = this.resources[type];
                    const addedAmount = Math.min(amount, maxAmount - currentAmount);
                    this.resources[type] += addedAmount;
                    return addedAmount;
                }
                return 0;
            }
            
            removeResource(type, amount) {
                if (this.resources.hasOwnProperty(type)) {
                    const currentAmount = this.resources[type];
                    const removedAmount = Math.min(amount, currentAmount);
                    this.resources[type] -= removedAmount;
                    return removedAmount;
                }
                return 0;
            }
            
            hasResources(requirements) {
                for (const [type, amount] of Object.entries(requirements)) {
                    if (!this.resources[type] || this.resources[type] < amount) {
                        return false;
                    }
                }
                return true;
            }
            
            consumeResources(requirements) {
                if (this.hasResources(requirements)) {
                    for (const [type, amount] of Object.entries(requirements)) {
                        this.resources[type] -= amount;
                    }
                    return true;
                }
                return false;
            }
        }
        
        class WorkerComponent {
            constructor() {
                this.workerId = Math.floor(Math.random() * 10000);
                this.name = `Worker ${this.workerId}`;
                this.job = 'unemployed'; // unemployed, farmer, builder, miner, etc.
                this.skill = 1; // 1-10 skill level
                this.experience = 0;
                this.productivity = 1.0; // Base productivity multiplier
                
                // Worker stats
                this.energy = 100; // 0-100, affects productivity
                this.maxEnergy = 100;
                this.happiness = 70; // 0-100
                this.loyalty = 60; // 0-100
                
                // Work assignment
                this.assignedBuilding = null; // Entity ID of assigned building
                this.workSchedule = {
                    startTime: 6, // 6 AM
                    endTime: 18,  // 6 PM
                    breakTime: 12 // Lunch break at noon
                };
                
                // Work state
                this.isWorking = false;
                this.lastWorkTime = Date.now();
                this.totalWorkTime = 0; // Total work time in seconds
                
                this.active = true;
            }
            
            assignToJob(jobType, buildingEntity = null) {
                this.job = jobType;
                this.assignedBuilding = buildingEntity ? buildingEntity.id : null;
                this.isWorking = jobType !== 'unemployed';
                return true;
            }
            
            work(deltaTime) {
                if (this.isWorking && this.energy > 10) {
                    // Simulate work energy consumption
                    this.energy -= deltaTime * 2; // Lose 2 energy per second
                    this.energy = Math.max(0, this.energy);
                    
                    // Gain experience
                    this.experience += deltaTime * 0.1;
                    
                    // Update skill level based on experience
                    const newSkill = Math.min(10, Math.floor(this.experience / 100) + 1);
                    if (newSkill > this.skill) {
                        this.skill = newSkill;
                        this.productivity = 1.0 + (this.skill - 1) * 0.1; // +10% per skill level
                    }
                    
                    this.totalWorkTime += deltaTime;
                    this.lastWorkTime = Date.now();
                    
                    return this.productivity;
                }
                return 0;
            }
            
            rest(deltaTime) {
                // Restore energy when not working
                if (!this.isWorking || this.energy <= 10) {
                    this.energy += deltaTime * 5; // Restore 5 energy per second
                    this.energy = Math.min(this.maxEnergy, this.energy);
                }
            }
        }
        
        class EconomyComponent {
            constructor() {
                this.tradingPosts = [];
                this.marketPrices = {
                    wood: 2,
                    stone: 3,
                    food: 1,
                    gold: 1, // Base currency
                    iron: 5,
                    tools: 10
                };
                
                // Market dynamics
                this.supply = {
                    wood: 100,
                    stone: 80,
                    food: 120,
                    iron: 30,
                    tools: 20
                };
                
                this.demand = {
                    wood: 80,
                    stone: 90,
                    food: 110,
                    iron: 40,
                    tools: 25
                };
                
                // Trade relationships
                this.tradeRoutes = [];
                this.reputation = 50; // 0-100, affects trade prices
                
                this.active = true;
            }
            
            updateMarketPrices() {
                // Simple supply/demand price calculation
                for (const resource in this.marketPrices) {
                    const supplyLevel = this.supply[resource] || 100;
                    const demandLevel = this.demand[resource] || 100;
                    const ratio = demandLevel / supplyLevel;
                    
                    // Adjust price based on supply/demand
                    this.marketPrices[resource] = Math.max(0.1, this.marketPrices[resource] * (0.95 + ratio * 0.1));
                }
            }
            
            trade(resource, amount, isBuying = true) {
                const price = this.marketPrices[resource] * amount;
                
                if (isBuying) {
                    this.supply[resource] = Math.max(0, this.supply[resource] - amount);
                    this.demand[resource] += amount * 0.1; // Buying increases future demand
                } else {
                    this.supply[resource] += amount;
                    this.demand[resource] = Math.max(0, this.demand[resource] - amount * 0.1);
                }
                
                return price;
            }
        }
        
        // ===== PHASE 5: ADVANCED GAMEPLAY SYSTEMS =====
        
        class QuestComponent {
            constructor() {
                this.questId = Math.random().toString(36).substr(2, 9);
                this.title = 'Sample Quest';
                this.description = 'Complete this quest objective';
                this.questType = 'kill'; // kill, collect, deliver, talk, explore
                
                // Quest status
                this.status = 'available'; // available, active, completed, failed
                this.startTime = null;
                this.completionTime = null;
                
                // Objectives system
                this.objectives = [
                    {
                        id: 'obj1',
                        description: 'Defeat 5 enemies',
                        type: 'kill',
                        target: 'enemy',
                        current: 0,
                        required: 5,
                        completed: false
                    }
                ];
                
                // Rewards
                this.rewards = {
                    experience: 100,
                    gold: 50,
                    items: [],
                    reputation: 10
                };
                
                // Quest dependencies
                this.prerequisites = []; // Quest IDs that must be completed first
                this.unlocks = []; // Quest IDs that this quest unlocks
                
                // NPC associations
                this.questGiver = null; // Entity ID of quest giver
                this.turnInNPC = null; // Entity ID to turn quest in to
                
                this.active = true;
            }
            
            addObjective(description, type, target, required) {
                const obj = {
                    id: 'obj' + (this.objectives.length + 1),
                    description,
                    type,
                    target,
                    current: 0,
                    required,
                    completed: false
                };
                this.objectives.push(obj);
                return obj;
            }
            
            updateObjective(objectiveId, progress) {
                const objective = this.objectives.find(obj => obj.id === objectiveId);
                if (objective) {
                    objective.current = Math.min(objective.current + progress, objective.required);
                    objective.completed = objective.current >= objective.required;
                    return objective.completed;
                }
                return false;
            }
            
            isCompleted() {
                return this.objectives.every(obj => obj.completed);
            }
        }
        
        class DialogueComponent {
            constructor() {
                this.characterName = 'Unknown NPC';
                this.currentDialogue = null;
                this.dialogueHistory = [];
                
                // Dialogue tree structure
                this.dialogueTree = {
                    root: {
                        id: 'start',
                        text: 'Hello, traveler!',
                        speaker: 'npc',
                        choices: [
                            {
                                text: 'Hello! How are you?',
                                next: 'friendly',
                                requirements: null,
                                consequence: { reputation: 1 }
                            },
                            {
                                text: 'I need information.',
                                next: 'business',
                                requirements: null,
                                consequence: null
                            }
                        ]
                    },
                    friendly: {
                        id: 'friendly',
                        text: 'I am well, thank you for asking!',
                        speaker: 'npc',
                        choices: [
                            {
                                text: 'Goodbye.',
                                next: 'end',
                                requirements: null,
                                consequence: null
                            }
                        ]
                    },
                    business: {
                        id: 'business',
                        text: 'What would you like to know?',
                        speaker: 'npc',
                        choices: [
                            {
                                text: 'Tell me about this place.',
                                next: 'location_info',
                                requirements: null,
                                consequence: null
                            }
                        ]
                    }
                };
                
                // Character relationships
                this.relationship = {
                    reputation: 50, // 0-100
                    trust: 50, // 0-100
                    fear: 0, // 0-100
                    friendship: 50 // 0-100
                };
                
                // Dialogue state
                this.lastInteraction = null;
                this.conversationCount = 0;
                
                this.active = true;
            }
            
            startDialogue(nodeId = 'start') {
                this.currentDialogue = this.dialogueTree.root;
                this.conversationCount++;
                this.lastInteraction = Date.now();
                return this.currentDialogue;
            }
            
            chooseOption(choiceIndex) {
                if (!this.currentDialogue || !this.currentDialogue.choices) return null;
                
                const choice = this.currentDialogue.choices[choiceIndex];
                if (!choice) return null;
                
                // Apply consequences
                if (choice.consequence) {
                    if (choice.consequence.reputation) {
                        this.relationship.reputation += choice.consequence.reputation;
                    }
                }
                
                // Move to next dialogue node
                if (choice.next === 'end') {
                    this.currentDialogue = null;
                    return null;
                }
                
                this.currentDialogue = this.dialogueTree[choice.next];
                this.dialogueHistory.push(choice.text);
                
                return this.currentDialogue;
            }
        }
        
        class NPCComponent {
            constructor() {
                this.npcType = 'villager'; // villager, merchant, guard, quest_giver, etc.
                this.name = 'Unnamed NPC';
                this.level = 1;
                
                // Advanced AI behavior
                this.personality = {
                    friendliness: Math.random() * 100,
                    helpfulness: Math.random() * 100,
                    aggressiveness: Math.random() * 100,
                    curiosity: Math.random() * 100
                };
                
                // Daily schedule
                this.schedule = [
                    { time: 6, activity: 'wake_up', location: 'home' },
                    { time: 8, activity: 'work', location: 'workplace' },
                    { time: 12, activity: 'lunch', location: 'tavern' },
                    { time: 13, activity: 'work', location: 'workplace' },
                    { time: 18, activity: 'socializing', location: 'town_square' },
                    { time: 22, activity: 'sleep', location: 'home' }
                ];
                
                this.currentActivity = null;
                this.activityStartTime = null;
                
                // Social interactions
                this.relationships = new Map(); // Entity ID -> relationship value
                this.socialGroup = 'villagers';
                this.reputation = 50; // 0-100 in community
                
                // Economic behavior
                this.profession = 'farmer'; // farmer, blacksmith, merchant, etc.
                this.skills = {
                    farming: Math.random() * 100,
                    crafting: Math.random() * 100,
                    trading: Math.random() * 100,
                    combat: Math.random() * 100
                };
                
                // Inventory and needs
                this.needs = {
                    food: 80,
                    shelter: 90,
                    safety: 70,
                    social: 60
                };
                
                this.active = true;
            }
            
            getCurrentActivity(gameTime) {
                const hour = Math.floor(gameTime / 3600) % 24; // Convert to hours in 24h format
                
                for (let i = this.schedule.length - 1; i >= 0; i--) {
                    if (hour >= this.schedule[i].time) {
                        return this.schedule[i];
                    }
                }
                return this.schedule[0]; // Default to first activity
            }
            
            updateNeeds(deltaTime) {
                // Simulate need decay over time
                this.needs.food -= deltaTime * 0.5;
                this.needs.shelter -= deltaTime * 0.1;
                this.needs.safety -= deltaTime * 0.2;
                this.needs.social -= deltaTime * 0.3;
                
                // Clamp values
                Object.keys(this.needs).forEach(need => {
                    this.needs[need] = Math.max(0, Math.min(100, this.needs[need]));
                });
            }
        }
        
        class EventComponent {
            constructor() {
                this.eventType = 'random'; // random, scripted, seasonal, triggered
                this.eventName = 'Strange Occurrence';
                this.description = 'Something unusual is happening...';
                
                // Event timing
                this.triggerTime = null;
                this.duration = 300; // 5 minutes in seconds
                this.startTime = null;
                this.endTime = null;
                
                // Event state
                this.status = 'pending'; // pending, active, completed, failed
                this.participants = []; // Entity IDs affected by event
                
                // Event effects
                this.effects = {
                    weatherChange: null, // sunny, rainy, stormy, etc.
                    resourceModifiers: {}, // Resource generation modifiers
                    moodModifiers: {}, // NPC mood changes
                    spawnEnemies: 0, // Number of enemies to spawn
                    questTriggers: [] // Quest IDs to activate
                };
                
                // Randomization
                this.randomEvents = [
                    {
                        name: 'Merchant Caravan',
                        description: 'A trading caravan has arrived!',
                        effects: { resourceModifiers: { gold: 1.5 } },
                        probability: 0.3
                    },
                    {
                        name: 'Heavy Rainfall',
                        description: 'The skies open and rain pours down.',
                        effects: { weatherChange: 'rainy', resourceModifiers: { food: 1.2 } },
                        probability: 0.4
                    },
                    {
                        name: 'Bandit Attack',
                        description: 'Bandits are threatening the village!',
                        effects: { spawnEnemies: 3, moodModifiers: { fear: 20 } },
                        probability: 0.2
                    }
                ];
                
                // Player choices and consequences
                this.playerChoices = [];
                this.consequences = [];
                
                this.active = true;
            }
            
            triggerRandomEvent() {
                const availableEvents = this.randomEvents.filter(event => 
                    Math.random() < event.probability
                );
                
                if (availableEvents.length > 0) {
                    const selectedEvent = availableEvents[Math.floor(Math.random() * availableEvents.length)];
                    this.eventName = selectedEvent.name;
                    this.description = selectedEvent.description;
                    this.effects = { ...this.effects, ...selectedEvent.effects };
                    this.status = 'active';
                    this.startTime = Date.now();
                    return selectedEvent;
                }
                return null;
            }
            
            processEvent(deltaTime, world) {
                if (this.status !== 'active') return;
                
                const elapsed = (Date.now() - this.startTime) / 1000;
                
                // Apply ongoing effects
                if (this.effects.resourceModifiers) {
                    // This would integrate with the resource system
                }
                
                // Check if event should end
                if (elapsed >= this.duration) {
                    this.status = 'completed';
                    this.endTime = Date.now();
                }
            }
        }
        
        // Attach Phase 3 components to window so they can be accessed globally
        window.PartyComponent = PartyComponent;
        window.CharacterComponent = CharacterComponent;
        window.AIComponent = AIComponent;
        window.CombatComponent = CombatComponent;
        window.InventoryComponent = InventoryComponent;
        
        // Attach Phase 4 components to window
        window.VillageComponent = VillageComponent;
        window.BuildingComponent = BuildingComponent;
        window.ResourceComponent = ResourceComponent;
        window.WorkerComponent = WorkerComponent;
        window.EconomyComponent = EconomyComponent;
        
        // Attach Phase 5 components to window
        window.QuestComponent = QuestComponent;
        window.DialogueComponent = DialogueComponent;
        window.NPCComponent = NPCComponent;
        window.EventComponent = EventComponent;
        
        console.log('‚úÖ Phase 3 components attached to window');
        console.log('‚úÖ Phase 4 components attached to window');
        console.log('‚úÖ Phase 5 components attached to window');
        
        // Global state
        let scene, camera, renderer, world;
        let lastTime = Date.now();
        let selectedEntity = null;
        let raycaster, mouse;
        
        // Component loading state
        let phase2ComponentsLoaded = false;
        let queryTestCount = 0;
        let lastInspectorUpdate = 0;
        
        // Inspector dragging state
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        
        
        
        function init() {
            // Verify Phase 3 components are available at init time
            console.log('  PartyComponent:', !!window.PartyComponent);
            console.log('  CharacterComponent:', !!window.CharacterComponent);
            console.log('  AIComponent:', !!window.AIComponent);
            console.log('  CombatComponent:', !!window.CombatComponent);
            console.log('  InventoryComponent:', !!window.InventoryComponent);
            
            // Initialize Three.js
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2c3e50);
            
            // Create dimetric camera (orthographic projection with 2:1 tile ratio)
            const frustumSize = 20;
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.OrthographicCamera(
                frustumSize * aspect / -2, frustumSize * aspect / 2,
                frustumSize / 2, frustumSize / -2,
                0.1, 1000
            );
            
            // Position for dimetric view (26.57¬∞ elevation, 45¬∞ azimuth for 2:1 tile ratio)
            const elevation = 26.57 * Math.PI / 180; // 26.57 degrees
            const azimuth = 45 * Math.PI / 180; // 45 degrees
            const distance = 20;
            
            camera.position.set(
                Math.cos(elevation) * Math.sin(azimuth) * distance,
                Math.sin(elevation) * distance,
                Math.cos(elevation) * Math.cos(azimuth) * distance
            );
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Create ground
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(25, 25),
                new THREE.MeshLambertMaterial({ color: 0x34495e })
            );
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Initialize raycaster for mouse picking
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Add mouse event listeners
            renderer.domElement.addEventListener('click', onMouseClick);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            
            // Initialize inspector dragging
            initInspectorDragging();
            
            // Initialize inspector resize observer
            initInspectorResize();
            
            // Initialize UI dragging
            initUIDragging();
            
            // Initialize ECS
            world = new World();
            
            // Load saved panel positions
            loadPanelPositions();
            
            // Load Phase 2 components (physics & animation) at startup
            loadPhase2Components(() => {
                console.log('‚úÖ Phase 2 components are now available in the ECS inspector');
                
                // Load Phase 3 components (party & character systems)
                loadPhase3Components(() => {
                    console.log('‚úÖ Phase 3 components are now available in the ECS inspector');
                    
                    // Create initial entities AFTER all components are loaded
                    console.log('üéØ Creating initial entities with all components...');
                    for (let i = 0; i < 5; i++) {
                        createEntity();
                    }
                    
                    console.log('ECS Demo initialized with', world.entities.length, 'entities with all components');
                });
            });
            
            // Start game loop immediately
            animate();
            updateStatus();
        }
        
        function createEntity() {
            const entity = world.createEntity();
            
            // Add Transform component
            const transform = new Transform(
                (Math.random() - 0.5) * 10,
                Math.random() * 3 + 1,
                (Math.random() - 0.5) * 10
            );
            entity.addComponent(transform);
            
            // Add Renderable component
            const geometry = Math.random() > 0.5 ? 
                new THREE.BoxGeometry(1, 1, 1) : 
                new THREE.SphereGeometry(0.5, 12, 8);
            const material = new THREE.MeshLambertMaterial({ 
                color: Math.random() * 0xffffff 
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            entity.addComponent(new Renderable(mesh));
            
            // Store entity reference on mesh for picking
            mesh.userData.entity = entity;
            
            scene.add(mesh);
            
            // Add all available components by default
            
            // Add Movement component
            const movement = new Movement();
            movement.velocity = {
                x: (Math.random() - 0.5) * 4,
                y: (Math.random() - 0.5) * 2,
                z: (Math.random() - 0.5) * 4
            };
            entity.addComponent(movement);
            
            // Add Health component
            entity.addComponent(new Health());
            
            // Add Lifetime component
            entity.addComponent(new Lifetime(Math.random() * 10 + 5));
            
            // Add VisualComponent for styling control
            entity.addComponent(new VisualComponent());
            
            // Add physics components if available
            if (phase2ComponentsLoaded) {
                // Add RigidbodyComponent
                const rigidbody = new window.RigidbodyComponent();
                rigidbody.mass = 1;
                rigidbody.useGravity = true;
                rigidbody.velocity = new THREE.Vector3((Math.random() - 0.5) * 2, 0, (Math.random() - 0.5) * 2);
                entity.addComponent(rigidbody);
                
                // Add appropriate collider based on geometry
                if (geometry instanceof THREE.SphereGeometry) {
                    const collider = new window.SphereColliderComponent();
                    collider.setRadius(0.5);
                    entity.addComponent(collider);
                } else {
                    const collider = new window.BoxColliderComponent();
                    collider.setSize(1, 1, 1);
                    entity.addComponent(collider);
                }
                
                // Add TweenComponent 
                const tween = new window.TweenComponent();
                entity.addComponent(tween);
                
                // Add AnimatorComponent
                const animator = new window.AnimatorComponent();
                entity.addComponent(animator);
                
                // Add Phase 3 components if available
                console.log('üîç Checking Phase 3 components availability:', {
                    PartyComponent: !!window.PartyComponent,
                    CharacterComponent: !!window.CharacterComponent,
                    AIComponent: !!window.AIComponent,
                    CombatComponent: !!window.CombatComponent,
                    InventoryComponent: !!window.InventoryComponent
                });
                
                if (window.PartyComponent) {
                    const party = new window.PartyComponent();
                    party.addMember(entity.id);
                    entity.addComponent(party);
                } else {
                    console.log('‚ùå PartyComponent not available');
                }
                
                if (window.CharacterComponent) {
                    const character = new window.CharacterComponent();
                    character.name = `Hero ${entity.id}`;
                    character.level = Math.floor(Math.random() * 5) + 1;
                    entity.addComponent(character);
                }
                
                if (window.AIComponent) {
                    const ai = new window.AIComponent();
                    const behaviors = ['follow', 'guard', 'patrol', 'aggressive'];
                    ai.behaviorType = behaviors[Math.floor(Math.random() * behaviors.length)];
                    entity.addComponent(ai);
                }
                
                if (window.CombatComponent) {
                    const combat = new window.CombatComponent();
                    combat.attackPower = Math.floor(Math.random() * 20) + 10;
                    entity.addComponent(combat);
                }
                
                if (window.InventoryComponent) {
                    const inventory = new window.InventoryComponent();
                    inventory.currency = Math.floor(Math.random() * 100);
                    entity.addComponent(inventory);
                }
                
                // Add Phase 4 components if available
                if (window.VillageComponent) {
                    const village = new window.VillageComponent();
                    village.name = `Village ${entity.id}`;
                    village.population = Math.floor(Math.random() * 20) + 5;
                    entity.addComponent(village);
                }
                
                if (window.BuildingComponent) {
                    const building = new window.BuildingComponent();
                    const buildingTypes = ['house', 'farm', 'workshop', 'storage', 'barracks'];
                    building.buildingType = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
                    building.level = Math.floor(Math.random() * 3) + 1;
                    entity.addComponent(building);
                }
                
                if (window.ResourceComponent) {
                    const resource = new window.ResourceComponent();
                    // Randomize starting resources
                    resource.resources.wood = Math.floor(Math.random() * 100) + 20;
                    resource.resources.stone = Math.floor(Math.random() * 80) + 10;
                    resource.resources.food = Math.floor(Math.random() * 60) + 30;
                    entity.addComponent(resource);
                }
                
                if (window.WorkerComponent) {
                    const worker = new window.WorkerComponent();
                    const jobs = ['farmer', 'builder', 'miner', 'soldier', 'merchant'];
                    worker.job = jobs[Math.floor(Math.random() * jobs.length)];
                    worker.skill = Math.floor(Math.random() * 5) + 1;
                    entity.addComponent(worker);
                }
                
                if (window.EconomyComponent) {
                    const economy = new window.EconomyComponent();
                    economy.reputation = Math.floor(Math.random() * 50) + 25;
                    entity.addComponent(economy);
                }
                
                // Phase 5 components
                if (window.QuestComponent) {
                    const quest = new window.QuestComponent();
                    const questTypes = ['kill', 'collect', 'deliver', 'talk', 'explore'];
                    quest.questType = questTypes[Math.floor(Math.random() * questTypes.length)];
                    quest.title = `${quest.questType.charAt(0).toUpperCase() + quest.questType.slice(1)} Quest`;
                    entity.addComponent(quest);
                }
                
                if (window.DialogueComponent) {
                    const dialogue = new window.DialogueComponent();
                    const names = ['Elder Smith', 'Merchant Joe', 'Guard Captain', 'Village Chief', 'Wise Oracle'];
                    dialogue.characterName = names[Math.floor(Math.random() * names.length)];
                    entity.addComponent(dialogue);
                }
                
                if (window.NPCComponent) {
                    const npc = new window.NPCComponent();
                    const types = ['villager', 'merchant', 'guard', 'quest_giver', 'farmer'];
                    npc.npcType = types[Math.floor(Math.random() * types.length)];
                    npc.name = `NPC_${Math.floor(Math.random() * 1000)}`;
                    entity.addComponent(npc);
                }
                
                if (window.EventComponent) {
                    const event = new window.EventComponent();
                    const eventTypes = ['random', 'scripted', 'seasonal', 'triggered'];
                    event.eventType = eventTypes[Math.floor(Math.random() * eventTypes.length)];
                    entity.addComponent(event);
                }
                
                console.log('‚úÖ Created entity with all components including physics, Phases 3, 4, and 5!');
            } else {
                // Add Phase 3 components even if physics components aren't loaded yet
                console.log('üîç Checking Phase 3 components availability (no physics):', {
                    PartyComponent: !!window.PartyComponent,
                    CharacterComponent: !!window.CharacterComponent,
                    AIComponent: !!window.AIComponent,
                    CombatComponent: !!window.CombatComponent,
                    InventoryComponent: !!window.InventoryComponent
                });
                
                if (window.PartyComponent) {
                    const party = new window.PartyComponent();
                    party.addMember(entity.id);
                    entity.addComponent(party);
                } else {
                    console.log('‚ùå PartyComponent not available (no physics)');
                }
                
                if (window.CharacterComponent) {
                    const character = new window.CharacterComponent();
                    character.name = `Hero ${entity.id}`;
                    character.level = Math.floor(Math.random() * 5) + 1;
                    entity.addComponent(character);
                }
                
                if (window.AIComponent) {
                    const ai = new window.AIComponent();
                    const behaviors = ['follow', 'guard', 'patrol', 'aggressive'];
                    ai.behaviorType = behaviors[Math.floor(Math.random() * behaviors.length)];
                    entity.addComponent(ai);
                }
                
                if (window.CombatComponent) {
                    const combat = new window.CombatComponent();
                    combat.attackPower = Math.floor(Math.random() * 20) + 10;
                    entity.addComponent(combat);
                }
                
                if (window.InventoryComponent) {
                    const inventory = new window.InventoryComponent();
                    inventory.currency = Math.floor(Math.random() * 100);
                    entity.addComponent(inventory);
                }
                
                // Add Phase 4 components even if physics components aren't loaded yet
                if (window.VillageComponent) {
                    const village = new window.VillageComponent();
                    village.name = `Village ${entity.id}`;
                    village.population = Math.floor(Math.random() * 20) + 5;
                    entity.addComponent(village);
                }
                
                if (window.BuildingComponent) {
                    const building = new window.BuildingComponent();
                    const buildingTypes = ['house', 'farm', 'workshop', 'storage', 'barracks'];
                    building.buildingType = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
                    building.level = Math.floor(Math.random() * 3) + 1;
                    entity.addComponent(building);
                }
                
                if (window.ResourceComponent) {
                    const resource = new window.ResourceComponent();
                    // Randomize starting resources
                    resource.resources.wood = Math.floor(Math.random() * 100) + 20;
                    resource.resources.stone = Math.floor(Math.random() * 80) + 10;
                    resource.resources.food = Math.floor(Math.random() * 60) + 30;
                    entity.addComponent(resource);
                }
                
                if (window.WorkerComponent) {
                    const worker = new window.WorkerComponent();
                    const jobs = ['farmer', 'builder', 'miner', 'soldier', 'merchant'];
                    worker.job = jobs[Math.floor(Math.random() * jobs.length)];
                    worker.skill = Math.floor(Math.random() * 5) + 1;
                    entity.addComponent(worker);
                }
                
                if (window.EconomyComponent) {
                    const economy = new window.EconomyComponent();
                    economy.reputation = Math.floor(Math.random() * 50) + 25;
                    entity.addComponent(economy);
                }
                
                // Phase 5 components (no physics)
                if (window.QuestComponent) {
                    const quest = new window.QuestComponent();
                    const questTypes = ['kill', 'collect', 'deliver', 'talk', 'explore'];
                    quest.questType = questTypes[Math.floor(Math.random() * questTypes.length)];
                    quest.title = `${quest.questType.charAt(0).toUpperCase() + quest.questType.slice(1)} Quest`;
                    entity.addComponent(quest);
                }
                
                if (window.DialogueComponent) {
                    const dialogue = new window.DialogueComponent();
                    const names = ['Elder Smith', 'Merchant Joe', 'Guard Captain', 'Village Chief', 'Wise Oracle'];
                    dialogue.characterName = names[Math.floor(Math.random() * names.length)];
                    entity.addComponent(dialogue);
                }
                
                if (window.NPCComponent) {
                    const npc = new window.NPCComponent();
                    const types = ['villager', 'merchant', 'guard', 'quest_giver', 'farmer'];
                    npc.npcType = types[Math.floor(Math.random() * types.length)];
                    npc.name = `NPC_${Math.floor(Math.random() * 1000)}`;
                    entity.addComponent(npc);
                }
                
                if (window.EventComponent) {
                    const event = new window.EventComponent();
                    const eventTypes = ['random', 'scripted', 'seasonal', 'triggered'];
                    event.eventType = eventTypes[Math.floor(Math.random() * eventTypes.length)];
                    entity.addComponent(event);
                }
                
                console.log('‚úÖ Created entity with basic components, Phases 3, 4, and 5 components (physics components loading...)');
            }
            
            updateStatus();
            return entity;
        }
        
        function addComponentToEntity(entity) {
            const componentTypes = ['Movement', 'Health', 'Lifetime', 'RigidbodyComponent', 'BoxColliderComponent', 'SphereColliderComponent', 'TweenComponent', 'AnimatorComponent', 'VisualComponent', 'PartyComponent', 'CharacterComponent', 'AIComponent', 'CombatComponent', 'InventoryComponent', 'VillageComponent', 'BuildingComponent', 'ResourceComponent', 'WorkerComponent', 'EconomyComponent'];
            const availableTypes = componentTypes.filter(type => !entity.hasComponent(type));
            
            if (availableTypes.length === 0) {
                console.log(`‚ö†Ô∏è Entity ${entity.id} already has all possible components`);
                return;
            }
            
            const randomType = availableTypes[Math.floor(Math.random() * availableTypes.length)];
            
            let component;
            switch(randomType) {
                case 'Movement':
                    component = new Movement();
                    component.velocity = {
                        x: (Math.random() - 0.5) * 4,
                        y: (Math.random() - 0.5) * 2,
                        z: (Math.random() - 0.5) * 4
                    };
                    break;
                case 'Health':
                    component = new Health();
                    break;
                case 'Lifetime':
                    component = new Lifetime(Math.random() * 10 + 5);
                    break;
                case 'RigidbodyComponent':
                    component = new window.RigidbodyComponent();
                    component.mass = 1;
                    component.useGravity = true;
                    component.velocity = new THREE.Vector3(0, 0, 0);
                    console.log('üî¨ Added physics rigidbody component');
                    break;
                case 'BoxColliderComponent':
                    component = new window.BoxColliderComponent();
                    component.setSize(2, 2, 2);
                    console.log('üì¶ Added box collider component');
                    break;
                case 'SphereColliderComponent':
                    component = new window.SphereColliderComponent();
                    component.setRadius(1);
                    console.log('‚ö™ Added sphere collider component');
                    break;
                case 'TweenComponent':
                    component = new window.TweenComponent();
                    console.log('üé¨ Added tween animation component');
                    break;
                case 'AnimatorComponent':
                    component = new window.AnimatorComponent();
                    console.log('üé≠ Added animator component');
                    break;
                case 'VisualComponent':
                    component = new VisualComponent();
                    console.log('üé® Added visual styling component');
                    break;
                case 'PartyComponent':
                    component = new PartyComponent();
                    // Auto-add this entity to the party
                    component.addMember(entity.id);
                    console.log('üë• Added party management component');
                    break;
                case 'CharacterComponent':
                    component = new CharacterComponent();
                    component.name = `Hero ${entity.id}`;
                    component.level = Math.floor(Math.random() * 5) + 1;
                    console.log('‚öîÔ∏è Added character stats component');
                    break;
                case 'AIComponent':
                    component = new AIComponent();
                    const behaviors = ['follow', 'guard', 'patrol', 'aggressive'];
                    component.behaviorType = behaviors[Math.floor(Math.random() * behaviors.length)];
                    console.log(`ü§ñ Added AI component (${component.behaviorType})`);
                    break;
                case 'CombatComponent':
                    component = new CombatComponent();
                    component.attackPower = Math.floor(Math.random() * 20) + 10;
                    console.log('‚öîÔ∏è Added combat component');
                    break;
                case 'InventoryComponent':
                    component = new InventoryComponent();
                    component.currency = Math.floor(Math.random() * 100);
                    console.log('üéí Added inventory component');
                    break;
                case 'VillageComponent':
                    component = new VillageComponent();
                    component.name = `Village ${entity.id}`;
                    component.population = Math.floor(Math.random() * 30) + 5;
                    console.log('üèòÔ∏è Added village component');
                    break;
                case 'BuildingComponent':
                    component = new BuildingComponent();
                    const buildingTypes = ['house', 'farm', 'workshop', 'storage', 'barracks'];
                    component.buildingType = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
                    component.level = Math.floor(Math.random() * 3) + 1;
                    console.log('üèóÔ∏è Added building component');
                    break;
                case 'ResourceComponent':
                    component = new ResourceComponent();
                    component.resources.wood = Math.floor(Math.random() * 100) + 20;
                    component.resources.stone = Math.floor(Math.random() * 80) + 10;
                    component.resources.food = Math.floor(Math.random() * 60) + 30;
                    console.log('üì¶ Added resource component');
                    break;
                case 'WorkerComponent':
                    component = new WorkerComponent();
                    const jobs = ['farmer', 'builder', 'miner', 'soldier', 'merchant'];
                    component.job = jobs[Math.floor(Math.random() * jobs.length)];
                    component.skill = Math.floor(Math.random() * 5) + 1;
                    console.log('üë∑ Added worker component');
                    break;
                case 'EconomyComponent':
                    component = new EconomyComponent();
                    component.reputation = Math.floor(Math.random() * 50) + 25;
                    console.log('üí∞ Added economy component');
                    break;
            }
            
            entity.addComponent(component);
            console.log(`‚úÖ Added ${randomType} to entity ${entity.id}`);
            updateStatus();
        }
        
        function removeComponentFromEntity(entity) {
            const componentTypes = Array.from(entity.components.keys());
            const removableTypes = componentTypes.filter(type => 
                type !== 'Transform' && type !== 'Renderable'
            );
            
            if (removableTypes.length === 0) {
                console.log(`‚ö†Ô∏è Entity ${entity.id} has no removable components`);
                return;
            }
            
            const typeToRemove = removableTypes[Math.floor(Math.random() * removableTypes.length)];
            entity.removeComponent(typeToRemove);
            console.log(`üóëÔ∏è Removed ${typeToRemove} from entity ${entity.id}`);
            updateStatus();
        }
        
        function destroyEntity(entity) {
            // Always clean up visualization helpers for this entity
            removeColliderVisualization(entity);
            
            // Clear selection if this entity is currently selected
            if (selectedEntity && selectedEntity.id === entity.id) {
                selectEntity(null); // This will clear selection properly
            }
            
            world.destroyEntity(entity);
            console.log(`üí• Destroyed entity ${entity.id}`);
            updateStatus();
        }
        
        
        function queryEntities() {
            const queries = [
                ['Transform'],
                ['Transform', 'Movement'],
                ['Transform', 'Health'],
                ['Movement', 'Health'],
                ['Transform', 'Renderable', 'Movement']
            ];
            
            queries.forEach(componentTypes => {
                const result = world.query(componentTypes);
                console.log(`Query [${componentTypes.join(', ')}]: ${result.length} entities`);
            });
            
            queryTestCount++;
            updateStatus();
        }
        
        function stressTest() {
            console.log('Running stress test...');
            const start = performance.now();
            
            // Create 100 entities
            for (let i = 0; i < 100; i++) {
                createEntity();
            }
            
            // Run systems 10 times
            for (let i = 0; i < 10; i++) {
                world.update(0.016);
            }
            
            // Perform queries
            for (let i = 0; i < 50; i++) {
                world.query(['Transform', 'Movement']);
            }
            
            const end = performance.now();
            console.log(`Stress test completed in ${(end - start).toFixed(2)}ms`);
            document.getElementById('performance').textContent = `Stress: ${(end - start).toFixed(2)}ms`;
            updateStatus();
        }
        
        
        function clearAll() {
            // Clear selection first
            selectEntity(null);
            
            while (world.entities.length > 0) {
                world.destroyEntity(world.entities[0]);
            }
            console.log('Cleared all entities');
            updateStatus();
        }
        
        function updateStatus() {
            const stats = world.getStats();
            document.getElementById('entityCount').textContent = stats.entities;
            document.getElementById('componentCount').textContent = stats.components;
            document.getElementById('systemCount').textContent = stats.systems;
            document.getElementById('queryCount').textContent = queryTestCount;
            updateInspector();
        }
        
        
        function onMouseMove(event) {
            // Update mouse position for hover effects
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Update raycaster
            raycaster.setFromCamera(mouse, camera);
            
            // Find intersected objects
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            // Reset all mesh colors first
            world.entities.forEach(entity => {
                const renderable = entity.getComponent('Renderable');
                if (renderable && renderable.mesh && renderable.mesh.userData.entity) {
                    if (selectedEntity && selectedEntity.id === entity.id) {
                        // Keep selected entity highlighted
                        renderable.mesh.material.emissive.setHex(0x004400);
                    } else {
                        // Normal color
                        renderable.mesh.material.emissive.setHex(0x000000);
                    }
                }
            });
            
            // Highlight hovered object
            if (intersects.length > 0) {
                const mesh = intersects[0].object;
                if (mesh.userData.entity && (!selectedEntity || selectedEntity.id !== mesh.userData.entity.id)) {
                    mesh.material.emissive.setHex(0x222222);
                }
                renderer.domElement.style.cursor = 'pointer';
            } else {
                renderer.domElement.style.cursor = 'default';
            }
        }
        
        function onMouseClick(event) {
            // Update mouse position
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Update raycaster
            raycaster.setFromCamera(mouse, camera);
            
            // Find intersected objects
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            if (intersects.length > 0) {
                const mesh = intersects[0].object;
                if (mesh.userData.entity) {
                    console.log(`üéØ Viewport click - selecting entity ${mesh.userData.entity.id}`);
                    selectEntity(mesh.userData.entity);
                }
            } else {
                // Clicked on empty space, deselect
                console.log('üéØ Viewport click - deselecting');
                selectEntity(null);
            }
        }
        
        function selectEntity(entity) {
            console.log(`üîÑ selectEntity called with: ${entity ? `entity ${entity.id}` : 'null'}`);
            
            // Clear previous selection highlight
            if (selectedEntity) {
                const prevRenderable = selectedEntity.getComponent('Renderable');
                if (prevRenderable && prevRenderable.mesh) {
                    prevRenderable.mesh.material.emissive.setHex(0x000000);
                }
                
                // Remove collider visualization from previous selection
                removeColliderVisualization(selectedEntity);
            }
            
            selectedEntity = entity;
            
            // Highlight new selection with emissive glow
            if (selectedEntity) {
                const renderable = selectedEntity.getComponent('Renderable');
                if (renderable && renderable.mesh) {
                    // Add emissive glow for selection feedback
                    renderable.mesh.material.emissive.setHex(0x004400);
                }
                
                // Add collider visualization (replaces wireframe)
                addColliderVisualization(selectedEntity);
            }
            
            updateSelectionUI();
            updateInspector(); // This will update the inspector to show the selected state
        }
        
        function updateSelectionUI() {
            const selectionInfo = document.getElementById('selectionInfo');
            
            if (selectionInfo) {
                if (selectedEntity) {
                    const componentTypes = Array.from(selectedEntity.components.keys());
                    const activeCount = componentTypes.filter(type => {
                        const component = selectedEntity.getComponent(type);
                        return component.active !== false;
                    }).length;
                    
                    selectionInfo.innerHTML = `
                        <strong>Selected:</strong> Entity ${selectedEntity.id}<br>
                        <span style="font-size: 10px;">
                            ${componentTypes.length} components, ${activeCount} active
                        </span>
                    `;
                    selectionInfo.style.color = '#4CAF50';
                } else {
                    selectionInfo.textContent = 'Click an entity to select it. Click components to toggle on/off.';
                    selectionInfo.style.color = '#888';
                }
            }
        }
        
        function initInspectorDragging() {
            const inspector = document.getElementById('inspector');
            const header = document.getElementById('inspector-header');
            
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                inspector.classList.add('dragging');
                
                const rect = inspector.getBoundingClientRect();
                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;
                
                document.addEventListener('mousemove', onDrag);
                document.addEventListener('mouseup', onDragEnd);
                
                e.preventDefault();
            });
            
            function onDrag(e) {
                if (!isDragging) return;
                
                const newX = e.clientX - dragOffset.x;
                const newY = e.clientY - dragOffset.y;
                
                // Keep inspector within viewport bounds
                const maxX = window.innerWidth - inspector.offsetWidth;
                const maxY = window.innerHeight - inspector.offsetHeight;
                
                const clampedX = Math.max(0, Math.min(newX, maxX));
                const clampedY = Math.max(0, Math.min(newY, maxY));
                
                inspector.style.left = clampedX + 'px';
                inspector.style.top = clampedY + 'px';
                inspector.style.right = 'auto'; // Remove right positioning
                
                e.preventDefault();
            }
            
            function onDragEnd() {
                isDragging = false;
                inspector.classList.remove('dragging');
                document.removeEventListener('mousemove', onDrag);
                document.removeEventListener('mouseup', onDragEnd);
                
                // Save inspector position
                saveInspectorPosition();
            }
        }
        
        function initInspectorResize() {
            const inspector = document.getElementById('inspector');
            let resizeTimeout;
            
            // Use ResizeObserver to detect when inspector is resized
            if (window.ResizeObserver) {
                const resizeObserver = new ResizeObserver(entries => {
                    // Debounce the save operation
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        saveInspectorScale();
                    }, 100);
                });
                
                resizeObserver.observe(inspector);
            } else {
                // Fallback for older browsers - use window resize event
                let lastWidth = inspector.offsetWidth;
                let lastHeight = inspector.offsetHeight;
                
                window.addEventListener('resize', () => {
                    const currentWidth = inspector.offsetWidth;
                    const currentHeight = inspector.offsetHeight;
                    
                    if (currentWidth !== lastWidth || currentHeight !== lastHeight) {
                        clearTimeout(resizeTimeout);
                        resizeTimeout = setTimeout(() => {
                            saveInspectorScale();
                        }, 100);
                        
                        lastWidth = currentWidth;
                        lastHeight = currentHeight;
                    }
                });
            }
        }
        
        function initUIDragging() {
            const ui = document.getElementById('ui');
            const header = document.getElementById('ui-header');
            let isDraggingUI = false;
            let uiDragOffset = { x: 0, y: 0 };
            
            header.addEventListener('mousedown', (e) => {
                isDraggingUI = true;
                ui.classList.add('dragging');
                
                const rect = ui.getBoundingClientRect();
                uiDragOffset.x = e.clientX - rect.left;
                uiDragOffset.y = e.clientY - rect.top;
                
                document.addEventListener('mousemove', onUIDrag);
                document.addEventListener('mouseup', onUIDragEnd);
                
                e.preventDefault();
            });
            
            function onUIDrag(e) {
                if (!isDraggingUI) return;
                
                const newX = e.clientX - uiDragOffset.x;
                const newY = e.clientY - uiDragOffset.y;
                
                // Keep UI within viewport bounds
                const maxX = window.innerWidth - ui.offsetWidth;
                const maxY = window.innerHeight - ui.offsetHeight;
                
                const clampedX = Math.max(0, Math.min(newX, maxX));
                const clampedY = Math.max(0, Math.min(newY, maxY));
                
                ui.style.left = clampedX + 'px';
                ui.style.top = clampedY + 'px';
                
                e.preventDefault();
            }
            
            function onUIDragEnd() {
                isDraggingUI = false;
                ui.classList.remove('dragging');
                document.removeEventListener('mousemove', onUIDrag);
                document.removeEventListener('mouseup', onUIDragEnd);
                
                // Save UI position
                saveUIPosition();
            }
        }
        
        function saveUIPosition() {
            const ui = document.getElementById('ui');
            const position = {
                left: ui.style.left || '10px',
                top: ui.style.top || '10px'
            };
            localStorage.setItem('ecsUI_position', JSON.stringify(position));
        }
        
        function saveInspectorPosition() {
            const inspector = document.getElementById('inspector');
            const position = {
                left: inspector.style.left || 'auto',
                top: inspector.style.top || '10px',
                right: inspector.style.right || '10px',
                width: inspector.style.width || '320px',
                height: inspector.style.height || '400px'
            };
            localStorage.setItem('ecsInspector_position', JSON.stringify(position));
        }
        
        function saveInspectorScale() {
            const inspector = document.getElementById('inspector');
            const scale = {
                width: inspector.offsetWidth + 'px',
                height: inspector.offsetHeight + 'px'
            };
            localStorage.setItem('ecsInspector_scale', JSON.stringify(scale));
        }
        
        function loadPanelPositions() {
            // Load UI position
            const uiPosition = localStorage.getItem('ecsUI_position');
            if (uiPosition) {
                try {
                    const pos = JSON.parse(uiPosition);
                    const ui = document.getElementById('ui');
                    ui.style.left = pos.left;
                    ui.style.top = pos.top;
                } catch (e) {
                    console.log('Failed to load UI position:', e);
                }
            }
            
            // Load Inspector position
            const inspectorPosition = localStorage.getItem('ecsInspector_position');
            if (inspectorPosition) {
                try {
                    const pos = JSON.parse(inspectorPosition);
                    const inspector = document.getElementById('inspector');
                    
                    // Apply position
                    if (pos.left !== 'auto') {
                        inspector.style.left = pos.left;
                        inspector.style.right = 'auto';
                    } else {
                        inspector.style.right = pos.right;
                    }
                    inspector.style.top = pos.top;
                    inspector.style.width = pos.width;
                    inspector.style.height = pos.height;
                } catch (e) {
                    console.log('Failed to load Inspector position:', e);
                }
            }
            
            // Load Inspector scale
            const inspectorScale = localStorage.getItem('ecsInspector_scale');
            if (inspectorScale) {
                try {
                    const scale = JSON.parse(inspectorScale);
                    const inspector = document.getElementById('inspector');
                    inspector.style.width = scale.width;
                    inspector.style.height = scale.height;
                } catch (e) {
                    console.log('Failed to load Inspector scale:', e);
                }
            }
        }
        
        function updateInspector() {
            // Validate that selected entity still exists
            if (selectedEntity && !world.entities.find(e => e.id === selectedEntity.id)) {
                selectedEntity = null; // Clear selection if entity no longer exists
            }
            
            const entityList = document.getElementById('entityList');
            entityList.innerHTML = '';
            
            console.log(`üîÑ Updating inspector, selected entity: ${selectedEntity ? selectedEntity.id : 'none'}`);
            
            // Show ALL entities, not just first 10
            world.entities.forEach(entity => {
                const card = document.createElement('div');
                card.className = 'entity-card';
                
                // Check if this entity is selected and apply style directly
                const isSelected = selectedEntity && selectedEntity.id === entity.id;
                if (isSelected) {
                    card.style.setProperty('background', 'rgba(76,175,80,0.5)', 'important');
                    card.style.setProperty('border', '2px solid #4CAF50', 'important');
                    card.style.setProperty('box-shadow', '0 0 8px rgba(76,175,80,0.6)', 'important');
                    card.style.setProperty('opacity', '1', 'important');
                    card.classList.add('selected');
                } else {
                    card.style.setProperty('background', 'rgba(255,255,255,0.1)', 'important');
                    card.style.setProperty('border', 'none', 'important');
                    card.style.setProperty('box-shadow', 'none', 'important');
                    card.style.setProperty('opacity', '0.6', 'important');
                    card.classList.remove('selected');
                }
                
                // Create header with entity name and buttons
                const header = document.createElement('div');
                header.className = 'entity-header';
                
                const entityName = document.createElement('strong');
                entityName.innerHTML = `<i data-lucide="box" style="width: 18px; height: 18px; vertical-align: text-bottom; margin-right: 6px;"></i>Entity ${entity.id}`;
                entityName.style.cursor = 'pointer';
                entityName.style.zIndex = '10';
                entityName.style.position = 'relative';
                
                // Add direct click handler to entity name
                entityName.addEventListener('click', (e) => {
                    console.log(`üñ±Ô∏è Entity name clicked for entity ${entity.id}`);
                    selectEntity(entity);
                    e.stopPropagation();
                });
                
                const buttonContainer = document.createElement('div');
                buttonContainer.className = 'entity-buttons';
                
                // Add Component button
                const addBtn = document.createElement('button');
                addBtn.className = 'entity-btn';
                addBtn.innerHTML = '<i data-lucide="plus" style="width: 14px; height: 14px;"></i>';
                addBtn.title = 'Add Component';
                
                const componentTypes = ['Movement', 'Health', 'Lifetime', 'RigidbodyComponent', 'BoxColliderComponent', 'SphereColliderComponent', 'TweenComponent', 'AnimatorComponent', 'VisualComponent', 'PartyComponent', 'CharacterComponent', 'AIComponent', 'CombatComponent', 'InventoryComponent', 'VillageComponent', 'BuildingComponent', 'ResourceComponent', 'WorkerComponent', 'EconomyComponent'];
                const availableTypes = componentTypes.filter(type => !entity.hasComponent(type));
                addBtn.disabled = availableTypes.length === 0;
                
                addBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    addComponentToEntity(entity);
                });
                
                // Remove Component button
                const removeBtn = document.createElement('button');
                removeBtn.className = 'entity-btn remove';
                removeBtn.innerHTML = '<i data-lucide="minus" style="width: 14px; height: 14px;"></i>';
                removeBtn.title = 'Remove Component';
                
                const componentKeys = Array.from(entity.components.keys());
                const removableTypes = componentKeys.filter(type => 
                    type !== 'Transform' && type !== 'Renderable'
                );
                removeBtn.disabled = removableTypes.length === 0;
                
                removeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    removeComponentFromEntity(entity);
                });
                
                // Destroy Entity button
                const destroyBtn = document.createElement('button');
                destroyBtn.className = 'entity-btn destroy';
                destroyBtn.innerHTML = '<i data-lucide="trash-2" style="width: 14px; height: 14px;"></i>';
                destroyBtn.title = 'Destroy Entity';
                
                destroyBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    destroyEntity(entity);
                });
                
                buttonContainer.appendChild(addBtn);
                buttonContainer.appendChild(removeBtn);
                buttonContainer.appendChild(destroyBtn);
                header.appendChild(entityName);
                header.appendChild(buttonContainer);
                
                // Add click handler to header background (not buttons)
                header.addEventListener('click', (e) => {
                    // Only trigger if clicking on header background, not buttons or entity name
                    if (e.target === header) {
                        console.log(`üñ±Ô∏è Header background clicked for entity ${entity.id}`);
                        selectEntity(entity);
                    }
                });
                
                card.appendChild(header);
                
                // Add components display
                const componentsDiv = document.createElement('div');
                Array.from(entity.components.keys()).forEach(componentType => {
                    const component = entity.components.get(componentType);
                    const cssClass = componentType.toLowerCase();
                    
                    let details = '';
                    if (componentType === 'Transform') {
                        details = `(${component.x.toFixed(1)}, ${component.y.toFixed(1)}, ${component.z.toFixed(1)})`;
                    } else if (componentType === 'Movement') {
                        const speed = Math.sqrt(
                            component.velocity.x ** 2 + 
                            component.velocity.y ** 2 + 
                            component.velocity.z ** 2
                        ).toFixed(1);
                        details = `(speed: ${speed})`;
                    } else if (componentType === 'Health') {
                        details = `(${Math.round(component.current)}/${component.max})`;
                    } else if (componentType === 'Lifetime') {
                        details = `(${component.remaining.toFixed(1)}s)`;
                    } else if (componentType === 'RigidbodyComponent') {
                        const kinematic = component.isKinematic ? 'kinematic' : 'dynamic';
                        const mass = component.mass.toFixed(1);
                        if (!component.isKinematic && component.velocity) {
                            const speed = Math.sqrt(
                                component.velocity.x ** 2 + 
                                component.velocity.y ** 2 + 
                                component.velocity.z ** 2
                            ).toFixed(1);
                            details = `(${kinematic}, v: ${speed})`;
                        } else {
                            details = `(${kinematic}, mass: ${mass})`;
                        }
                    } else if (componentType === 'BoxColliderComponent') {
                        const size = component.size;
                        details = `(${size.x}√ó${size.y}√ó${size.z})`;
                    } else if (componentType === 'SphereColliderComponent') {
                        details = `(radius: ${component.radius.toFixed(1)})`;
                    } else if (componentType === 'TweenComponent') {
                        const status = component.isPlaying ? 'playing' : 'stopped';
                        details = `(${status})`;
                    } else if (componentType === 'AnimatorComponent') {
                        const state = component.currentState || 'idle';
                        details = `(${state})`;
                    } else if (componentType === 'VisualComponent') {
                        const modes = [];
                        if (component.wireframe) modes.push('wire');
                        if (component.pointsMode) modes.push('points');
                        if (component.transparent) modes.push('transp');
                        if (!component.visible) modes.push('hidden');
                        details = modes.length > 0 ? `(${modes.join(', ')})` : '(default)';
                    } else if (componentType === 'PartyComponent') {
                        const memberCount = component.members.length;
                        const leader = component.activeLeader;
                        details = `(${memberCount}/${component.maxSize} members, leader: ${leader})`;
                    } else if (componentType === 'CharacterComponent') {
                        const health = `${component.currentHealth}/${component.maxHealth}`;
                        details = `(Lv.${component.level}, HP: ${health})`;
                    } else if (componentType === 'AIComponent') {
                        const state = component.currentState || 'idle';
                        details = `(${component.behaviorType}, ${state})`;
                    } else if (componentType === 'CombatComponent') {
                        const state = component.combatState || 'idle';
                        const power = component.attackPower;
                        details = `(ATK: ${power}, ${state})`;
                    } else if (componentType === 'InventoryComponent') {
                        const itemCount = component.slots.filter(slot => slot !== null).length;
                        const gold = component.currency;
                        details = `(${itemCount}/20 items, ${gold} gold)`;
                    }
                    
                    const componentSpan = document.createElement('span');
                    const isActive = component.active !== false; // Default to true if not set
                    componentSpan.className = `component ${cssClass} ${isActive ? 'active' : 'inactive'}`;
                    componentSpan.textContent = `${componentType} ${details}`;
                    componentSpan.style.cursor = 'pointer';
                    componentSpan.title = `Click to ${isActive ? 'disable' : 'enable'} component`;
                    
                    // Add click handler to toggle component
                    componentSpan.addEventListener('click', (e) => {
                        console.log(`üñ†Ô∏è Component ${componentType} clicked for entity ${entity.id}`);
                        e.stopPropagation();
                        e.preventDefault();
                        toggleComponent(entity, componentType, component);
                    });
                    
                    componentsDiv.appendChild(componentSpan);
                });
                
                card.appendChild(componentsDiv);
                entityList.appendChild(card);
            });
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const now = Date.now();
            const deltaTime = (now - lastTime) / 1000;
            lastTime = now;
            
            // Update ECS world
            world.update(deltaTime);
            
            // Update physics system if available
            if (world.physicsSystem) {
                world.physicsSystem.update(deltaTime);
            }
            
            // Update Phase 3 systems if available
            if (world.partySystem) {
                world.partySystem.update(deltaTime);
            }
            if (world.characterSystem) {
                world.characterSystem.update(deltaTime);
            }
            if (world.aiSystem) {
                world.aiSystem.update(deltaTime);
            }
            if (world.combatSystem) {
                world.combatSystem.update(deltaTime);
            }
            if (world.inventorySystem) {
                world.inventorySystem.update(deltaTime);
            }
            
            // Update Phase 4 systems if available
            if (world.villageSystem) {
                world.villageSystem.update(deltaTime);
            }
            if (world.buildingSystem) {
                world.buildingSystem.update(deltaTime);
            }
            if (world.resourceSystem) {
                world.resourceSystem.update(deltaTime);
            }
            if (world.workerSystem) {
                world.workerSystem.update(deltaTime);
            }
            if (world.economySystem) {
                world.economySystem.update(deltaTime);
            }
            
            // Phase 5 systems
            if (world.questSystem) {
                world.questSystem.update(deltaTime);
            }
            if (world.dialogueSystem) {
                world.dialogueSystem.update(deltaTime);
            }
            if (world.npcSystem) {
                world.npcSystem.update(deltaTime);
            }
            if (world.eventSystem) {
                world.eventSystem.update(deltaTime);
            }
            
            
            // Update UI less frequently to avoid flickering (every 1000ms)
            if ((now - lastInspectorUpdate) > 1000) {
                updateInspector();
                updateStatus();
                lastInspectorUpdate = now;
            }
            
            // Update collider visualization for selected entity
            if (selectedEntity) {
                updateColliderVisualization(selectedEntity);
            }
            
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            const frustumSize = 20;
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Initialize
        if (typeof THREE !== 'undefined') {
            init();
        } else {
            window.addEventListener('load', init);
        }
        
        // Load Phase 2 components at initialization
        
        function loadPhase2Components(callback) {
            if (phase2ComponentsLoaded) {
                if (callback) callback();
                return;
            }
            
            console.log('üì¶ Loading Phase 2 components for ECS...');
            
            // Load GameEngine-standalone to get the component classes
            const gameEngineScript = document.createElement('script');
            gameEngineScript.src = './GameEngine-standalone.js';
            gameEngineScript.onload = () => {
                console.log('‚úÖ Phase 2 components loaded and available in ECS');
                phase2ComponentsLoaded = true;
                
                // Add physics system to existing ECS
                addPhysicsSystemToECS();
                
                if (callback) callback();
            };
            gameEngineScript.onerror = () => {
                console.error('‚ùå Failed to load Phase 2 components');
                if (callback) callback();
            };
            document.head.appendChild(gameEngineScript);
        }
        
        function addPhysicsSystemToECS() {
            // Add a proper physics system based on PhysicsSystem from GameEngine
            if (!world.physicsSystem) {
                world.physicsSystem = {
                    gravity: new THREE.Vector3(0, -9.81, 0),
                    enableGravity: true,
                    requiredComponents: ['Transform', 'RigidbodyComponent'],
                    
                    update: function(deltaTime) {
                        // Process entities using proper ECS pattern
                        world.entities.forEach(entity => {
                            if (!this.entityMatches(entity)) return;
                            
                            const transform = entity.getComponent('Transform');
                            const rigidbody = entity.getComponent('RigidbodyComponent');
                            
                            if (rigidbody.isKinematic || rigidbody.isSleeping || rigidbody.active === false || transform.active === false) return;
                            
                            // Apply gravity
                            if (rigidbody.useGravity && this.enableGravity) {
                                rigidbody.forces = rigidbody.forces || [];
                                const gravityForce = this.gravity.clone().multiplyScalar(rigidbody.mass);
                                rigidbody.forces.push(gravityForce);
                            }
                            
                            // Apply forces to acceleration
                            rigidbody.acceleration = rigidbody.acceleration || new THREE.Vector3(0, 0, 0);
                            rigidbody.acceleration.set(0, 0, 0);
                            
                            if (rigidbody.forces) {
                                rigidbody.forces.forEach(force => {
                                    rigidbody.acceleration.add(force.clone().divideScalar(rigidbody.mass));
                                });
                                rigidbody.forces = []; // Clear forces
                            }
                            
                            // Apply drag
                            if (rigidbody.drag) {
                                const dragForce = rigidbody.velocity.clone().multiplyScalar(-rigidbody.drag);
                                rigidbody.acceleration.add(dragForce);
                            }
                            
                            // Update velocity
                            rigidbody.velocity.add(rigidbody.acceleration.clone().multiplyScalar(deltaTime));
                            
                            // Update position 
                            const deltaPosition = rigidbody.velocity.clone().multiplyScalar(deltaTime);
                            transform.x += deltaPosition.x;
                            transform.y += deltaPosition.y;
                            transform.z += deltaPosition.z;
                            
                            // Simple ground collision with collider detection
                            const sphereCollider = entity.getComponent('SphereColliderComponent');
                            const boxCollider = entity.getComponent('BoxColliderComponent');
                            
                            let colliderRadius = 0.5; // Default
                            if (sphereCollider) {
                                colliderRadius = sphereCollider.radius;
                            } else if (boxCollider) {
                                colliderRadius = Math.min(boxCollider.size.x, boxCollider.size.y, boxCollider.size.z) / 2;
                            }
                            
                            if (transform.y < colliderRadius) {
                                transform.y = colliderRadius;
                                rigidbody.velocity.y = Math.abs(rigidbody.velocity.y) * 0.7; // Bounce with restitution
                                
                                // Wake up if sleeping
                                rigidbody.isSleeping = false;
                            }
                            
                            // Check for sleep threshold
                            if (rigidbody.velocity.length() < (rigidbody.sleepThreshold || 0.01)) {
                                rigidbody.isSleeping = true;
                            }
                        });
                    },
                    
                    entityMatches: function(entity) {
                        return this.requiredComponents.every(componentType => entity.hasComponent(componentType));
                    },
                    
                    getStats: function() {
                        return {
                            gravity: this.gravity.clone(),
                            enableGravity: this.enableGravity
                        };
                    }
                };
                console.log('‚úÖ Proper PhysicsSystem integrated into existing ECS with collision detection');
            }
        }
        
        // === Phase 3 Systems ===
        function addPhase3SystemsToECS() {
            console.log('üéØ Adding Phase 3 systems to ECS...');
            
            // PartySystem
            if (!world.partySystem) {
                world.partySystem = {
                    update: function(deltaTime) {
                        world.entities.forEach(entity => {
                            const party = entity.getComponent('PartyComponent');
                            if (!party || party.active === false) return;
                            
                            this.updatePartyFormation(entity, party);
                            this.updateFollowerPositions(entity, party, deltaTime);
                        });
                    },
                    
                    updatePartyFormation: function(partyEntity, party) {
                        const leaderId = party.getLeader();
                        const leader = world.entities.find(entity => entity.id === leaderId);
                        if (!leader) return;
                        
                        const leaderTransform = leader.getComponent('Transform');
                        if (!leaderTransform) return;
                        
                        // Update formation positions for followers
                        for (let i = 0; i < party.members.length; i++) {
                            if (i === party.activeLeader) continue; // Skip leader
                            
                            const follower = world.entities.find(entity => entity.id === party.members[i]);
                            if (!follower) continue;
                            
                            const followerTransform = follower.getComponent('Transform');
                            if (!followerTransform) continue;
                            
                            // Calculate formation position
                            const formationPos = this.calculateFormationPosition(
                                leaderTransform, i, party.formation, party.spacing
                            );
                            
                            // Set follower target position (will be handled by AI)
                            const ai = follower.getComponent('AIComponent');
                            if (ai) {
                                ai.target = party.getLeader();
                                ai.lastKnownTargetPosition = formationPos;
                            }
                        }
                    },
                    
                    calculateFormationPosition: function(leaderTransform, memberIndex, formation, spacing) {
                        const pos = { x: leaderTransform.x, y: leaderTransform.y, z: leaderTransform.z };
                        
                        switch (formation) {
                            case 'line':
                                pos.x -= spacing * (memberIndex + 1);
                                break;
                            case 'triangle':
                                const side = memberIndex % 2 === 0 ? -1 : 1;
                                pos.x += side * spacing * Math.ceil(memberIndex / 2);
                                pos.z -= spacing * Math.ceil(memberIndex / 2);
                                break;
                            case 'column':
                                pos.z -= spacing * (memberIndex + 1);
                                break;
                        }
                        
                        return pos;
                    },
                    
                    updateFollowerPositions: function(partyEntity, party, deltaTime) {
                        // Smooth movement toward formation positions
                        // This would integrate with movement/AI systems
                    }
                };
                console.log('‚úÖ PartySystem added to ECS');
            }
            
            // CharacterSystem  
            if (!world.characterSystem) {
                world.characterSystem = {
                    update: function(deltaTime) {
                        world.entities.forEach(entity => {
                            const character = entity.getComponent('CharacterComponent');
                            if (!character || character.active === false) return;
                            
                            this.updateCharacterStats(character);
                            this.processStatusEffects(character, deltaTime);
                        });
                    },
                    
                    updateCharacterStats: function(character) {
                        // Recalculate derived stats if needed
                        character.recalculateStats();
                    },
                    
                    processStatusEffects: function(character, deltaTime) {
                        const combat = character.entity?.getComponent('CombatComponent');
                        if (!combat) return;
                        
                        const now = performance.now() / 1000;
                        combat.statusEffects = combat.statusEffects.filter(effect => {
                            const elapsed = now - effect.startTime;
                            return elapsed < effect.duration;
                        });
                    }
                };
                console.log('‚úÖ CharacterSystem added to ECS');
            }
            
            // AISystem
            if (!world.aiSystem) {
                world.aiSystem = {
                    update: function(deltaTime) {
                        world.entities.forEach(entity => {
                            const ai = entity.getComponent('AIComponent');
                            if (!ai || ai.active === false) return;
                            
                            const now = performance.now() / 1000;
                            if ((now - ai.lastDecisionTime) >= ai.decisionCooldown) {
                                this.processAI(entity, ai, deltaTime);
                                ai.lastDecisionTime = now;
                            }
                            
                            ai.stateTimer += deltaTime;
                        });
                    },
                    
                    processAI: function(entity, ai, deltaTime) {
                        const transform = entity.getComponent('Transform');
                        if (!transform) return;
                        
                        switch (ai.behaviorType) {
                            case 'follow':
                                this.processFollowBehavior(entity, ai, transform);
                                break;
                            case 'patrol':
                                this.processPatrolBehavior(entity, ai, transform);
                                break;
                            case 'guard':
                                this.processGuardBehavior(entity, ai, transform);
                                break;
                            case 'aggressive':
                                this.processAggressiveBehavior(entity, ai, transform);
                                break;
                        }
                    },
                    
                    processFollowBehavior: function(entity, ai, transform) {
                        if (!ai.target) return;
                        
                        const targetEntity = world.entities.find(entity => entity.id === ai.target);
                        if (!targetEntity) return;
                        
                        const targetTransform = targetEntity.getComponent('Transform');
                        if (!targetTransform) return;
                        
                        // Calculate distance to target
                        const dx = targetTransform.x - transform.x;
                        const dz = targetTransform.z - transform.z;
                        const distance = Math.sqrt(dx * dx + dz * dz);
                        
                        // Move toward target if too far
                        const movement = entity.getComponent('Movement');
                        if (movement && distance > 2.0) {
                            const moveSpeed = 2.0;
                            movement.velocity.x = (dx / distance) * moveSpeed;
                            movement.velocity.z = (dz / distance) * moveSpeed;
                            ai.setState('moving');
                        } else if (movement) {
                            movement.velocity.x = 0;
                            movement.velocity.z = 0;
                            ai.setState('idle');
                        }
                    },
                    
                    processPatrolBehavior: function(entity, ai, transform) {
                        // Patrol between waypoints
                        if (ai.patrolPoints.length === 0) return;
                        
                        const targetPoint = ai.patrolPoints[ai.currentPatrolIndex];
                        const dx = targetPoint.x - transform.x;
                        const dz = targetPoint.z - transform.z;
                        const distance = Math.sqrt(dx * dx + dz * dz);
                        
                        if (distance < 1.0) {
                            // Reached waypoint, move to next
                            ai.currentPatrolIndex = (ai.currentPatrolIndex + 1) % ai.patrolPoints.length;
                        } else {
                            // Move toward current waypoint
                            const movement = entity.getComponent('Movement');
                            if (movement) {
                                const moveSpeed = 1.5;
                                movement.velocity.x = (dx / distance) * moveSpeed;
                                movement.velocity.z = (dz / distance) * moveSpeed;
                            }
                        }
                    },
                    
                    processGuardBehavior: function(entity, ai, transform) {
                        // Stay in place and watch for threats
                        const movement = entity.getComponent('Movement');
                        if (movement) {
                            movement.velocity.x = 0;
                            movement.velocity.z = 0;
                        }
                        ai.setState('guarding');
                    },
                    
                    processAggressiveBehavior: function(entity, ai, transform) {
                        // Look for targets and attack
                        if (!ai.target) {
                            // Find nearest enemy (for now, just find any other entity)
                            let nearestEntity = null;
                            let nearestDistance = ai.detectionRadius;
                            
                            world.entities.forEach((otherEntity, id) => {
                                if (otherEntity.id === entity.id) return;
                                
                                const otherTransform = otherEntity.getComponent('Transform');
                                if (!otherTransform) return;
                                
                                const dx = otherTransform.x - transform.x;
                                const dz = otherTransform.z - transform.z;
                                const distance = Math.sqrt(dx * dx + dz * dz);
                                
                                if (distance < nearestDistance) {
                                    nearestEntity = otherEntity;
                                    nearestDistance = distance;
                                }
                            });
                            
                            if (nearestEntity) {
                                ai.setTarget(nearestEntity.id);
                            }
                        } else {
                            // Chase and attack target
                            this.processFollowBehavior(entity, ai, transform);
                            
                            const targetEntity = world.entities.find(entity => entity.id === ai.target);
                            if (targetEntity) {
                                const targetTransform = targetEntity.getComponent('Transform');
                                if (targetTransform) {
                                    const dx = targetTransform.x - transform.x;
                                    const dz = targetTransform.z - transform.z;
                                    const distance = Math.sqrt(dx * dx + dz * dz);
                                    
                                    if (distance <= ai.attackRadius) {
                                        const combat = entity.getComponent('CombatComponent');
                                        if (combat && combat.canAttack()) {
                                            const attackResult = combat.attack();
                                            if (attackResult) {
                                                console.log(`üó°Ô∏è Entity ${entity.id} attacks for ${attackResult.damage} damage${attackResult.isCritical ? ' (CRITICAL!)' : ''}`);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                };
                console.log('‚úÖ AISystem added to ECS');
            }
            
            // CombatSystem
            if (!world.combatSystem) {
                world.combatSystem = {
                    update: function(deltaTime) {
                        world.entities.forEach(entity => {
                            const combat = entity.getComponent('CombatComponent');
                            if (!combat || combat.active === false) return;
                            
                            this.updateCombatState(combat, deltaTime);
                            this.processStatusEffects(combat, deltaTime);
                            this.processCombatCooldowns(combat, deltaTime);
                        });
                    },
                    
                    updateCombatState: function(combat, deltaTime) {
                        // Reset combat state after attacks
                        if (combat.combatState === 'attacking') {
                            const now = performance.now() / 1000;
                            if ((now - combat.lastAttackTime) > 0.5) { // 0.5s attack animation
                                combat.combatState = 'idle';
                            }
                        }
                    },
                    
                    processStatusEffects: function(combat, deltaTime) {
                        const now = performance.now() / 1000;
                        combat.statusEffects = combat.statusEffects.filter(effect => {
                            const elapsed = now - effect.startTime;
                            if (elapsed >= effect.duration) {
                                console.log(`‚ú® Status effect ${effect.type} expired`);
                                return false;
                            }
                            return true;
                        });
                    },
                    
                    processCombatCooldowns: function(combat, deltaTime) {
                        // Handle ability cooldowns and other timers
                        // This would be expanded with more complex combat mechanics
                    },
                    
                    dealDamage: function(attackerEntity, targetEntity, damage) {
                        const targetCharacter = targetEntity.getComponent('CharacterComponent');
                        const targetHealth = targetEntity.getComponent('Health');
                        
                        if (targetCharacter) {
                            targetCharacter.currentHealth -= damage;
                            console.log(`üí• ${targetEntity.id} takes ${damage} damage (${targetCharacter.currentHealth}/${targetCharacter.maxHealth} HP)`);
                            
                            if (targetCharacter.currentHealth <= 0) {
                                console.log(`üíÄ Entity ${targetEntity.id} has been defeated!`);
                                // Could trigger death/destruction logic here
                            }
                        } else if (targetHealth) {
                            targetHealth.current -= damage;
                            console.log(`üí• ${targetEntity.id} takes ${damage} damage (${targetHealth.current}/${targetHealth.max} HP)`);
                        }
                    }
                };
                console.log('‚úÖ CombatSystem added to ECS');
            }
            
            // InventorySystem
            if (!world.inventorySystem) {
                world.inventorySystem = {
                    update: function(deltaTime) {
                        world.entities.forEach(entity => {
                            const inventory = entity.getComponent('InventoryComponent');
                            if (!inventory || inventory.active === false) return;
                            
                            this.updateInventoryWeight(inventory);
                        });
                    },
                    
                    updateInventoryWeight: function(inventory) {
                        let totalWeight = 0;
                        inventory.slots.forEach(slot => {
                            if (slot !== null) {
                                totalWeight += (slot.item.weight || 1) * slot.quantity;
                            }
                        });
                        inventory.currentWeight = totalWeight;
                    },
                    
                    transferItem: function(fromInventory, toInventory, fromSlot, toSlot) {
                        const item = fromInventory.slots[fromSlot];
                        if (!item) return false;
                        
                        if (toInventory.slots[toSlot] === null) {
                            toInventory.slots[toSlot] = item;
                            fromInventory.slots[fromSlot] = null;
                            console.log(`üì¶ Transferred ${item.item.name || 'item'} to new slot`);
                            return true;
                        }
                        return false;
                    },
                    
                    createRandomItem: function() {
                        const items = [
                            { name: 'Sword', weight: 3, value: 50, type: 'weapon' },
                            { name: 'Shield', weight: 5, value: 30, type: 'armor' },
                            { name: 'Potion', weight: 1, value: 10, type: 'consumable' },
                            { name: 'Gold Coin', weight: 0.1, value: 1, type: 'currency' },
                            { name: 'Magic Ring', weight: 0.5, value: 100, type: 'accessory' }
                        ];
                        return items[Math.floor(Math.random() * items.length)];
                    }
                };
                console.log('‚úÖ InventorySystem added to ECS');
            }
            
            console.log('üéØ Phase 3 systems integration complete');
        }
        
        // === Phase 4 Systems: World Building ===
        function addPhase4SystemsToECS() {
            console.log('üèóÔ∏è Adding Phase 4 systems to ECS...');
            
            // VillageSystem
            if (!world.villageSystem) {
                world.villageSystem = {
                    update: function(deltaTime) {
                        world.entities.forEach(entity => {
                            const village = entity.getComponent('VillageComponent');
                            if (!village || village.active === false) return;
                            
                            this.updatePopulation(village, deltaTime);
                            this.updateMorale(village);
                            this.processGrowth(village, deltaTime);
                        });
                    },
                    
                    updatePopulation: function(village, deltaTime) {
                        // Natural population growth/decline
                        const timeInDays = deltaTime / (24 * 3600); // Convert to days for growth calculations
                        
                        if (village.morale > 60 && village.population < village.maxPopulation) {
                            // Growth based on morale and current population
                            const growthChance = village.growthRate * timeInDays * (village.morale / 100);
                            if (Math.random() < growthChance * 0.01) { // Very slow growth for demo
                                village.addPopulation(1);
                                console.log(`üë∂ ${village.name} population grew to ${village.population}`);
                            }
                        } else if (village.morale < 30) {
                            // Population decline due to low morale
                            const declineChance = village.emigrationRate * timeInDays * (1 - village.morale / 100);
                            if (Math.random() < declineChance * 0.01) {
                                village.removePopulation(1);
                                console.log(`üòû ${village.name} population declined to ${village.population}`);
                            }
                        }
                    },
                    
                    updateMorale: function(village) {
                        // Recalculate morale based on village conditions
                        village.calculateMorale();
                        
                        // Random events affecting morale
                        if (Math.random() < 0.001) { // 0.1% chance per update
                            const events = [
                                { name: 'Good Harvest', happiness: 10, prosperity: 5 },
                                { name: 'Festival', happiness: 15, morale: 5 },
                                { name: 'Disease Outbreak', happiness: -15, safety: -10 },
                                { name: 'Bandits Spotted', safety: -10, happiness: -5 },
                                { name: 'Trade Success', prosperity: 10, happiness: 5 }
                            ];
                            
                            const event = events[Math.floor(Math.random() * events.length)];
                            if (event.happiness) village.happiness = Math.max(0, Math.min(100, village.happiness + event.happiness));
                            if (event.prosperity) village.prosperity = Math.max(0, Math.min(100, village.prosperity + event.prosperity));
                            if (event.safety) village.safety = Math.max(0, Math.min(100, village.safety + event.safety));
                            if (event.morale) village.morale = Math.max(0, Math.min(100, village.morale + event.morale));
                            
                            console.log(`üì∞ ${village.name}: ${event.name}!`);
                        }
                    },
                    
                    processGrowth: function(village, deltaTime) {
                        // Update village age and handle milestones
                        const age = (Date.now() - village.founded) / 1000; // Age in seconds
                        
                        // Unlock population capacity based on age
                        if (age > 300 && village.maxPopulation < 75) { // 5 minutes = small growth
                            village.maxPopulation = 75;
                            console.log(`üèòÔ∏è ${village.name} expanded its borders! Max population: ${village.maxPopulation}`);
                        } else if (age > 600 && village.maxPopulation < 100) { // 10 minutes = major growth
                            village.maxPopulation = 100;
                            console.log(`üèòÔ∏è ${village.name} became a town! Max population: ${village.maxPopulation}`);
                        }
                    }
                };
                console.log('‚úÖ VillageSystem added to ECS');
            }
            
            // BuildingSystem
            if (!world.buildingSystem) {
                world.buildingSystem = {
                    update: function(deltaTime) {
                        world.entities.forEach(entity => {
                            const building = entity.getComponent('BuildingComponent');
                            if (!building || building.active === false) return;
                            
                            this.updateConstruction(building, deltaTime);
                            this.updateProduction(building, deltaTime);
                            this.updateMaintenance(building, deltaTime);
                        });
                    },
                    
                    updateConstruction: function(building, deltaTime) {
                        if (!building.isConstructed && building.constructionStarted) {
                            building.updateConstruction();
                            
                            if (building.isConstructed) {
                                console.log(`üèóÔ∏è ${building.buildingType} construction completed!`);
                            }
                        }
                    },
                    
                    updateProduction: function(building, deltaTime) {
                        if (building.isConstructed && building.produces && building.workersAssigned > 0) {
                            // Calculate efficiency based on workers and skill
                            const baseEfficiency = Math.min(1.0, building.workersAssigned / building.workersRequired);
                            building.efficiency = baseEfficiency * (building.health / building.maxHealth);
                            
                            // Generate resources
                            const productionAmount = building.productionRate * building.efficiency * deltaTime;
                            
                            if (productionAmount > 0) {
                                console.log(`‚öôÔ∏è ${building.buildingType} produced ${productionAmount.toFixed(2)} ${building.produces}`);
                            }
                        }
                    },
                    
                    updateMaintenance: function(building, deltaTime) {
                        if (building.isConstructed) {
                            // Buildings slowly degrade over time
                            const degradationRate = 0.1; // Health lost per minute
                            building.health -= degradationRate * (deltaTime / 60);
                            building.health = Math.max(0, building.health);
                            
                            if (building.health <= 0 && building.isConstructed) {
                                console.log(`üí• ${building.buildingType} has collapsed due to poor maintenance!`);
                                building.isConstructed = false;
                                building.constructionProgress = 0;
                            } else if (building.health < 25) {
                                console.log(`‚ö†Ô∏è ${building.buildingType} needs urgent repairs!`);
                            }
                        }
                    },
                    
                    startBuilding: function(building, resourceComponent) {
                        if (resourceComponent && resourceComponent.hasResources(building.resourceRequirements)) {
                            if (resourceComponent.consumeResources(building.resourceRequirements)) {
                                building.startConstruction();
                                console.log(`üöß Started building ${building.buildingType}`);
                                return true;
                            }
                        }
                        return false;
                    }
                };
                console.log('‚úÖ BuildingSystem added to ECS');
            }
            
            // ResourceSystem
            if (!world.resourceSystem) {
                world.resourceSystem = {
                    update: function(deltaTime) {
                        world.entities.forEach(entity => {
                            const resource = entity.getComponent('ResourceComponent');
                            if (!resource || resource.active === false) return;
                            
                            this.updateProduction(resource, deltaTime);
                            this.updateConsumption(resource, deltaTime);
                            this.processDecay(resource, deltaTime);
                        });
                    },
                    
                    updateProduction: function(resource, deltaTime) {
                        // Generate resources over time
                        for (const [type, rate] of Object.entries(resource.productionRates)) {
                            if (rate > 0) {
                                const produced = resource.addResource(type, rate * deltaTime);
                                if (produced > 0 && Math.random() < 0.001) { // Occasional logging
                                    console.log(`‚õèÔ∏è Produced ${produced.toFixed(1)} ${type}`);
                                }
                            }
                        }
                    },
                    
                    updateConsumption: function(resource, deltaTime) {
                        // Consume resources over time
                        for (const [type, rate] of Object.entries(resource.consumptionRates)) {
                            if (rate > 0) {
                                const consumed = resource.removeResource(type, rate * deltaTime);
                                if (consumed > 0 && resource.resources[type] <= 10) {
                                    console.log(`‚ö†Ô∏è Low ${type}! Only ${resource.resources[type].toFixed(1)} remaining`);
                                }
                            }
                        }
                    },
                    
                    processDecay: function(resource, deltaTime) {
                        // Food spoilage
                        if (resource.resources.food > 100) {
                            const spoilage = (resource.resources.food - 100) * 0.01 * deltaTime;
                            resource.removeResource('food', spoilage);
                            if (spoilage > 0.1) {
                                console.log(`ü¶† ${spoilage.toFixed(1)} food spoiled due to poor storage`);
                            }
                        }
                    },
                    
                    transferResources: function(fromResource, toResource, transfers) {
                        for (const [type, amount] of Object.entries(transfers)) {
                            const available = fromResource.removeResource(type, amount);
                            toResource.addResource(type, available);
                        }
                    }
                };
                console.log('‚úÖ ResourceSystem added to ECS');
            }
            
            // WorkerSystem
            if (!world.workerSystem) {
                world.workerSystem = {
                    update: function(deltaTime) {
                        world.entities.forEach(entity => {
                            const worker = entity.getComponent('WorkerComponent');
                            if (!worker || worker.active === false) return;
                            
                            this.updateWork(worker, deltaTime);
                            this.updateWellbeing(worker, deltaTime);
                            this.processSkillGrowth(worker, deltaTime);
                        });
                    },
                    
                    updateWork: function(worker, deltaTime) {
                        const currentHour = new Date().getHours();
                        const shouldWork = currentHour >= worker.workSchedule.startTime && 
                                         currentHour < worker.workSchedule.endTime && 
                                         currentHour !== worker.workSchedule.breakTime;
                        
                        if (shouldWork && worker.job !== 'unemployed') {
                            const productivity = worker.work(deltaTime);
                            if (productivity > 0 && Math.random() < 0.001) {
                                console.log(`üë∑ ${worker.name} working as ${worker.job} (productivity: ${productivity.toFixed(2)})`);
                            }
                        } else {
                            worker.rest(deltaTime);
                        }
                    },
                    
                    updateWellbeing: function(worker, deltaTime) {
                        // Happiness affects productivity
                        if (worker.energy < 30) {
                            worker.happiness -= deltaTime * 0.1; // Tired workers become unhappy
                        } else if (worker.energy > 80) {
                            worker.happiness += deltaTime * 0.05; // Well-rested workers are happier
                        }
                        
                        // Loyalty changes based on treatment
                        if (worker.happiness > 80) {
                            worker.loyalty += deltaTime * 0.02;
                        } else if (worker.happiness < 20) {
                            worker.loyalty -= deltaTime * 0.05;
                            
                            if (worker.loyalty < 10 && Math.random() < 0.001) {
                                console.log(`üò† ${worker.name} is considering quitting due to poor conditions`);
                            }
                        }
                        
                        // Clamp values
                        worker.happiness = Math.max(0, Math.min(100, worker.happiness));
                        worker.loyalty = Math.max(0, Math.min(100, worker.loyalty));
                    },
                    
                    processSkillGrowth: function(worker, deltaTime) {
                        // Workers improve skills over time
                        if (worker.isWorking && worker.skill < 10) {
                            const skillGrowthRate = 0.001; // Very slow skill growth
                            worker.experience += skillGrowthRate * deltaTime;
                            
                            const newSkill = Math.min(10, Math.floor(worker.experience / 100) + 1);
                            if (newSkill > worker.skill) {
                                worker.skill = newSkill;
                                worker.productivity = 1.0 + (worker.skill - 1) * 0.1;
                                console.log(`üìà ${worker.name} improved to skill level ${worker.skill}!`);
                            }
                        }
                    },
                    
                    assignWorker: function(worker, building) {
                        if (building && building.workersAssigned < building.workersRequired) {
                            worker.assignToJob(building.buildingType, building);
                            building.workersAssigned++;
                            console.log(`üë∑ ${worker.name} assigned to work at ${building.buildingType}`);
                            return true;
                        }
                        return false;
                    }
                };
                console.log('‚úÖ WorkerSystem added to ECS');
            }
            
            // EconomySystem
            if (!world.economySystem) {
                world.economySystem = {
                    update: function(deltaTime) {
                        world.entities.forEach(entity => {
                            const economy = entity.getComponent('EconomyComponent');
                            if (!economy || economy.active === false) return;
                            
                            this.updateMarket(economy, deltaTime);
                            this.processTrade(economy, deltaTime);
                        });
                    },
                    
                    updateMarket: function(economy, deltaTime) {
                        // Update market prices based on supply and demand
                        economy.updateMarketPrices();
                        
                        // Random market fluctuations
                        if (Math.random() < 0.001) { // 0.1% chance per update
                            const resources = Object.keys(economy.marketPrices);
                            const resource = resources[Math.floor(Math.random() * resources.length)];
                            const fluctuation = (Math.random() - 0.5) * 0.2; // ¬±10% change
                            
                            economy.marketPrices[resource] *= (1 + fluctuation);
                            economy.marketPrices[resource] = Math.max(0.1, economy.marketPrices[resource]);
                            
                            console.log(`üìà Market: ${resource} price changed to ${economy.marketPrices[resource].toFixed(2)}`);
                        }
                    },
                    
                    processTrade: function(economy, deltaTime) {
                        // Simulate some automatic trading
                        if (Math.random() < 0.0005) { // Very rare automatic trades
                            const resources = Object.keys(economy.marketPrices);
                            const resource = resources[Math.floor(Math.random() * resources.length)];
                            const amount = Math.floor(Math.random() * 10) + 1;
                            const isBuying = Math.random() > 0.5;
                            
                            const price = economy.trade(resource, amount, isBuying);
                            console.log(`üí± Market ${isBuying ? 'bought' : 'sold'} ${amount} ${resource} for ${price.toFixed(2)} gold`);
                        }
                    },
                    
                    calculateTradeValue: function(economy, resource, amount) {
                        const basePrice = economy.marketPrices[resource];
                        const reputationModifier = 0.5 + (economy.reputation / 100); // 50% to 150% based on reputation
                        return basePrice * amount * reputationModifier;
                    }
                };
                console.log('‚úÖ EconomySystem added to ECS');
            }
            
            console.log('üèóÔ∏è Phase 4 systems integration complete');
        }
        
        function addPhase5SystemsToECS() {
            console.log('üéØ Adding Phase 5 systems to ECS...');
            
            // Quest System - handles quest progression and objectives
            if (!world.questSystem) {
                world.questSystem = {
                    update: function(deltaTime) {
                        world.entities.forEach(entity => {
                            const quest = entity.getComponent('QuestComponent');
                            if (!quest || quest.active === false) return;
                            
                            this.processQuest(entity, quest, deltaTime);
                        });
                    },
                    
                    processQuest: function(entity, quest, deltaTime) {
                        if (quest.status === 'active') {
                            // Check objective completion conditions
                            quest.objectives.forEach(objective => {
                                if (!objective.completed) {
                                    this.checkObjectiveProgress(objective, entity);
                                }
                            });
                            
                            // Check if quest is completed
                            if (quest.isCompleted() && quest.status === 'active') {
                                this.completeQuest(entity, quest);
                            }
                        }
                    },
                    
                    checkObjectiveProgress: function(objective, questEntity) {
                        // Example: check for kill objectives
                        if (objective.type === 'kill') {
                            // This would integrate with combat system
                            if (Math.random() < 0.001) { // Simulate progress
                                objective.current = Math.min(objective.current + 1, objective.required);
                                objective.completed = objective.current >= objective.required;
                            }
                        }
                    },
                    
                    completeQuest: function(entity, quest) {
                        quest.status = 'completed';
                        quest.completionTime = Date.now();
                        
                        // Grant rewards
                        const character = entity.getComponent('CharacterComponent');
                        if (character && quest.rewards) {
                            if (quest.rewards.experience) {
                                character.experience += quest.rewards.experience;
                            }
                            if (quest.rewards.gold) {
                                character.gold += quest.rewards.gold;
                            }
                        }
                        
                        console.log(`‚úÖ Quest '${quest.title}' completed for entity ${entity.id}`);
                    },
                    
                    startQuest: function(entity, questId) {
                        const quest = entity.getComponent('QuestComponent');
                        if (quest && quest.questId === questId) {
                            quest.status = 'active';
                            quest.startTime = Date.now();
                            console.log(`üéØ Quest '${quest.title}' started for entity ${entity.id}`);
                        }
                    }
                };
                console.log('‚úÖ QuestSystem added to ECS');
            }
            
            // Dialogue System - manages conversation flow
            if (!world.dialogueSystem) {
                world.dialogueSystem = {
                    activeDialogues: new Map(), // Entity ID -> dialogue state
                    
                    update: function(deltaTime) {
                        world.entities.forEach(entity => {
                            const dialogue = entity.getComponent('DialogueComponent');
                            if (!dialogue || dialogue.active === false) return;
                            
                            this.processDialogue(entity, dialogue, deltaTime);
                        });
                    },
                    
                    processDialogue: function(entity, dialogue, deltaTime) {
                        // Update relationship values over time
                        if (dialogue.lastInteraction) {
                            const timeSinceInteraction = Date.now() - dialogue.lastInteraction;
                            
                            // Relationships naturally decay over time
                            if (timeSinceInteraction > 86400000) { // 24 hours
                                Object.keys(dialogue.relationship).forEach(rel => {
                                    dialogue.relationship[rel] = Math.max(0, 
                                        dialogue.relationship[rel] - 0.1 * deltaTime);
                                });
                            }
                        }
                    },
                    
                    startConversation: function(entity, playerEntity = null) {
                        const dialogue = entity.getComponent('DialogueComponent');
                        if (!dialogue) return null;
                        
                        const conversation = dialogue.startDialogue();
                        this.activeDialogues.set(entity.id, {
                            entity: entity,
                            player: playerEntity,
                            currentNode: conversation
                        });
                        
                        console.log(`üí¨ Started conversation with ${dialogue.characterName}`);
                        return conversation;
                    },
                    
                    makeChoice: function(entityId, choiceIndex) {
                        const activeDialogue = this.activeDialogues.get(entityId);
                        if (!activeDialogue) return null;
                        
                        const dialogue = activeDialogue.entity.getComponent('DialogueComponent');
                        const nextNode = dialogue.chooseOption(choiceIndex);
                        
                        if (nextNode) {
                            activeDialogue.currentNode = nextNode;
                        } else {
                            // Conversation ended
                            this.activeDialogues.delete(entityId);
                            console.log(`üí¨ Conversation with ${dialogue.characterName} ended`);
                        }
                        
                        return nextNode;
                    }
                };
                console.log('‚úÖ DialogueSystem added to ECS');
            }
            
            // NPC System - advanced NPC behaviors and scheduling
            if (!world.npcSystem) {
                world.npcSystem = {
                    gameTime: 0, // Simulated game time in seconds
                    
                    update: function(deltaTime) {
                        this.gameTime += deltaTime;
                        
                        world.entities.forEach(entity => {
                            const npc = entity.getComponent('NPCComponent');
                            if (!npc || npc.active === false) return;
                            
                            this.processNPC(entity, npc, deltaTime);
                        });
                    },
                    
                    processNPC: function(entity, npc, deltaTime) {
                        // Update needs
                        npc.updateNeeds(deltaTime);
                        
                        // Update current activity based on schedule
                        const currentActivity = npc.getCurrentActivity(this.gameTime);
                        if (npc.currentActivity !== currentActivity.activity) {
                            npc.currentActivity = currentActivity.activity;
                            npc.activityStartTime = this.gameTime;
                            console.log(`ü§ñ ${npc.name} is now ${currentActivity.activity} at ${currentActivity.location}`);
                        }
                        
                        // Process social interactions
                        this.processSocialBehavior(entity, npc, deltaTime);
                        
                        // Economic decision making
                        this.processEconomicBehavior(entity, npc, deltaTime);
                    },
                    
                    processSocialBehavior: function(entity, npc, deltaTime) {
                        // NPCs seek social interaction based on their needs
                        if (npc.needs.social < 30 && Math.random() < 0.001) {
                            // Look for nearby NPCs to socialize with
                            const nearbyNPCs = world.entities.filter(other => 
                                other !== entity && 
                                other.getComponent('NPCComponent') &&
                                other.getComponent('Transform')
                            );
                            
                            if (nearbyNPCs.length > 0) {
                                npc.needs.social += 10;
                                console.log(`üòä ${npc.name} socialized and feels better`);
                            }
                        }
                    },
                    
                    processEconomicBehavior: function(entity, npc, deltaTime) {
                        // NPCs make economic decisions based on their profession and needs
                        if (npc.needs.food < 50 && Math.random() < 0.0001) {
                            const economy = entity.getComponent('EconomyComponent');
                            if (economy && economy.marketPrices.food) {
                                // Buy food
                                const foodCost = economy.marketPrices.food * 5;
                                npc.needs.food += 20;
                                console.log(`üçû ${npc.name} bought food for ${foodCost.toFixed(2)} gold`);
                            }
                        }
                    }
                };
                console.log('‚úÖ NPCSystem added to ECS');
            }
            
            // Event System - handles random and scripted world events
            if (!world.eventSystem) {
                world.eventSystem = {
                    activeEvents: [],
                    eventTimer: 0,
                    eventFrequency: 30, // Seconds between potential events
                    
                    update: function(deltaTime) {
                        this.eventTimer += deltaTime;
                        
                        // Process active events
                        this.activeEvents.forEach(event => {
                            event.processEvent(deltaTime, world);
                        });
                        
                        // Remove completed events
                        this.activeEvents = this.activeEvents.filter(event => 
                            event.status === 'active'
                        );
                        
                        // Check for new random events
                        if (this.eventTimer >= this.eventFrequency) {
                            this.eventTimer = 0;
                            this.checkForRandomEvents();
                        }
                        
                        // Process entity events
                        world.entities.forEach(entity => {
                            const eventComp = entity.getComponent('EventComponent');
                            if (!eventComp || eventComp.active === false) return;
                            
                            this.processEntityEvent(entity, eventComp, deltaTime);
                        });
                    },
                    
                    checkForRandomEvents: function() {
                        if (Math.random() < 0.3) { // 30% chance every interval
                            const eventEntities = world.entities.filter(entity => 
                                entity.getComponent('EventComponent')
                            );
                            
                            if (eventEntities.length > 0) {
                                const randomEntity = eventEntities[Math.floor(Math.random() * eventEntities.length)];
                                const eventComp = randomEntity.getComponent('EventComponent');
                                const triggeredEvent = eventComp.triggerRandomEvent();
                                
                                if (triggeredEvent) {
                                    this.activeEvents.push(eventComp);
                                    console.log(`üé≤ Random event triggered: ${triggeredEvent.name}`);
                                }
                            }
                        }
                    },
                    
                    processEntityEvent: function(entity, eventComp, deltaTime) {
                        if (eventComp.status === 'active') {
                            eventComp.processEvent(deltaTime, world);
                            
                            // Apply event effects to nearby entities
                            if (eventComp.effects.moodModifiers) {
                                this.applyMoodEffects(entity, eventComp.effects.moodModifiers);
                            }
                        }
                    },
                    
                    applyMoodEffects: function(sourceEntity, moodModifiers) {
                        const transform = sourceEntity.getComponent('Transform');
                        if (!transform) return;
                        
                        // Affect nearby NPCs
                        world.entities.forEach(entity => {
                            const npc = entity.getComponent('NPCComponent');
                            const entityTransform = entity.getComponent('Transform');
                            
                            if (npc && entityTransform && entity !== sourceEntity) {
                                const distance = Math.sqrt(
                                    Math.pow(transform.x - entityTransform.x, 2) +
                                    Math.pow(transform.z - entityTransform.z, 2)
                                );
                                
                                if (distance < 10) { // Within 10 units
                                    Object.keys(moodModifiers).forEach(mood => {
                                        if (npc.needs[mood] !== undefined) {
                                            npc.needs[mood] = Math.max(0, Math.min(100, 
                                                npc.needs[mood] + moodModifiers[mood]
                                            ));
                                        }
                                    });
                                }
                            }
                        });
                    }
                };
                console.log('‚úÖ EventSystem added to ECS');
            }
            
            console.log('üéØ Phase 5 systems integration complete');
        }
        
        // Load Phase 3 components and systems
        function loadPhase3Components(callback) {
            console.log('üì¶ Loading Phase 3 components for ECS...');
            
            // Verify Phase 3 components are available
            const componentsAvailable = [
                'PartyComponent',
                'CharacterComponent', 
                'AIComponent',
                'CombatComponent',
                'InventoryComponent'
            ].every(name => {
                const available = !!window[name];
                console.log(`  ${available ? '‚úÖ' : '‚ùå'} ${name}: ${available ? 'Available' : 'Not found'}`);
                return available;
            });
            
            if (!componentsAvailable) {
                console.error('‚ùå Some Phase 3 components are not available on window!');
            }
            
            // Add Phase 3 systems to existing ECS
            addPhase3SystemsToECS();
            
            // Add Phase 4 systems to existing ECS
            addPhase4SystemsToECS();
            
            // Add Phase 5 systems to existing ECS
            addPhase5SystemsToECS();
            
            console.log('‚úÖ Phase 3 components and systems loaded');
            console.log('‚úÖ Phase 4 components and systems loaded');
            console.log('‚úÖ Phase 5 components and systems loaded');
            if (callback) callback();
        }
        
        
        // Collider visualization
        function addColliderVisualization(entity) {
            if (!entity) return;
            
            const transform = entity.getComponent('Transform');
            if (!transform) return;
            
            // Always create visualizations - they show component state, not movement state
            
            // Remove existing collider visualizations
            removeColliderVisualization(entity);
            
            // Visualize SphereColliderComponent
            const sphereCollider = entity.getComponent('SphereColliderComponent');
            if (sphereCollider && sphereCollider.active !== false && !entity.sphereColliderHelper) {
                const geometry = new THREE.SphereGeometry(sphereCollider.radius, 16, 12);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x00ff88,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.6
                });
                const sphereHelper = new THREE.Mesh(geometry, material);
                
                // Position the helper
                sphereHelper.position.set(transform.x, transform.y, transform.z);
                sphereHelper.position.add(sphereCollider.center);
                
                // Store reference and add to scene
                entity.sphereColliderHelper = sphereHelper;
                scene.add(sphereHelper);
                
                console.log(`üîµ Added sphere collider visualization for entity ${entity.id}`);
            }
            
            // Visualize BoxColliderComponent
            const boxCollider = entity.getComponent('BoxColliderComponent');
            if (boxCollider && boxCollider.active !== false && !entity.boxColliderHelper) {
                const geometry = new THREE.BoxGeometry(boxCollider.size.x, boxCollider.size.y, boxCollider.size.z);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x0088ff,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.6
                });
                const boxHelper = new THREE.Mesh(geometry, material);
                
                // Position the helper
                boxHelper.position.set(transform.x, transform.y, transform.z);
                boxHelper.position.add(boxCollider.center);
                
                // Store reference and add to scene
                entity.boxColliderHelper = boxHelper;
                scene.add(boxHelper);
                
                console.log(`üü¶ Added box collider visualization for entity ${entity.id}`);
            }
            
            // Visualize TweenComponent
            const tweenComponent = entity.getComponent('TweenComponent');
            if (tweenComponent && tweenComponent.active !== false) {
                // Create a pulsing ring around the entity to show it has tweening
                const ringGeometry = new THREE.RingGeometry(1.5, 2.0, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff44ff,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide
                });
                const ringHelper = new THREE.Mesh(ringGeometry, ringMaterial);
                
                // Position the ring horizontally around the entity
                ringHelper.position.set(transform.x, transform.y + 1, transform.z);
                ringHelper.rotation.x = Math.PI / 2; // Make it horizontal
                
                // Store reference and add to scene
                entity.tweenHelper = ringHelper;
                scene.add(ringHelper);
                
                console.log(`üü† Added tween visualization for entity ${entity.id}`);
            }
            
            // Visualize AnimatorComponent
            const animatorComponent = entity.getComponent('AnimatorComponent');
            if (animatorComponent && animatorComponent.active !== false) {
                // Create rotating wireframe octahedron to show animation state
                const geometry = new THREE.OctahedronGeometry(1.2);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xaa44ff,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.8
                });
                const animatorHelper = new THREE.Mesh(geometry, material);
                
                // Position above the entity
                animatorHelper.position.set(transform.x, transform.y + 2.5, transform.z);
                
                // Store reference and add to scene
                entity.animatorHelper = animatorHelper;
                scene.add(animatorHelper);
                
                console.log(`üé≠ Added animator visualization for entity ${entity.id}`);
            }
            
            // Visualize PartyComponent
            const party = entity.getComponent('PartyComponent');
            if (party && party.active !== false) {
                // Create party leadership indicator (crown)
                const crownGeometry = new THREE.ConeGeometry(0.2, 0.4, 6);
                const crownMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffd700,
                    transparent: true,
                    opacity: 0.9
                });
                const crownHelper = new THREE.Mesh(crownGeometry, crownMaterial);
                crownHelper.position.set(transform.x, transform.y + 2, transform.z);
                
                entity.partyHelper = crownHelper;
                scene.add(crownHelper);
                
            }
            
            // Visualize CharacterComponent
            const character = entity.getComponent('CharacterComponent');
            if (character && character.active !== false) {
                // Create health bar
                const healthBarGeometry = new THREE.PlaneGeometry(1, 0.1);
                const healthPercent = character.currentHealth / character.maxHealth;
                const healthColor = healthPercent > 0.5 ? 0x4caf50 : healthPercent > 0.2 ? 0xffeb3b : 0xf44336;
                const healthBarMaterial = new THREE.MeshBasicMaterial({ 
                    color: healthColor,
                    transparent: true,
                    opacity: 0.8
                });
                const healthBar = new THREE.Mesh(healthBarGeometry, healthBarMaterial);
                healthBar.position.set(transform.x, transform.y + 1.8, transform.z);
                healthBar.lookAt(camera.position);
                
                // Create level indicator
                const levelGeometry = new THREE.RingGeometry(0.15, 0.25, 8);
                const levelMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x2196f3,
                    transparent: true,
                    opacity: 0.7
                });
                const levelHelper = new THREE.Mesh(levelGeometry, levelMaterial);
                levelHelper.position.set(transform.x + 0.7, transform.y + 1.8, transform.z);
                levelHelper.lookAt(camera.position);
                
                entity.healthBarHelper = healthBar;
                entity.levelHelper = levelHelper;
                scene.add(healthBar);
                scene.add(levelHelper);
                
            }
            
            // Visualize AIComponent
            const ai = entity.getComponent('AIComponent');
            if (ai && ai.active !== false) {
                // Create behavior state indicator
                const behaviorGeometry = new THREE.SphereGeometry(0.15, 8, 6);
                let behaviorColor;
                switch(ai.behaviorType) {
                    case 'follow': behaviorColor = 0x4caf50; break;
                    case 'guard': behaviorColor = 0xff9800; break;
                    case 'patrol': behaviorColor = 0x2196f3; break;
                    case 'aggressive': behaviorColor = 0xf44336; break;
                    default: behaviorColor = 0x9e9e9e;
                }
                const behaviorMaterial = new THREE.MeshBasicMaterial({ 
                    color: behaviorColor,
                    transparent: true,
                    opacity: 0.8
                });
                const behaviorHelper = new THREE.Mesh(behaviorGeometry, behaviorMaterial);
                behaviorHelper.position.set(transform.x - 0.7, transform.y + 1.8, transform.z);
                
                entity.aiHelper = behaviorHelper;
                scene.add(behaviorHelper);
                
            }
            
            // Visualize CombatComponent
            const combat = entity.getComponent('CombatComponent');
            if (combat && combat.active !== false) {
                // Create attack range indicator
                const rangeGeometry = new THREE.RingGeometry(1.5, 1.7, 16);
                const rangeMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xf44336,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                const rangeHelper = new THREE.Mesh(rangeGeometry, rangeMaterial);
                rangeHelper.position.set(transform.x, transform.y + 0.1, transform.z);
                rangeHelper.rotation.x = -Math.PI / 2;
                
                entity.combatHelper = rangeHelper;
                scene.add(rangeHelper);
                
            }
            
            // Visualize InventoryComponent
            const inventory = entity.getComponent('InventoryComponent');
            if (inventory && inventory.active !== false) {
                // Create inventory bag indicator
                const bagGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                const bagMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x8d6e63,
                    transparent: true,
                    opacity: 0.9
                });
                const bagHelper = new THREE.Mesh(bagGeometry, bagMaterial);
                bagHelper.position.set(transform.x + 0.7, transform.y + 1.2, transform.z);
                
                entity.inventoryHelper = bagHelper;
                scene.add(bagHelper);
                
            }
            
            // Visualize Phase 4 Components
            
            // Visualize VillageComponent
            const village = entity.getComponent('VillageComponent');
            if (village && village.active !== false) {
                // Create village indicator (small house)
                const houseGeometry = new THREE.BoxGeometry(0.4, 0.4, 0.4);
                const houseMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x8bc34a,
                    transparent: true,
                    opacity: 0.9
                });
                const houseHelper = new THREE.Mesh(houseGeometry, houseMaterial);
                houseHelper.position.set(transform.x - 1.0, transform.y + 1.5, transform.z);
                
                // Add roof
                const roofGeometry = new THREE.ConeGeometry(0.3, 0.3, 4);
                const roofMaterial = new THREE.MeshBasicMaterial({ color: 0x795548 });
                const roofHelper = new THREE.Mesh(roofGeometry, roofMaterial);
                roofHelper.position.set(transform.x - 1.0, transform.y + 1.8, transform.z);
                
                entity.villageHelper = houseHelper;
                entity.villageRoofHelper = roofHelper;
                scene.add(houseHelper);
                scene.add(roofHelper);
                
            }
            
            // Visualize BuildingComponent
            const building = entity.getComponent('BuildingComponent');
            if (building && building.active !== false) {
                // Create building indicator based on type
                let buildingColor;
                switch(building.buildingType) {
                    case 'house': buildingColor = 0x8bc34a; break;
                    case 'farm': buildingColor = 0x4caf50; break;
                    case 'workshop': buildingColor = 0x795548; break;
                    case 'storage': buildingColor = 0xff9800; break;
                    case 'barracks': buildingColor = 0xf44336; break;
                    default: buildingColor = 0x607d8b;
                }
                
                const buildingGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.6);
                const buildingMaterial = new THREE.MeshBasicMaterial({ 
                    color: buildingColor,
                    transparent: true,
                    opacity: building.isConstructed ? 0.8 : 0.4
                });
                const buildingHelper = new THREE.Mesh(buildingGeometry, buildingMaterial);
                buildingHelper.position.set(transform.x + 1.0, transform.y + 1.4, transform.z);
                
                entity.buildingHelper = buildingHelper;
                scene.add(buildingHelper);
                
            }
            
            // Visualize ResourceComponent
            const resource = entity.getComponent('ResourceComponent');
            if (resource && resource.active !== false) {
                // Create resource stack indicator
                const stackGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.5, 8);
                const stackMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff9800,
                    transparent: true,
                    opacity: 0.8
                });
                const stackHelper = new THREE.Mesh(stackGeometry, stackMaterial);
                stackHelper.position.set(transform.x, transform.y + 2.2, transform.z + 1.0);
                
                entity.resourceHelper = stackHelper;
                scene.add(stackHelper);
                
            }
            
            // Visualize WorkerComponent
            const worker = entity.getComponent('WorkerComponent');
            if (worker && worker.active !== false) {
                // Create worker tool indicator
                const toolGeometry = new THREE.BoxGeometry(0.1, 0.6, 0.1);
                const toolMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x607d8b,
                    transparent: true,
                    opacity: 0.9
                });
                const toolHelper = new THREE.Mesh(toolGeometry, toolMaterial);
                toolHelper.position.set(transform.x - 0.5, transform.y + 1.5, transform.z - 0.5);
                toolHelper.rotation.z = Math.PI / 4; // Lean the tool
                
                entity.workerHelper = toolHelper;
                scene.add(toolHelper);
                
            }
            
            // Visualize EconomyComponent
            const economy = entity.getComponent('EconomyComponent');
            if (economy && economy.active !== false) {
                // Store all coin helpers in an array
                entity.economyHelpers = [];
                
                // Stack multiple coins - create separate geometry and material for each
                for (let i = 0; i < 3; i++) {
                    const coinGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.05, 12);
                    const coinMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffc107,
                        transparent: true,
                        opacity: 0.9
                    });
                    
                    const coinHelper = new THREE.Mesh(coinGeometry, coinMaterial);
                    coinHelper.position.set(transform.x + 0.5, transform.y + 1.0 + (i * 0.1), transform.z + 0.5);
                    
                    entity.economyHelpers.push(coinHelper);
                    scene.add(coinHelper);
                }
                
                // Keep reference to first coin for easy access in updates
                entity.economyHelper = entity.economyHelpers[0];
                
            }
            
            // ===== PHASE 5 VISUALIZATIONS =====
            
            // Visualize QuestComponent
            const quest = entity.getComponent('QuestComponent');
            if (quest && quest.active !== false) {
                // Create quest indicator based on status
                let questColor;
                switch(quest.status) {
                    case 'available': questColor = 0xffeb3b; break; // Yellow
                    case 'active': questColor = 0x2196f3; break;    // Blue
                    case 'completed': questColor = 0x4caf50; break; // Green
                    case 'failed': questColor = 0xf44336; break;    // Red
                    default: questColor = 0x9e9e9e;                // Gray
                }
                
                const questGeometry = new THREE.ConeGeometry(0.2, 0.8, 4);
                const questMaterial = new THREE.MeshBasicMaterial({ 
                    color: questColor,
                    transparent: true,
                    opacity: 0.8
                });
                const questHelper = new THREE.Mesh(questGeometry, questMaterial);
                questHelper.position.set(transform.x - 1.0, transform.y + 1.5, transform.z);
                questHelper.rotation.x = Math.PI; // Point upward
                
                entity.questHelper = questHelper;
                scene.add(questHelper);
                
            }
            
            // Visualize DialogueComponent
            const dialogue = entity.getComponent('DialogueComponent');
            if (dialogue && dialogue.active !== false) {
                // Create speech bubble indicator
                const bubbleGeometry = new THREE.SphereGeometry(0.3, 8, 6);
                const bubbleMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xe1f5fe,
                    transparent: true,
                    opacity: 0.7
                });
                const bubbleHelper = new THREE.Mesh(bubbleGeometry, bubbleMaterial);
                bubbleHelper.position.set(transform.x + 1.5, transform.y + 1.8, transform.z);
                
                entity.dialogueHelper = bubbleHelper;
                scene.add(bubbleHelper);
                
            }
            
            // Visualize NPCComponent
            const npc = entity.getComponent('NPCComponent');
            if (npc && npc.active !== false) {
                // Create NPC type indicator
                let npcColor;
                switch(npc.npcType) {
                    case 'villager': npcColor = 0x8bc34a; break;   // Light green
                    case 'merchant': npcColor = 0xffc107; break;   // Amber
                    case 'guard': npcColor = 0x607d8b; break;      // Blue gray
                    case 'quest_giver': npcColor = 0x9c27b0; break; // Purple
                    case 'farmer': npcColor = 0x795548; break;     // Brown
                    default: npcColor = 0x2196f3;                 // Blue
                }
                
                const npcGeometry = new THREE.OctahedronGeometry(0.25, 0);
                const npcMaterial = new THREE.MeshBasicMaterial({ 
                    color: npcColor,
                    transparent: true,
                    opacity: 0.8
                });
                const npcHelper = new THREE.Mesh(npcGeometry, npcMaterial);
                npcHelper.position.set(transform.x, transform.y + 2.0, transform.z + 1.0);
                
                entity.npcHelper = npcHelper;
                scene.add(npcHelper);
                
            }
            
            // Visualize EventComponent
            const event = entity.getComponent('EventComponent');
            if (event && event.active !== false) {
                // Create event indicator based on type and status
                let eventColor;
                if (event.status === 'active') {
                    eventColor = 0xff5722; // Deep orange for active events
                } else {
                    switch(event.eventType) {
                        case 'random': eventColor = 0x4caf50; break;    // Green
                        case 'scripted': eventColor = 0x2196f3; break;  // Blue
                        case 'seasonal': eventColor = 0xff9800; break;  // Orange
                        case 'triggered': eventColor = 0x9c27b0; break; // Purple
                        default: eventColor = 0x607d8b;                // Blue gray
                    }
                }
                
                const eventGeometry = new THREE.TetrahedronGeometry(0.4, 0);
                const eventMaterial = new THREE.MeshBasicMaterial({ 
                    color: eventColor,
                    transparent: true,
                    opacity: event.status === 'active' ? 0.9 : 0.6
                });
                const eventHelper = new THREE.Mesh(eventGeometry, eventMaterial);
                eventHelper.position.set(transform.x - 1.5, transform.y + 2.2, transform.z);
                
                entity.eventHelper = eventHelper;
                scene.add(eventHelper);
                
            }
        }
        
        function removeColliderVisualization(entity) {
            if (!entity) return;
            
            // Remove sphere collider helper
            if (entity.sphereColliderHelper) {
                scene.remove(entity.sphereColliderHelper);
                entity.sphereColliderHelper.geometry.dispose();
                entity.sphereColliderHelper.material.dispose();
                delete entity.sphereColliderHelper;
            }
            
            // Remove box collider helper
            if (entity.boxColliderHelper) {
                scene.remove(entity.boxColliderHelper);
                entity.boxColliderHelper.geometry.dispose();
                entity.boxColliderHelper.material.dispose();
                delete entity.boxColliderHelper;
            }
            
            // Remove tween helper
            if (entity.tweenHelper) {
                scene.remove(entity.tweenHelper);
                entity.tweenHelper.geometry.dispose();
                entity.tweenHelper.material.dispose();
                delete entity.tweenHelper;
            }
            
            // Remove animator helper
            if (entity.animatorHelper) {
                scene.remove(entity.animatorHelper);
                entity.animatorHelper.geometry.dispose();
                entity.animatorHelper.material.dispose();
                delete entity.animatorHelper;
            }
            
            // Remove Phase 3 component helpers
            if (entity.partyHelper) {
                scene.remove(entity.partyHelper);
                entity.partyHelper.geometry.dispose();
                entity.partyHelper.material.dispose();
                delete entity.partyHelper;
            }
            
            if (entity.healthBarHelper) {
                scene.remove(entity.healthBarHelper);
                entity.healthBarHelper.geometry.dispose();
                entity.healthBarHelper.material.dispose();
                delete entity.healthBarHelper;
            }
            
            if (entity.levelHelper) {
                scene.remove(entity.levelHelper);
                entity.levelHelper.geometry.dispose();
                entity.levelHelper.material.dispose();
                delete entity.levelHelper;
            }
            
            if (entity.aiHelper) {
                scene.remove(entity.aiHelper);
                entity.aiHelper.geometry.dispose();
                entity.aiHelper.material.dispose();
                delete entity.aiHelper;
            }
            
            if (entity.combatHelper) {
                scene.remove(entity.combatHelper);
                entity.combatHelper.geometry.dispose();
                entity.combatHelper.material.dispose();
                delete entity.combatHelper;
            }
            
            if (entity.inventoryHelper) {
                scene.remove(entity.inventoryHelper);
                entity.inventoryHelper.geometry.dispose();
                entity.inventoryHelper.material.dispose();
                delete entity.inventoryHelper;
            }
            
            // Remove Phase 4 component helpers
            if (entity.villageHelper) {
                scene.remove(entity.villageHelper);
                entity.villageHelper.geometry.dispose();
                entity.villageHelper.material.dispose();
                delete entity.villageHelper;
            }
            
            if (entity.villageRoofHelper) {
                scene.remove(entity.villageRoofHelper);
                entity.villageRoofHelper.geometry.dispose();
                entity.villageRoofHelper.material.dispose();
                delete entity.villageRoofHelper;
            }
            
            if (entity.buildingHelper) {
                scene.remove(entity.buildingHelper);
                entity.buildingHelper.geometry.dispose();
                entity.buildingHelper.material.dispose();
                delete entity.buildingHelper;
            }
            
            if (entity.resourceHelper) {
                scene.remove(entity.resourceHelper);
                entity.resourceHelper.geometry.dispose();
                entity.resourceHelper.material.dispose();
                delete entity.resourceHelper;
            }
            
            if (entity.workerHelper) {
                scene.remove(entity.workerHelper);
                entity.workerHelper.geometry.dispose();
                entity.workerHelper.material.dispose();
                delete entity.workerHelper;
            }
            
            // Remove all economy helpers (multiple coins)
            if (entity.economyHelpers) {
                entity.economyHelpers.forEach(coinHelper => {
                    scene.remove(coinHelper);
                    coinHelper.geometry.dispose();
                    coinHelper.material.dispose();
                });
                delete entity.economyHelpers;
                delete entity.economyHelper; // Remove the reference to first coin too
            }
            
            // Phase 5 cleanup
            if (entity.questHelper) {
                scene.remove(entity.questHelper);
                entity.questHelper.geometry.dispose();
                entity.questHelper.material.dispose();
                delete entity.questHelper;
            }
            
            if (entity.dialogueHelper) {
                scene.remove(entity.dialogueHelper);
                entity.dialogueHelper.geometry.dispose();
                entity.dialogueHelper.material.dispose();
                delete entity.dialogueHelper;
            }
            
            if (entity.npcHelper) {
                scene.remove(entity.npcHelper);
                entity.npcHelper.geometry.dispose();
                entity.npcHelper.material.dispose();
                delete entity.npcHelper;
            }
            
            if (entity.eventHelper) {
                scene.remove(entity.eventHelper);
                entity.eventHelper.geometry.dispose();
                entity.eventHelper.material.dispose();
                delete entity.eventHelper;
            }
        }
        
        function updateColliderVisualization(entity) {
            if (!entity || entity !== selectedEntity) return;
            
            const transform = entity.getComponent('Transform');
            if (!transform || transform.active === false) return;
            
            const now = Date.now();
            
            // Update sphere collider position
            if (entity.sphereColliderHelper) {
                const sphereCollider = entity.getComponent('SphereColliderComponent');
                if (sphereCollider) {
                    entity.sphereColliderHelper.position.set(transform.x, transform.y, transform.z);
                    entity.sphereColliderHelper.position.add(sphereCollider.center);
                }
            }
            
            // Update box collider position
            if (entity.boxColliderHelper) {
                const boxCollider = entity.getComponent('BoxColliderComponent');
                if (boxCollider) {
                    entity.boxColliderHelper.position.set(transform.x, transform.y, transform.z);
                    entity.boxColliderHelper.position.add(boxCollider.center);
                }
            }
            
            // Update tween helper with pulsing animation
            if (entity.tweenHelper) {
                entity.tweenHelper.position.set(transform.x, transform.y + 1, transform.z);
                
                // Pulsing effect
                const pulse = Math.sin(now * 0.005) * 0.3 + 0.7;
                entity.tweenHelper.material.opacity = pulse;
                
                // Slow rotation
                entity.tweenHelper.rotation.z += 0.02;
            }
            
            // Update animator helper with rotation
            if (entity.animatorHelper) {
                entity.animatorHelper.position.set(transform.x, transform.y + 2.5, transform.z);
                
                // Continuous rotation on multiple axes
                entity.animatorHelper.rotation.x += 0.03;
                entity.animatorHelper.rotation.y += 0.02;
                entity.animatorHelper.rotation.z += 0.01;
            }
            
            // Update Phase 3 component helpers
            if (entity.partyHelper) {
                entity.partyHelper.position.set(transform.x, transform.y + 2, transform.z);
                
                // Gentle bobbing animation for crown
                const bob = Math.sin(now * 0.003) * 0.1;
                entity.partyHelper.position.y += bob;
                
                // Slow rotation
                entity.partyHelper.rotation.y += 0.01;
            }
            
            if (entity.healthBarHelper) {
                entity.healthBarHelper.position.set(transform.x, transform.y + 1.8, transform.z);
                entity.healthBarHelper.lookAt(camera.position);
                
                // Update health bar color based on current health
                const character = entity.getComponent('CharacterComponent');
                if (character) {
                    const healthPercent = character.currentHealth / character.maxHealth;
                    const healthColor = healthPercent > 0.5 ? 0x4caf50 : healthPercent > 0.2 ? 0xffeb3b : 0xf44336;
                    entity.healthBarHelper.material.color.setHex(healthColor);
                    
                    // Scale health bar based on health percentage
                    entity.healthBarHelper.scale.x = healthPercent;
                }
            }
            
            if (entity.levelHelper) {
                entity.levelHelper.position.set(transform.x + 0.7, transform.y + 1.8, transform.z);
                entity.levelHelper.lookAt(camera.position);
                
                // Gentle pulsing for level indicator
                const pulse = Math.sin(now * 0.004) * 0.1 + 0.9;
                entity.levelHelper.scale.setScalar(pulse);
            }
            
            if (entity.aiHelper) {
                entity.aiHelper.position.set(transform.x - 0.7, transform.y + 1.8, transform.z);
                
                // Behavior-specific animations
                const ai = entity.getComponent('AIComponent');
                if (ai) {
                    switch(ai.behaviorType) {
                        case 'follow':
                            // Gentle floating motion
                            entity.aiHelper.position.y += Math.sin(now * 0.005) * 0.1;
                            break;
                        case 'guard':
                            // Steady pulsing
                            const guardPulse = Math.sin(now * 0.003) * 0.2 + 0.8;
                            entity.aiHelper.material.opacity = guardPulse;
                            break;
                        case 'patrol':
                            // Rotating motion
                            entity.aiHelper.rotation.y += 0.02;
                            break;
                        case 'aggressive':
                            // Rapid pulsing
                            const aggroPulse = Math.sin(now * 0.01) * 0.3 + 0.7;
                            entity.aiHelper.material.opacity = aggroPulse;
                            break;
                    }
                }
            }
            
            if (entity.combatHelper) {
                entity.combatHelper.position.set(transform.x, transform.y + 0.1, transform.z);
                
                // Pulsing attack range
                const rangePulse = Math.sin(now * 0.002) * 0.1 + 0.9;
                entity.combatHelper.scale.setScalar(rangePulse);
                
                // Slow rotation
                entity.combatHelper.rotation.z += 0.005;
            }
            
            if (entity.inventoryHelper) {
                entity.inventoryHelper.position.set(transform.x + 0.7, transform.y + 1.2, transform.z);
                
                // Gentle swaying motion
                const sway = Math.sin(now * 0.003) * 0.05;
                entity.inventoryHelper.rotation.z = sway;
                
                // Subtle scaling based on inventory state
                const inventory = entity.getComponent('InventoryComponent');
                if (inventory) {
                    const fillPercent = inventory.currentWeight / inventory.maxWeight;
                    const scale = 0.8 + (fillPercent * 0.4); // Scale from 0.8 to 1.2
                    entity.inventoryHelper.scale.setScalar(scale);
                }
            }
            
            // Update Phase 4 component helpers
            if (entity.villageHelper) {
                entity.villageHelper.position.set(transform.x - 1.0, transform.y + 1.5, transform.z);
                entity.villageRoofHelper.position.set(transform.x - 1.0, transform.y + 1.8, transform.z);
                
                // Gentle house breathing animation
                const breathe = Math.sin(now * 0.002) * 0.05 + 1.0;
                entity.villageHelper.scale.setScalar(breathe);
                
                // Roof sways slightly
                entity.villageRoofHelper.rotation.z = Math.sin(now * 0.001) * 0.02;
            }
            
            if (entity.buildingHelper) {
                entity.buildingHelper.position.set(transform.x + 1.0, transform.y + 1.4, transform.z);
                
                // Update building opacity based on construction progress
                const building = entity.getComponent('BuildingComponent');
                if (building) {
                    const opacity = building.isConstructed ? 0.8 : 0.4 + (building.constructionProgress / 100) * 0.4;
                    entity.buildingHelper.material.opacity = opacity;
                    
                    // Building under construction flickers
                    if (!building.isConstructed && building.constructionStarted) {
                        const flicker = Math.sin(now * 0.01) * 0.1 + 0.9;
                        entity.buildingHelper.material.opacity *= flicker;
                    }
                }
            }
            
            if (entity.resourceHelper) {
                entity.resourceHelper.position.set(transform.x, transform.y + 2.2, transform.z + 1.0);
                
                // Resource stack height based on total resources
                const resource = entity.getComponent('ResourceComponent');
                if (resource) {
                    const totalResources = Object.values(resource.resources).reduce((sum, amount) => sum + amount, 0);
                    const stackHeight = Math.max(0.3, Math.min(1.5, totalResources / 200));
                    entity.resourceHelper.scale.y = stackHeight;
                }
                
                // Gentle rotation
                entity.resourceHelper.rotation.y += 0.005;
            }
            
            if (entity.workerHelper) {
                entity.workerHelper.position.set(transform.x - 0.5, transform.y + 1.5, transform.z - 0.5);
                
                // Tool animation based on work state
                const worker = entity.getComponent('WorkerComponent');
                if (worker && worker.isWorking) {
                    // Working animation - tool moves up and down
                    const workMotion = Math.sin(now * 0.008) * 0.2;
                    entity.workerHelper.position.y += workMotion;
                    entity.workerHelper.rotation.z = Math.PI / 4 + Math.sin(now * 0.008) * 0.3;
                } else {
                    // Idle animation - gentle sway
                    entity.workerHelper.rotation.z = Math.PI / 4 + Math.sin(now * 0.002) * 0.1;
                }
            }
            
            // Update ALL economy coin helpers
            if (entity.economyHelpers && entity.economyHelpers.length > 0) {
                const economy = entity.getComponent('EconomyComponent');
                const economicActivity = economy && Math.random() < 0.001;
                const glint = Math.sin(now * 0.003) * 0.3 + 0.9;
                
                entity.economyHelpers.forEach((coinHelper, index) => {
                    // Update position with stacked height
                    coinHelper.position.set(
                        transform.x + 0.5, 
                        transform.y + 1.0 + (index * 0.1), 
                        transform.z + 0.5
                    );
                    
                    // Coins glint animation (slight variation per coin)
                    const coinGlint = Math.sin(now * 0.003 + index * 0.5) * 0.3 + 0.9;
                    coinHelper.material.opacity = coinGlint;
                    
                    // Slight rotation (different speed per coin)
                    coinHelper.rotation.y += 0.01 + (index * 0.002);
                    
                    // Economic activity causes coins to bounce
                    if (economicActivity) {
                        const bounce = Math.sin(now * 0.02 + index * 0.3) * 0.1;
                        coinHelper.position.y += bounce;
                    }
                });
            }
            
            // Phase 5 visualization updates
            if (entity.questHelper) {
                entity.questHelper.position.set(transform.x - 1.0, transform.y + 1.5, transform.z);
                
                // Quest indicator animation - gentle bobbing
                const questBob = Math.sin(now * 0.003) * 0.1;
                entity.questHelper.position.y += questBob;
                
                // Rotate quest indicator
                entity.questHelper.rotation.y += 0.01;
                
                // Update color based on quest status
                const quest = entity.getComponent('QuestComponent');
                if (quest) {
                    let questColor;
                    switch(quest.status) {
                        case 'available': questColor = 0xffeb3b; break; // Yellow
                        case 'active': questColor = 0x2196f3; break;    // Blue
                        case 'completed': questColor = 0x4caf50; break; // Green
                        case 'failed': questColor = 0xf44336; break;    // Red
                        default: questColor = 0x9e9e9e;                // Gray
                    }
                    entity.questHelper.material.color.setHex(questColor);
                }
            }
            
            if (entity.dialogueHelper) {
                entity.dialogueHelper.position.set(transform.x + 1.5, transform.y + 1.8, transform.z);
                
                // Speech bubble animation - floating and pulsing
                const bubbleFloat = Math.sin(now * 0.004) * 0.15;
                entity.dialogueHelper.position.y += bubbleFloat;
                
                const bubblePulse = 0.8 + Math.sin(now * 0.006) * 0.2;
                entity.dialogueHelper.scale.setScalar(bubblePulse);
                
                // Dialogue activity indicator
                const dialogue = entity.getComponent('DialogueComponent');
                if (dialogue && dialogue.currentDialogue) {
                    entity.dialogueHelper.material.opacity = 0.9;
                } else {
                    entity.dialogueHelper.material.opacity = 0.7;
                }
            }
            
            if (entity.npcHelper) {
                entity.npcHelper.position.set(transform.x, transform.y + 2.0, transform.z + 1.0);
                
                // NPC indicator animation - rotation and activity-based movement
                entity.npcHelper.rotation.x += 0.02;
                entity.npcHelper.rotation.y += 0.015;
                
                const npc = entity.getComponent('NPCComponent');
                if (npc) {
                    // Activity-based animation
                    if (npc.currentActivity === 'work') {
                        const workMotion = Math.sin(now * 0.01) * 0.1;
                        entity.npcHelper.position.y += workMotion;
                    } else if (npc.currentActivity === 'socializing') {
                        const socialSway = Math.sin(now * 0.005) * 0.05;
                        entity.npcHelper.position.x += socialSway;
                    }
                    
                    // Mood-based opacity
                    const averageMood = Object.values(npc.needs).reduce((sum, need) => sum + need, 0) / Object.keys(npc.needs).length;
                    entity.npcHelper.material.opacity = 0.5 + (averageMood / 100) * 0.4;
                }
            }
            
            if (entity.eventHelper) {
                entity.eventHelper.position.set(transform.x - 1.5, transform.y + 2.2, transform.z);
                
                // Event indicator animation
                entity.eventHelper.rotation.x += 0.03;
                entity.eventHelper.rotation.y += 0.02;
                entity.eventHelper.rotation.z += 0.01;
                
                const event = entity.getComponent('EventComponent');
                if (event) {
                    if (event.status === 'active') {
                        // Active events pulse more intensely
                        const activePulse = 0.8 + Math.sin(now * 0.01) * 0.4;
                        entity.eventHelper.scale.setScalar(activePulse);
                        entity.eventHelper.material.opacity = 0.9;
                    } else {
                        // Inactive events gentle pulse
                        const gentlePulse = 0.9 + Math.sin(now * 0.003) * 0.1;
                        entity.eventHelper.scale.setScalar(gentlePulse);
                        entity.eventHelper.material.opacity = 0.6;
                    }
                }
            }
        }
        
        // Component toggle functionality
        function toggleComponent(entity, componentType, component) {
            const wasActive = component.active !== false;
            component.active = !wasActive;
            
            console.log(`üîÑ ${wasActive ? 'Disabled' : 'Enabled'} ${componentType} for entity ${entity.id}`);
            
            // If this is the selected entity, update its visualizations immediately
            if (entity === selectedEntity) {
                // Always refresh visualizations to sync with component active states
                removeColliderVisualization(entity);
                addColliderVisualization(entity);
                
                // Maintain entity selection
                selectedEntity = entity;
            }
            
            // Force immediate update after toggle to show the change
            setTimeout(() => {
                updateInspector();
                updateSelectionUI();
            }, 0);
        }
        
        // Physics and animation components are now integrated directly into ECS
        // Users can add physics/animation components via the inspector using the + button
        
        // Initialize Lucide icons when they're loaded
        window.addEventListener('load', () => {
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
                
                // Re-create icons whenever the inspector updates
                const originalUpdateInspector = updateInspector;
                updateInspector = function() {
                    originalUpdateInspector();
                    setTimeout(() => lucide.createIcons(), 0);
                };
            }
        });
    </script>
</body>
</html>