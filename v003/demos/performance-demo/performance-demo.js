import { TransformComponent } from '../../components/TransformComponent.js';
import { RenderableComponent } from '../../components/RenderableComponent.js';

/**
 * Performance Demo
 * Stress tests the ECS engine with thousands of entities and components
 */
export default class PerformanceDemo {
    constructor(gameEngine) {
        this.gameEngine = gameEngine;
        this.entities = [];
        this.instancedGroups = [];
        
        // Performance test settings
        this.entityCount = 2000;
        this.instancedEntityCount = 5000;
        this.animatedEntityCount = 500;
        
        // Test controls
        this.running = true;
        this.animationsEnabled = true;
        this.cullingEnabled = true;
        
        // Performance tracking
        this.performanceHistory = [];
        this.testResults = {
            entityCreation: 0,
            componentQueries: 0,
            systemUpdates: 0,
            rendering: 0
        };
        
        // Animation state
        this.time = 0;
        this.waveAmplitude = 2;
        this.waveFrequency = 1;
    }
    
    async initialize() {
        console.log('Initializing Performance Demo...');
        console.log(`Target: ${this.entityCount} regular entities + ${this.instancedEntityCount} instanced entities`);\n        \n        const startTime = performance.now();\n        \n        // Create materials and geometries\n        this.materials = this.createMaterials();\n        this.geometries = this.createGeometries();\n        \n        // Create ground\n        this.createGround();\n        \n        // Performance test: Entity creation\n        await this.testEntityCreation();\n        \n        // Performance test: Instanced rendering\n        await this.testInstancedRendering();\n        \n        // Performance test: Component queries\n        this.testComponentQueries();\n        \n        const initTime = performance.now() - startTime;\n        console.log(`Performance Demo initialized in ${initTime.toFixed(2)}ms`);\n        \n        // Start continuous performance monitoring\n        this.startPerformanceMonitoring();\n    }\n    \n    createMaterials() {\n        return {\n            ground: new THREE.MeshLambertMaterial({ color: 0x4CAF50 }),\n            cube: new THREE.MeshLambertMaterial({ color: 0x2196F3 }),\n            sphere: new THREE.MeshLambertMaterial({ color: 0xFF5722 }),\n            instancedCube: new THREE.MeshLambertMaterial({ color: 0x9C27B0 }),\n            instancedSphere: new THREE.MeshLambertMaterial({ color: 0xFFEB3B }),\n            animated: new THREE.MeshLambertMaterial({ color: 0x00BCD4 })\n        };\n    }\n    \n    createGeometries() {\n        return {\n            ground: new THREE.PlaneGeometry(200, 200),\n            cube: new THREE.BoxGeometry(0.5, 0.5, 0.5),\n            sphere: new THREE.SphereGeometry(0.3, 8, 6),\n            largeCube: new THREE.BoxGeometry(1, 1, 1),\n            smallSphere: new THREE.SphereGeometry(0.2, 6, 4)\n        };\n    }\n    \n    createGround() {\n        const groundEntity = this.gameEngine.createEntity();\n        \n        const transform = this.gameEngine.world.acquireComponent(TransformComponent);\n        transform.setPosition(0, 0, 0);\n        transform.setRotation(-Math.PI / 2, 0, 0);\n        this.gameEngine.addComponent(groundEntity, transform);\n        \n        const renderable = this.gameEngine.world.acquireComponent(RenderableComponent);\n        renderable.mesh = new THREE.Mesh(this.geometries.ground, this.materials.ground);\n        renderable.receiveShadow = true;\n        this.gameEngine.addComponent(groundEntity, renderable);\n        \n        this.gameEngine.renderingSystem.addToScene(renderable.mesh);\n        this.entities.push(groundEntity);\n    }\n    \n    async testEntityCreation() {\n        console.log('Testing entity creation performance...');\n        const startTime = performance.now();\n        \n        const geometries = [this.geometries.cube, this.geometries.sphere];\n        const materials = [this.materials.cube, this.materials.sphere];\n        \n        for (let i = 0; i < this.entityCount; i++) {\n            const entity = this.gameEngine.createEntity();\n            \n            // Transform component\n            const transform = this.gameEngine.world.acquireComponent(TransformComponent);\n            \n            // Distribute entities in a grid pattern\n            const gridSize = Math.ceil(Math.sqrt(this.entityCount));\n            const x = (i % gridSize - gridSize / 2) * 2;\n            const z = (Math.floor(i / gridSize) - gridSize / 2) * 2;\n            const y = Math.random() * 3 + 0.5;\n            \n            transform.setPosition(x, y, z);\n            \n            // Random rotation and scale\n            transform.setRotation(\n                Math.random() * Math.PI,\n                Math.random() * Math.PI,\n                Math.random() * Math.PI\n            );\n            \n            const scale = 0.5 + Math.random() * 1.5;\n            transform.setScale(scale, scale, scale);\n            \n            // Add some entities with velocity for animation\n            if (i < this.animatedEntityCount) {\n                transform.setVelocity(\n                    (Math.random() - 0.5) * 2,\n                    0,\n                    (Math.random() - 0.5) * 2\n                );\n                transform.angularVelocity = {\n                    x: (Math.random() - 0.5) * 2,\n                    y: (Math.random() - 0.5) * 2,\n                    z: (Math.random() - 0.5) * 2\n                };\n            }\n            \n            this.gameEngine.addComponent(entity, transform);\n            \n            // Renderable component\n            const renderable = this.gameEngine.world.acquireComponent(RenderableComponent);\n            const geoIndex = i % geometries.length;\n            const matIndex = i % materials.length;\n            \n            renderable.mesh = new THREE.Mesh(geometries[geoIndex], materials[matIndex]);\n            renderable.castShadow = Math.random() > 0.7; // Some cast shadows\n            renderable.receiveShadow = true;\n            \n            // Add LOD for some entities\n            if (i % 10 === 0) {\n                renderable.addLodLevel(renderable.mesh, 0);\n                renderable.addLodLevel(\n                    new THREE.Mesh(this.geometries.smallSphere, materials[matIndex]),\n                    20\n                );\n            }\n            \n            this.gameEngine.addComponent(entity, renderable);\n            \n            // Add to scene\n            this.gameEngine.renderingSystem.addToScene(renderable.mesh);\n            \n            this.entities.push(entity);\n            \n            // Yield periodically to prevent blocking\n            if (i % 100 === 0) {\n                await new Promise(resolve => setTimeout(resolve, 0));\n            }\n        }\n        \n        const entityCreationTime = performance.now() - startTime;\n        this.testResults.entityCreation = entityCreationTime;\n        \n        console.log(`Created ${this.entityCount} entities in ${entityCreationTime.toFixed(2)}ms`);\n        console.log(`Average: ${(entityCreationTime / this.entityCount).toFixed(3)}ms per entity`);\n    }\n    \n    async testInstancedRendering() {\n        console.log('Testing instanced rendering performance...');\n        const startTime = performance.now();\n        \n        // Create instanced mesh groups\n        const instancedConfigs = [\n            {\n                geometry: this.geometries.cube,\n                material: this.materials.instancedCube,\n                count: Math.floor(this.instancedEntityCount * 0.6),\n                name: 'cubes'\n            },\n            {\n                geometry: this.geometries.sphere,\n                material: this.materials.instancedSphere,\n                count: Math.floor(this.instancedEntityCount * 0.4),\n                name: 'spheres'\n            }\n        ];\n        \n        for (const config of instancedConfigs) {\n            const instancedMesh = this.gameEngine.renderingSystem.createInstancedMesh(\n                config.geometry,\n                config.material,\n                config.count\n            );\n            \n            instancedMesh.castShadow = true;\n            instancedMesh.receiveShadow = true;\n            \n            const entities = [];\n            \n            // Create entities for each instance\n            for (let i = 0; i < config.count; i++) {\n                const entity = this.gameEngine.createEntity();\n                \n                const transform = this.gameEngine.world.acquireComponent(TransformComponent);\n                \n                // Distribute in a larger area\n                const angle = (i / config.count) * Math.PI * 2 * 10; // Multiple spirals\n                const radius = 50 + (i / config.count) * 100;\n                const x = Math.cos(angle) * radius;\n                const z = Math.sin(angle) * radius;\n                const y = Math.random() * 10 + 1;\n                \n                transform.setPosition(x, y, z);\n                \n                // Random rotation\n                transform.setRotation(\n                    Math.random() * Math.PI * 2,\n                    Math.random() * Math.PI * 2,\n                    Math.random() * Math.PI * 2\n                );\n                \n                // Random scale\n                const scale = 0.3 + Math.random() * 1.2;\n                transform.setScale(scale, scale, scale);\n                \n                this.gameEngine.addComponent(entity, transform);\n                \n                const renderable = this.gameEngine.world.acquireComponent(RenderableComponent);\n                renderable.setInstanceId(i, instancedMesh);\n                this.gameEngine.addComponent(entity, renderable);\n                \n                entities.push(entity);\n                this.entities.push(entity);\n            }\n            \n            this.instancedGroups.push({\n                mesh: instancedMesh,\n                entities,\n                config\n            });\n            \n            this.gameEngine.renderingSystem.registerInstancedMesh(config.name, instancedMesh);\n            \n            // Yield to prevent blocking\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n        \n        const instancedTime = performance.now() - startTime;\n        this.testResults.rendering = instancedTime;\n        \n        console.log(`Created ${this.instancedEntityCount} instanced entities in ${instancedTime.toFixed(2)}ms`);\n    }\n    \n    testComponentQueries() {\n        console.log('Testing component query performance...');\n        const startTime = performance.now();\n        \n        const iterations = 100;\n        \n        for (let i = 0; i < iterations; i++) {\n            // Test various query types\n            this.gameEngine.query(['TransformComponent']);\n            this.gameEngine.query(['RenderableComponent']);\n            this.gameEngine.query(['TransformComponent', 'RenderableComponent']);\n        }\n        \n        const queryTime = performance.now() - startTime;\n        this.testResults.componentQueries = queryTime;\n        \n        console.log(`Performed ${iterations * 3} component queries in ${queryTime.toFixed(2)}ms`);\n        console.log(`Average: ${(queryTime / (iterations * 3)).toFixed(3)}ms per query`);\n    }\n    \n    update(deltaTime) {\n        if (!this.running) return;\n        \n        this.time += deltaTime;\n        \n        if (this.animationsEnabled) {\n            this.updateAnimations(deltaTime);\n        }\n        \n        // Test system update performance\n        const systemStartTime = performance.now();\n        this.updateInstancedEntities(deltaTime);\n        this.testResults.systemUpdates = performance.now() - systemStartTime;\n        \n        // Stress test: perform additional queries\n        this.performStressQueries();\n    }\n    \n    updateAnimations(deltaTime) {\n        // Animate first batch of entities with physics\n        const animatedEntities = this.entities.slice(1, this.animatedEntityCount + 1);\n        \n        for (const entity of animatedEntities) {\n            const transform = entity.getComponent('TransformComponent');\n            if (transform) {\n                // Bounce off boundaries\n                const bounds = 80;\n                if (Math.abs(transform.position.x) > bounds || Math.abs(transform.position.z) > bounds) {\n                    if (Math.abs(transform.position.x) > bounds) {\n                        transform.velocity.x *= -0.8;\n                        transform.position.x = Math.sign(transform.position.x) * bounds;\n                    }\n                    if (Math.abs(transform.position.z) > bounds) {\n                        transform.velocity.z *= -0.8;\n                        transform.position.z = Math.sign(transform.position.z) * bounds;\n                    }\n                }\n                \n                // Apply gravity and damping\n                if (transform.position.y > 0.5) {\n                    transform.velocity.y -= 9.8 * deltaTime;\n                } else {\n                    transform.position.y = 0.5;\n                    transform.velocity.y = 0;\n                }\n                \n                // Damping\n                transform.velocity.x *= 0.99;\n                transform.velocity.z *= 0.99;\n            }\n        }\n    }\n    \n    updateInstancedEntities(deltaTime) {\n        // Animate instanced entities in waves\n        for (const group of this.instancedGroups) {\n            const waveOffset = group.config.name === 'cubes' ? 0 : Math.PI;\n            \n            for (let i = 0; i < group.entities.length; i++) {\n                const entity = group.entities[i];\n                const transform = entity.getComponent('TransformComponent');\n                \n                if (transform && i % 10 === 0) { // Only animate every 10th entity for performance\n                    const wavePhase = (i / group.entities.length) * Math.PI * 4 + this.time * this.waveFrequency + waveOffset;\n                    const waveY = Math.sin(wavePhase) * this.waveAmplitude;\n                    \n                    // Update Y position with wave\n                    const baseY = 1 + Math.random() * 5;\n                    transform.position.y = baseY + waveY;\n                    \n                    // Slow rotation\n                    transform.rotate(0, deltaTime * 0.5, 0);\n                    \n                    transform.markDirty();\n                }\n            }\n        }\n    }\n    \n    performStressQueries() {\n        // Perform multiple queries to stress test the ECS\n        if (Math.random() > 0.95) { // 5% chance per frame\n            this.gameEngine.query(['TransformComponent']);\n            this.gameEngine.query(['RenderableComponent']);\n            this.gameEngine.query(['TransformComponent', 'RenderableComponent']);\n        }\n    }\n    \n    startPerformanceMonitoring() {\n        setInterval(() => {\n            const stats = this.gameEngine.getStats();\n            \n            this.performanceHistory.push({\n                timestamp: performance.now(),\n                fps: stats.performance.averageFPS,\n                frameTime: stats.performance.frameTime,\n                entities: stats.entities,\n                drawCalls: stats.rendering?.drawCalls || 0,\n                triangles: stats.rendering?.triangles || 0,\n                memory: performance.memory ? (performance.memory.usedJSHeapSize / 1048576) : 0\n            });\n            \n            // Keep only last 60 samples (2 seconds at 30fps)\n            if (this.performanceHistory.length > 60) {\n                this.performanceHistory.shift();\n            }\n            \n        }, 1000 / 30); // 30fps monitoring\n    }\n    \n    // Performance test controls\n    toggleAnimations() {\n        this.animationsEnabled = !this.animationsEnabled;\n        console.log('Animations:', this.animationsEnabled ? 'ON' : 'OFF');\n    }\n    \n    toggleCulling() {\n        this.cullingEnabled = !this.cullingEnabled;\n        \n        // Toggle frustum culling on all entities\n        for (const entity of this.entities) {\n            const renderable = entity.getComponent('RenderableComponent');\n            if (renderable) {\n                renderable.frustumCulled = this.cullingEnabled;\n            }\n        }\n        \n        console.log('Frustum culling:', this.cullingEnabled ? 'ON' : 'OFF');\n    }\n    \n    addMoreEntities(count = 500) {\n        console.log(`Adding ${count} more entities...`);\n        const startTime = performance.now();\n        \n        for (let i = 0; i < count; i++) {\n            const entity = this.gameEngine.createEntity();\n            \n            const transform = this.gameEngine.world.acquireComponent(TransformComponent);\n            transform.setPosition(\n                (Math.random() - 0.5) * 200,\n                Math.random() * 10 + 1,\n                (Math.random() - 0.5) * 200\n            );\n            \n            const scale = 0.3 + Math.random() * 0.7;\n            transform.setScale(scale, scale, scale);\n            \n            this.gameEngine.addComponent(entity, transform);\n            \n            const renderable = this.gameEngine.world.acquireComponent(RenderableComponent);\n            renderable.mesh = new THREE.Mesh(this.geometries.cube, this.materials.animated);\n            this.gameEngine.addComponent(entity, renderable);\n            \n            this.gameEngine.renderingSystem.addToScene(renderable.mesh);\n            this.entities.push(entity);\n        }\n        \n        const addTime = performance.now() - startTime;\n        console.log(`Added ${count} entities in ${addTime.toFixed(2)}ms`);\n    }\n    \n    removeRandomEntities(count = 100) {\n        console.log(`Removing ${count} random entities...`);\n        const startTime = performance.now();\n        \n        const toRemove = [];\n        for (let i = 0; i < Math.min(count, this.entities.length - 1); i++) {\n            const randomIndex = Math.floor(Math.random() * this.entities.length);\n            const entity = this.entities[randomIndex];\n            \n            if (entity && !toRemove.includes(entity) && entity !== this.entities[0]) { // Don't remove ground\n                toRemove.push(entity);\n            }\n        }\n        \n        for (const entity of toRemove) {\n            const renderable = entity.getComponent('RenderableComponent');\n            if (renderable?.mesh) {\n                this.gameEngine.renderingSystem.removeFromScene(renderable.mesh);\n            }\n            \n            this.gameEngine.destroyEntity(entity);\n            const index = this.entities.indexOf(entity);\n            if (index > -1) {\n                this.entities.splice(index, 1);\n            }\n        }\n        \n        const removeTime = performance.now() - startTime;\n        console.log(`Removed ${toRemove.length} entities in ${removeTime.toFixed(2)}ms`);\n    }\n    \n    runBenchmark() {\n        console.log('Running comprehensive benchmark...');\n        \n        const results = {\n            ...this.testResults,\n            currentStats: this.gameEngine.getStats(),\n            performanceHistory: this.performanceHistory.slice(-10), // Last 10 samples\n            entityCount: this.entities.length,\n            timestamp: new Date().toISOString()\n        };\n        \n        console.table(results);\n        return results;\n    }\n    \n    // Get demo statistics\n    getStats() {\n        const baseStats = this.gameEngine.getStats();\n        const recent = this.performanceHistory.slice(-5);\n        const avgFPS = recent.length > 0 ? recent.reduce((sum, s) => sum + s.fps, 0) / recent.length : 0;\n        \n        return {\n            ...baseStats,\n            demo: {\n                name: 'Performance Demo',\n                totalEntities: this.entities.length,\n                regularEntities: this.entityCount,\n                instancedEntities: this.instancedEntityCount,\n                animatedEntities: this.animatedEntityCount,\n                animationsEnabled: this.animationsEnabled,\n                cullingEnabled: this.cullingEnabled,\n                testResults: this.testResults,\n                averageFPS: avgFPS.toFixed(1),\n                running: this.running\n            }\n        };\n    }\n    \n    // Handle input events\n    onKeyPress(key) {\n        switch (key) {\n            case 'KeyA':\n                this.toggleAnimations();\n                break;\n            case 'KeyC':\n                this.toggleCulling();\n                break;\n            case 'Equal': // +\n                this.addMoreEntities(200);\n                break;\n            case 'Minus': // -\n                this.removeRandomEntities(100);\n                break;\n            case 'KeyB':\n                this.runBenchmark();\n                break;\n            case 'KeyP':\n                this.running = !this.running;\n                console.log('Performance demo:', this.running ? 'RUNNING' : 'PAUSED');\n                break;\n            case 'KeyH':\n                this.showHelp();\n                break;\n        }\n    }\n    \n    showHelp() {\n        console.log(`\n⚡ Performance Demo Controls:\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━\nToggle Animations: A\nToggle Culling: C\nAdd Entities: +\nRemove Entities: -\nRun Benchmark: B\nPause/Resume: P\nHelp: H\n\nCurrent: ${this.entities.length} entities\n        `);\n    }\n    \n    // Cleanup\n    destroy() {\n        console.log('Destroying performance demo...');\n        const startTime = performance.now();\n        \n        for (const entity of this.entities) {\n            const renderable = entity.getComponent('RenderableComponent');\n            if (renderable?.mesh) {\n                this.gameEngine.renderingSystem.removeFromScene(renderable.mesh);\n            }\n            this.gameEngine.destroyEntity(entity);\n        }\n        \n        Object.values(this.geometries).forEach(geo => geo.dispose());\n        Object.values(this.materials).forEach(mat => mat.dispose());\n        \n        const destroyTime = performance.now() - startTime;\n        console.log(`Performance Demo destroyed in ${destroyTime.toFixed(2)}ms`);\n    }\n}