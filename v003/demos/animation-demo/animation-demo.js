import { TransformComponent } from '../../components/TransformComponent.js';\nimport { RenderableComponent } from '../../components/RenderableComponent.js';\nimport { InputComponent } from '../../components/InputComponent.js';\nimport { \n    AnimatorComponent, \n    TweenComponent,\n    AnimationClip,\n    AnimationState\n} from '../../components/AnimationComponent.js';\n\n/**\n * Animation Demo\n * Demonstrates animation system capabilities: tweens, keyframes, state machines\n */\nexport default class AnimationDemo {\n    constructor(gameEngine) {\n        this.gameEngine = gameEngine;\n        this.entities = [];\n        this.materials = {};\n        this.geometries = {};\n        \n        // Demo state\n        this.currentDemo = 'basic-tweens';\n        this.demos = [\n            'basic-tweens',\n            'animation-states',\n            'complex-sequences',\n            'physics-animation',\n            'ui-animations'\n        ];\n        this.demoIndex = 0;\n        \n        // Animation control\n        this.globalSpeed = 1.0;\n        this.paused = false;\n        \n        // Demo objects\n        this.tweenObjects = [];\n        this.animatedObjects = [];\n        this.selectedObject = null;\n        \n        // UI elements positions for tweening\n        this.uiElements = [];\n    }\n    \n    async initialize() {\n        console.log('Initializing Animation Demo...');\n        \n        // Create materials and geometries\n        this.createMaterials();\n        this.createGeometries();\n        \n        // Create environment\n        this.createEnvironment();\n        \n        // Start with basic tweens demo\n        this.initializeDemo(this.currentDemo);\n        \n        console.log(`Animation Demo initialized with ${this.currentDemo}`);\n    }\n    \n    createMaterials() {\n        this.materials = {\n            ground: new THREE.MeshLambertMaterial({ color: 0x8BC34A }),\n            cube: new THREE.MeshLambertMaterial({ color: 0x2196F3 }),\n            sphere: new THREE.MeshLambertMaterial({ color: 0xF44336 }),\n            cylinder: new THREE.MeshLambertMaterial({ color: 0xFF9800 }),\n            cone: new THREE.MeshLambertMaterial({ color: 0x9C27B0 }),\n            torus: new THREE.MeshLambertMaterial({ color: 0x4CAF50 }),\n            selected: new THREE.MeshLambertMaterial({ color: 0xFFEB3B, emissive: 0x444400 }),\n            transparent: new THREE.MeshLambertMaterial({ \n                color: 0x81D4FA, \n                transparent: true, \n                opacity: 0.7 \n            }),\n            gradient: new THREE.MeshLambertMaterial({ color: 0xFF5722 })\n        };\n    }\n    \n    createGeometries() {\n        this.geometries = {\n            ground: new THREE.PlaneGeometry(30, 30),\n            cube: new THREE.BoxGeometry(1, 1, 1),\n            sphere: new THREE.SphereGeometry(0.5, 16, 12),\n            cylinder: new THREE.CylinderGeometry(0.5, 0.5, 1, 12),\n            cone: new THREE.ConeGeometry(0.5, 1, 8),\n            torus: new THREE.TorusGeometry(0.5, 0.2, 8, 16),\n            plane: new THREE.PlaneGeometry(2, 2)\n        };\n    }\n    \n    createEnvironment() {\n        // Ground\n        const ground = this.gameEngine.createEntity();\n        const groundTransform = this.gameEngine.world.acquireComponent(TransformComponent);\n        groundTransform.setPosition(0, 0, 0);\n        groundTransform.setRotation(-Math.PI / 2, 0, 0);\n        this.gameEngine.addComponent(ground, groundTransform);\n        \n        const groundRenderable = this.gameEngine.world.acquireComponent(RenderableComponent);\n        groundRenderable.mesh = new THREE.Mesh(this.geometries.ground, this.materials.ground);\n        groundRenderable.receiveShadow = true;\n        this.gameEngine.addComponent(ground, groundRenderable);\n        \n        this.gameEngine.renderingSystem.addToScene(groundRenderable.mesh);\n        this.entities.push(ground);\n    }\n    \n    // Demo initialization methods\n    initializeDemo(demo) {\n        this.clearDemoObjects();\n        \n        switch (demo) {\n            case 'basic-tweens':\n                this.initBasicTweens();\n                break;\n            case 'animation-states':\n                this.initAnimationStates();\n                break;\n            case 'complex-sequences':\n                this.initComplexSequences();\n                break;\n            case 'physics-animation':\n                this.initPhysicsAnimation();\n                break;\n            case 'ui-animations':\n                this.initUIAnimations();\n                break;\n        }\n    }\n    \n    initBasicTweens() {\n        // Create objects for different tween types\n        const tweenTypes = [\n            { name: 'Position', pos: { x: -6, y: 1, z: 0 }, geo: 'cube', mat: 'cube' },\n            { name: 'Rotation', pos: { x: -3, y: 1, z: 0 }, geo: 'cylinder', mat: 'cylinder' },\n            { name: 'Scale', pos: { x: 0, y: 1, z: 0 }, geo: 'sphere', mat: 'sphere' },\n            { name: 'Opacity', pos: { x: 3, y: 1, z: 0 }, geo: 'cone', mat: 'transparent' },\n            { name: 'Color', pos: { x: 6, y: 1, z: 0 }, geo: 'torus', mat: 'gradient' }\n        ];\n        \n        tweenTypes.forEach((type, index) => {\n            const entity = this.createAnimatedObject(\n                type.pos,\n                this.geometries[type.geo],\n                this.materials[type.mat]\n            );\n            \n            // Add TweenComponent\n            const tweenComponent = this.gameEngine.world.acquireComponent(TweenComponent);\n            this.gameEngine.addComponent(entity, tweenComponent);\n            \n            // Create different types of tweens\n            this.createBasicTween(entity, type.name, index);\n            \n            this.tweenObjects.push({ entity, type: type.name });\n        });\n    }\n    \n    createBasicTween(entity, type, index) {\n        const transform = entity.getComponent('TransformComponent');\n        const renderable = entity.getComponent('RenderableComponent');\n        const tweenComponent = entity.getComponent('TweenComponent');\n        \n        const delay = index * 0.5; // Stagger animations\n        \n        switch (type) {\n            case 'Position':\n                // Bounce up and down\n                tweenComponent.to(transform.position, 2, { y: 4 }, {\n                    ease: 'bounce-out',\n                    delay: delay,\n                    yoyo: true,\n                    loop: true\n                });\n                break;\n                \n            case 'Rotation':\n                // Spin continuously\n                tweenComponent.to(transform.rotation, 3, { y: Math.PI * 2 }, {\n                    ease: 'linear',\n                    delay: delay,\n                    loop: true\n                });\n                break;\n                \n            case 'Scale':\n                // Pulse scale\n                tweenComponent.to(transform.scale, 1.5, {\n                    x: 1.5, y: 1.5, z: 1.5\n                }, {\n                    ease: 'ease-in-out',\n                    delay: delay,\n                    yoyo: true,\n                    loop: true\n                });\n                break;\n                \n            case 'Opacity':\n                // Fade in and out\n                if (renderable.mesh.material.transparent) {\n                    tweenComponent.to(renderable.mesh.material, 2, { opacity: 0.1 }, {\n                        ease: 'ease-in-out',\n                        delay: delay,\n                        yoyo: true,\n                        loop: true\n                    });\n                }\n                break;\n                \n            case 'Color':\n                // Color cycling (simplified)\n                const colors = [0xFF5722, 0x4CAF50, 0x2196F3, 0x9C27B0];\n                let colorIndex = 0;\n                \n                const colorTween = () => {\n                    const nextColor = colors[colorIndex % colors.length];\n                    tweenComponent.to(renderable.mesh.material.color, 1, {\n                        r: ((nextColor >> 16) & 255) / 255,\n                        g: ((nextColor >> 8) & 255) / 255,\n                        b: (nextColor & 255) / 255\n                    }, {\n                        ease: 'ease-in-out',\n                        onComplete: () => {\n                            colorIndex++;\n                            setTimeout(colorTween, 500);\n                        }\n                    });\n                };\n                \n                setTimeout(colorTween, delay * 1000);\n                break;\n        }\n    }\n    \n    initAnimationStates() {\n        // Create objects with state machine animations\n        const stateObjects = [\n            { name: 'Idle-Walk-Run', pos: { x: -4, y: 1, z: 0 } },\n            { name: 'Attack-Combo', pos: { x: 0, y: 1, z: 0 } },\n            { name: 'Jump-Land', pos: { x: 4, y: 1, z: 0 } }\n        ];\n        \n        stateObjects.forEach(obj => {\n            const entity = this.createAnimatedObject(\n                obj.pos,\n                this.geometries.cube,\n                this.materials.cube\n            );\n            \n            // Add AnimatorComponent\n            const animator = this.gameEngine.world.acquireComponent(AnimatorComponent);\n            this.gameEngine.addComponent(entity, animator);\n            \n            // Create animation states\n            this.createStateMachine(entity, obj.name);\n            \n            this.animatedObjects.push({ entity, type: obj.name });\n        });\n    }\n    \n    createStateMachine(entity, type) {\n        const animator = entity.getComponent('AnimatorComponent');\n        const transform = entity.getComponent('TransformComponent');\n        \n        switch (type) {\n            case 'Idle-Walk-Run':\n                // Create animation clips\n                const idleClip = this.gameEngine.animationSystem.createClip('idle', 2);\n                idleClip.addTrack('position.y', [\n                    { time: 0, value: 1 },\n                    { time: 1, value: 1.2 },\n                    { time: 2, value: 1 }\n                ]);\n                \n                const walkClip = this.gameEngine.animationSystem.createClip('walk', 1);\n                walkClip.addTrack('position', [\n                    { time: 0, value: { x: transform.position.x, y: 1, z: 0 } },\n                    { time: 0.5, value: { x: transform.position.x + 2, y: 1.5, z: 0 } },\n                    { time: 1, value: { x: transform.position.x + 4, y: 1, z: 0 } }\n                ]);\n                \n                const runClip = this.gameEngine.animationSystem.createClip('run', 0.5);\n                runClip.addTrack('position', [\n                    { time: 0, value: { x: transform.position.x, y: 1, z: 0 } },\n                    { time: 0.25, value: { x: transform.position.x + 3, y: 2, z: 0 } },\n                    { time: 0.5, value: { x: transform.position.x + 6, y: 1, z: 0 } }\n                ]);\n                \n                // Add states\n                animator.addState('idle', idleClip, true);\n                animator.addState('walk', walkClip);\n                animator.addState('run', runClip);\n                \n                // Add transitions\n                animator.addTransition('idle', 'walk', \n                    (params) => params?.get('speed') > 0.5, 0.3);\n                animator.addTransition('walk', 'run', \n                    (params) => params?.get('speed') > 1.5, 0.2);\n                animator.addTransition('run', 'walk', \n                    (params) => params?.get('speed') <= 1.5, 0.2);\n                animator.addTransition('walk', 'idle', \n                    (params) => params?.get('speed') <= 0.5, 0.5);\n                \n                // Auto-cycle through states\n                let speed = 0;\n                const cycleSpeed = () => {\n                    speed = Math.sin(Date.now() * 0.001) * 2 + 1;\n                    animator.setFloat('speed', speed);\n                    setTimeout(cycleSpeed, 100);\n                };\n                cycleSpeed();\n                \n                break;\n                \n            case 'Attack-Combo':\n                // Attack sequence animations\n                const attack1Clip = this.gameEngine.animationSystem.createClip('attack1', 0.5);\n                attack1Clip.addTrack('scale', [\n                    { time: 0, value: { x: 1, y: 1, z: 1 } },\n                    { time: 0.2, value: { x: 1.5, y: 0.8, z: 1.5 } },\n                    { time: 0.5, value: { x: 1, y: 1, z: 1 } }\n                ]);\n                \n                const attack2Clip = this.gameEngine.animationSystem.createClip('attack2', 0.6);\n                attack2Clip.addTrack('rotation.y', [\n                    { time: 0, value: 0 },\n                    { time: 0.3, value: Math.PI },\n                    { time: 0.6, value: Math.PI * 2 }\n                ]);\n                \n                const comboClip = this.gameEngine.animationSystem.createClip('combo', 1);\n                comboClip.addTrack('position.y', [\n                    { time: 0, value: 1 },\n                    { time: 0.3, value: 3 },\n                    { time: 0.7, value: 3 },\n                    { time: 1, value: 1 }\n                ]);\n                \n                animator.addState('idle-combat', idleClip, true);\n                animator.addState('attack1', attack1Clip);\n                animator.addState('attack2', attack2Clip);\n                animator.addState('combo', comboClip);\n                \n                // Set up combo system\n                let comboCount = 0;\n                const triggerCombo = () => {\n                    comboCount++;\n                    if (comboCount === 1) {\n                        animator.play('attack1');\n                    } else if (comboCount === 2) {\n                        animator.play('attack2');\n                    } else {\n                        animator.play('combo');\n                        comboCount = 0;\n                    }\n                    \n                    setTimeout(() => {\n                        if (comboCount === 0) {\n                            animator.play('idle-combat');\n                        }\n                    }, 1000);\n                };\n                \n                // Auto-trigger combos\n                const autoCombo = () => {\n                    triggerCombo();\n                    setTimeout(autoCombo, 2000 + Math.random() * 3000);\n                };\n                setTimeout(autoCombo, 1000);\n                \n                break;\n                \n            case 'Jump-Land':\n                // Jump animation with physics-like motion\n                const jumpClip = this.gameEngine.animationSystem.createClip('jump', 1.5);\n                jumpClip.addTrack('position.y', [\n                    { time: 0, value: 1 },\n                    { time: 0.4, value: 4 },\n                    { time: 1.2, value: 4 },\n                    { time: 1.5, value: 1 }\n                ]);\n                jumpClip.addTrack('scale', [\n                    { time: 0, value: { x: 1, y: 1, z: 1 } },\n                    { time: 0.1, value: { x: 0.8, y: 1.3, z: 0.8 } },\n                    { time: 0.4, value: { x: 1.2, y: 0.8, z: 1.2 } },\n                    { time: 1.2, value: { x: 1.2, y: 0.8, z: 1.2 } },\n                    { time: 1.4, value: { x: 0.7, y: 1.5, z: 0.7 } },\n                    { time: 1.5, value: { x: 1, y: 1, z: 1 } }\n                ]);\n                \n                const landClip = this.gameEngine.animationSystem.createClip('land', 0.3);\n                landClip.addTrack('scale', [\n                    { time: 0, value: { x: 1.3, y: 0.7, z: 1.3 } },\n                    { time: 0.15, value: { x: 0.9, y: 1.1, z: 0.9 } },\n                    { time: 0.3, value: { x: 1, y: 1, z: 1 } }\n                ]);\n                \n                animator.addState('ground', idleClip, true);\n                animator.addState('jumping', jumpClip);\n                animator.addState('landing', landClip);\n                \n                // Auto-jump cycle\n                const jumpCycle = () => {\n                    animator.play('jumping');\n                    setTimeout(() => {\n                        animator.play('landing');\n                        setTimeout(() => {\n                            animator.play('ground');\n                            setTimeout(jumpCycle, 2000);\n                        }, 300);\n                    }, 1500);\n                };\n                setTimeout(jumpCycle, 1000);\n                \n                break;\n        }\n    }\n    \n    initComplexSequences() {\n        // Create objects that demonstrate complex animation sequences\n        const sequenceCount = 5;\n        \n        for (let i = 0; i < sequenceCount; i++) {\n            const entity = this.createAnimatedObject(\n                { x: (i - 2) * 3, y: 1, z: 0 },\n                this.geometries.sphere,\n                this.materials.sphere\n            );\n            \n            const tweenComponent = this.gameEngine.world.acquireComponent(TweenComponent);\n            this.gameEngine.addComponent(entity, tweenComponent);\n            \n            this.createComplexSequence(entity, i);\n            this.tweenObjects.push({ entity, type: 'sequence' });\n        }\n    }\n    \n    createComplexSequence(entity, index) {\n        const transform = entity.getComponent('TransformComponent');\n        const renderable = entity.getComponent('RenderableComponent');\n        const tweenComponent = entity.getComponent('TweenComponent');\n        \n        const startDelay = index * 1; // Stagger sequences\n        \n        // Create a complex sequence using the animation system's sequence builder\n        const animationSequence = [\n            {\n                createTween: (entity) => {\n                    const transform = entity.getComponent('TransformComponent');\n                    return tweenComponent.to(transform.position, 1, { y: 5 }, { ease: 'ease-out' });\n                },\n                duration: 1,\n                delay: startDelay\n            },\n            {\n                createTween: (entity) => {\n                    const transform = entity.getComponent('TransformComponent');\n                    return tweenComponent.to(transform.rotation, 0.5, { y: Math.PI * 2 }, { ease: 'linear' });\n                },\n                duration: 0.5\n            },\n            {\n                createTween: (entity) => {\n                    const transform = entity.getComponent('TransformComponent');\n                    return tweenComponent.to(transform.scale, 0.5, {\n                        x: 2, y: 2, z: 2\n                    }, { ease: 'bounce-out' });\n                },\n                duration: 0.5\n            },\n            {\n                createTween: (entity) => {\n                    const transform = entity.getComponent('TransformComponent');\n                    return tweenComponent.to(transform.position, 1, {\n                        x: transform.position.x + (Math.random() - 0.5) * 10,\n                        z: transform.position.z + (Math.random() - 0.5) * 10\n                    }, { ease: 'ease-in-out' });\n                },\n                duration: 1\n            },\n            {\n                createTween: (entity) => {\n                    const transform = entity.getComponent('TransformComponent');\n                    const tweenComponent = entity.getComponent('TweenComponent');\n                    \n                    // Parallel animations\n                    tweenComponent.to(transform.position, 1, { y: 1 }, { ease: 'bounce-out' });\n                    tweenComponent.to(transform.scale, 0.8, { x: 1, y: 1, z: 1 }, { ease: 'ease-out' });\n                    \n                    return null; // Already created tweens\n                },\n                duration: 1\n            }\n        ];\n        \n        // Execute sequence\n        this.gameEngine.animationSystem.createSequence(entity, animationSequence);\n    }\n    \n    initPhysicsAnimation() {\n        console.log('Physics Animation demo - requires physics system integration');\n        // This would demonstrate animations that work with physics\n        // For now, create simple physics-influenced animations\n        \n        for (let i = 0; i < 3; i++) {\n            const entity = this.createAnimatedObject(\n                { x: (i - 1) * 4, y: 5, z: 0 },\n                this.geometries.cube,\n                this.materials.cube\n            );\n            \n            const tweenComponent = this.gameEngine.world.acquireComponent(TweenComponent);\n            this.gameEngine.addComponent(entity, tweenComponent);\n            \n            // Simulate gravity with easing\n            const transform = entity.getComponent('TransformComponent');\n            const fallTween = tweenComponent.to(transform.position, 2, { y: 1 }, {\n                ease: 'ease-in',\n                onComplete: () => {\n                    // Bounce effect\n                    tweenComponent.to(transform.position, 0.5, { y: 2 }, {\n                        ease: 'ease-out',\n                        onComplete: () => {\n                            tweenComponent.to(transform.position, 0.3, { y: 1 }, { ease: 'ease-in' });\n                        }\n                    });\n                }\n            });\n            \n            // Add spin during fall\n            tweenComponent.to(transform.rotation, 2.8, {\n                x: Math.PI * 4,\n                y: Math.PI * 2,\n                z: Math.PI * 3\n            }, { ease: 'linear' });\n            \n            this.tweenObjects.push({ entity, type: 'physics' });\n        }\n    }\n    \n    initUIAnimations() {\n        // Create UI-style elements and animate them\n        const uiElements = [\n            { name: 'Button', pos: { x: -6, y: 2, z: 0 }, size: { x: 2, y: 0.5, z: 0.1 } },\n            { name: 'Panel', pos: { x: -2, y: 2, z: 0 }, size: { x: 3, y: 2, z: 0.1 } },\n            { name: 'Icon', pos: { x: 2, y: 2, z: 0 }, size: { x: 1, y: 1, z: 0.1 } },\n            { name: 'Progress', pos: { x: 6, y: 2, z: 0 }, size: { x: 2, y: 0.3, z: 0.1 } }\n        ];\n        \n        uiElements.forEach((element, index) => {\n            const entity = this.createUIElement(element);\n            this.createUIAnimation(entity, element.name, index);\n            this.uiElements.push({ entity, type: element.name });\n        });\n    }\n    \n    createUIElement(element) {\n        const entity = this.gameEngine.createEntity();\n        \n        const transform = this.gameEngine.world.acquireComponent(TransformComponent);\n        transform.setPosition(element.pos.x, element.pos.y, element.pos.z);\n        this.gameEngine.addComponent(entity, transform);\n        \n        const renderable = this.gameEngine.world.acquireComponent(RenderableComponent);\n        const geometry = new THREE.BoxGeometry(element.size.x, element.size.y, element.size.z);\n        renderable.mesh = new THREE.Mesh(geometry, this.materials.transparent);\n        this.gameEngine.addComponent(entity, renderable);\n        \n        const tweenComponent = this.gameEngine.world.acquireComponent(TweenComponent);\n        this.gameEngine.addComponent(entity, tweenComponent);\n        \n        this.gameEngine.renderingSystem.addToScene(renderable.mesh);\n        this.entities.push(entity);\n        \n        return entity;\n    }\n    \n    createUIAnimation(entity, type, index) {\n        const transform = entity.getComponent('TransformComponent');\n        const renderable = entity.getComponent('RenderableComponent');\n        const tweenComponent = entity.getComponent('TweenComponent');\n        \n        const delay = index * 0.3;\n        \n        switch (type) {\n            case 'Button':\n                // Button hover effect\n                const buttonHover = () => {\n                    tweenComponent.to(transform.scale, 0.2, {\n                        x: 1.1, y: 1.1, z: 1.1\n                    }, {\n                        ease: 'ease-out',\n                        onComplete: () => {\n                            tweenComponent.to(transform.scale, 0.2, {\n                                x: 1, y: 1, z: 1\n                            }, {\n                                ease: 'ease-in',\n                                onComplete: () => setTimeout(buttonHover, 2000 + Math.random() * 1000)\n                            });\n                        }\n                    });\n                };\n                setTimeout(buttonHover, delay * 1000);\n                break;\n                \n            case 'Panel':\n                // Panel slide in from side\n                const originalX = transform.position.x;\n                transform.position.x = -15;\n                \n                setTimeout(() => {\n                    tweenComponent.to(transform.position, 1, { x: originalX }, {\n                        ease: 'elastic-out'\n                    });\n                }, delay * 1000);\n                break;\n                \n            case 'Icon':\n                // Icon bounce and rotate\n                const iconBounce = () => {\n                    tweenComponent.to(transform.position, 0.5, { y: 4 }, {\n                        ease: 'ease-out',\n                        onComplete: () => {\n                            tweenComponent.to(transform.position, 0.5, { y: 2 }, {\n                                ease: 'bounce-out'\n                            });\n                        }\n                    });\n                    \n                    tweenComponent.to(transform.rotation, 1, {\n                        z: transform.rotation.z + Math.PI * 2\n                    }, { ease: 'ease-in-out' });\n                    \n                    setTimeout(iconBounce, 3000);\n                };\n                setTimeout(iconBounce, delay * 1000);\n                break;\n                \n            case 'Progress':\n                // Progress bar fill animation\n                const originalScaleX = transform.scale.x;\n                transform.scale.x = 0;\n                \n                setTimeout(() => {\n                    tweenComponent.to(transform.scale, 2, { x: originalScaleX }, {\n                        ease: 'ease-out',\n                        onComplete: () => {\n                            // Reset and repeat\n                            setTimeout(() => {\n                                transform.scale.x = 0;\n                                tweenComponent.to(transform.scale, 2, { x: originalScaleX }, {\n                                    ease: 'ease-out'\n                                });\n                            }, 1000);\n                        }\n                    });\n                }, delay * 1000);\n                break;\n        }\n    }\n    \n    createAnimatedObject(position, geometry, material) {\n        const entity = this.gameEngine.createEntity();\n        \n        const transform = this.gameEngine.world.acquireComponent(TransformComponent);\n        transform.setPosition(position.x, position.y, position.z);\n        this.gameEngine.addComponent(entity, transform);\n        \n        const renderable = this.gameEngine.world.acquireComponent(RenderableComponent);\n        renderable.mesh = new THREE.Mesh(geometry, material);\n        renderable.castShadow = true;\n        this.gameEngine.addComponent(entity, renderable);\n        \n        this.gameEngine.renderingSystem.addToScene(renderable.mesh);\n        this.entities.push(entity);\n        \n        return entity;\n    }\n    \n    // Demo management\n    clearDemoObjects() {\n        // Clear previous demo objects but keep environment\n        const toRemove = [...this.tweenObjects, ...this.animatedObjects, ...this.uiElements];\n        \n        for (const obj of toRemove) {\n            this.removeEntity(obj.entity);\n        }\n        \n        this.tweenObjects = [];\n        this.animatedObjects = [];\n        this.uiElements = [];\n    }\n    \n    removeEntity(entity) {\n        const renderable = entity.getComponent('RenderableComponent');\n        if (renderable?.mesh) {\n            this.gameEngine.renderingSystem.removeFromScene(renderable.mesh);\n        }\n        \n        const index = this.entities.indexOf(entity);\n        if (index > -1) {\n            this.entities.splice(index, 1);\n        }\n        \n        this.gameEngine.destroyEntity(entity);\n    }\n    \n    update(deltaTime) {\n        // Update demo-specific logic\n        if (this.selectedObject) {\n            this.updateSelectedObject();\n        }\n    }\n    \n    updateSelectedObject() {\n        const renderable = this.selectedObject.getComponent('RenderableComponent');\n        if (renderable?.mesh) {\n            // Highlight selected object\n            renderable.mesh.material = this.materials.selected;\n        }\n    }\n    \n    // Input handling\n    onKeyPress(key) {\n        switch (key) {\n            case 'Space':\n                this.toggleAnimations();\n                break;\n                \n            case 'KeyR':\n                this.restartCurrentDemo();\n                break;\n                \n            case 'KeyM':\n                this.nextDemo();\n                break;\n                \n            case 'ArrowUp':\n                this.adjustSpeed(0.1);\n                break;\n                \n            case 'ArrowDown':\n                this.adjustSpeed(-0.1);\n                break;\n                \n            case 'Digit1':\n            case 'Digit2':\n            case 'Digit3':\n            case 'Digit4':\n            case 'Digit5':\n                const demoIndex = parseInt(key.slice(-1)) - 1;\n                if (demoIndex < this.demos.length) {\n                    this.setDemo(this.demos[demoIndex]);\n                }\n                break;\n                \n            case 'KeyH':\n                this.showHelp();\n                break;\n        }\n    }\n    \n    onMouseClick(event, intersects) {\n        if (intersects.length > 0) {\n            const mesh = intersects[0].object;\n            const entity = this.entities.find(e => {\n                const renderable = e.getComponent('RenderableComponent');\n                return renderable?.mesh === mesh;\n            });\n            \n            if (entity) {\n                this.selectObject(entity);\n            }\n        } else {\n            this.selectObject(null);\n        }\n    }\n    \n    selectObject(entity) {\n        // Reset previous selection\n        if (this.selectedObject) {\n            const prevRenderable = this.selectedObject.getComponent('RenderableComponent');\n            if (prevRenderable?.mesh) {\n                // Restore original material (this is simplified)\n                prevRenderable.mesh.material = this.materials.cube;\n            }\n        }\n        \n        this.selectedObject = entity;\n        \n        if (entity) {\n            console.log(`Selected entity ${entity.id}`);\n        }\n    }\n    \n    // Demo controls\n    nextDemo() {\n        this.demoIndex = (this.demoIndex + 1) % this.demos.length;\n        this.setDemo(this.demos[this.demoIndex]);\n    }\n    \n    setDemo(demo) {\n        if (this.demos.includes(demo)) {\n            this.currentDemo = demo;\n            this.demoIndex = this.demos.indexOf(demo);\n            this.initializeDemo(demo);\n            console.log(`Switched to ${demo} demo`);\n        }\n    }\n    \n    restartCurrentDemo() {\n        this.initializeDemo(this.currentDemo);\n        console.log(`Restarted ${this.currentDemo} demo`);\n    }\n    \n    toggleAnimations() {\n        if (this.gameEngine.animationSystem) {\n            if (this.paused) {\n                this.gameEngine.animationSystem.resumeAll();\n                this.paused = false;\n                console.log('Animations resumed');\n            } else {\n                this.gameEngine.animationSystem.pauseAll();\n                this.paused = true;\n                console.log('Animations paused');\n            }\n        }\n    }\n    \n    adjustSpeed(delta) {\n        this.globalSpeed = Math.max(0.1, Math.min(3.0, this.globalSpeed + delta));\n        if (this.gameEngine.animationSystem) {\n            this.gameEngine.animationSystem.setGlobalTimeScale(this.globalSpeed);\n        }\n        console.log(`Animation speed: ${this.globalSpeed.toFixed(1)}x`);\n    }\n    \n    // Get demo statistics\n    getStats() {\n        const baseStats = this.gameEngine.getStats();\n        const animationStats = this.gameEngine.animationSystem?.getStats() || {};\n        \n        return {\n            ...baseStats,\n            demo: {\n                name: 'Animation Demo',\n                currentDemo: this.currentDemo,\n                totalObjects: this.entities.length,\n                tweenObjects: this.tweenObjects.length,\n                animatedObjects: this.animatedObjects.length,\n                uiElements: this.uiElements.length,\n                globalSpeed: this.globalSpeed,\n                paused: this.paused\n            },\n            animation: animationStats\n        };\n    }\n    \n    showHelp() {\n        console.log(`\n🎬 Animation Demo Controls:\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\nDemo Control:\n1-5: Switch demo types\nM: Next demo\nR: Restart demo\n\nAnimation Control:\nSpace: Pause/Resume\n↑/↓: Speed up/down\nClick: Select object\nH: Help\n\nCurrent Demo: ${this.currentDemo}\nDemos: ${this.demos.join(', ')}\nSpeed: ${this.globalSpeed.toFixed(1)}x\n        `);\n    }\n    \n    // Cleanup\n    destroy() {\n        for (const entity of this.entities) {\n            const renderable = entity.getComponent('RenderableComponent');\n            if (renderable?.mesh) {\n                this.gameEngine.renderingSystem.removeFromScene(renderable.mesh);\n            }\n            this.gameEngine.destroyEntity(entity);\n        }\n        \n        Object.values(this.geometries).forEach(geo => geo.dispose());\n        Object.values(this.materials).forEach(mat => mat.dispose());\n        \n        console.log('Animation Demo destroyed');\n    }\n}";