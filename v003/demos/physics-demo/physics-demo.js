import { TransformComponent } from '../../components/TransformComponent.js';
import { RenderableComponent } from '../../components/RenderableComponent.js';
import { InputComponent } from '../../components/InputComponent.js';
import { 
    RigidbodyComponent, 
    BoxColliderComponent, 
    SphereColliderComponent, 
    PlaneColliderComponent,
    PhysicsMaterialComponent 
} from '../../components/PhysicsComponent.js';

/**
 * Physics Demo
 * Demonstrates physics system capabilities: collisions, forces, materials
 */
export default class PhysicsDemo {
    constructor(gameEngine) {
        this.gameEngine = gameEngine;
        this.entities = [];
        this.materials = {};
        this.geometries = {};
        
        // Demo state
        this.gravityEnabled = true;
        this.showColliders = true;
        this.spawnRate = 1.0; // Objects per second
        this.spawnTimer = 0;
        this.maxObjects = 50;
        
        // Physics materials
        this.physicsMaterials = {};
        
        // Interaction
        this.selectedObject = null;
        this.mouseForce = 10;
        
        // Demo modes
        this.currentMode = 'bouncing-balls';
        this.modes = [
            'bouncing-balls',
            'collision-test',
            'stack-demo',
            'force-field',
            'friction-test'
        ];
        this.modeIndex = 0;
    }
    
    async initialize() {
        console.log('Initializing Physics Demo...');
        
        // Create materials and geometries
        this.createMaterials();
        this.createGeometries();
        this.createPhysicsMaterials();
        
        // Create environment
        this.createEnvironment();
        
        // Start with bouncing balls demo
        this.initializeMode(this.currentMode);
        
        console.log(`Physics Demo initialized in ${this.currentMode} mode`);
    }
    
    createMaterials() {
        this.materials = {
            ground: new THREE.MeshLambertMaterial({ color: 0x8BC34A }),
            wall: new THREE.MeshLambertMaterial({ color: 0x795548 }),
            ball: new THREE.MeshLambertMaterial({ color: 0xF44336 }),
            box: new THREE.MeshLambertMaterial({ color: 0x2196F3 }),
            bouncy: new THREE.MeshLambertMaterial({ color: 0xFF9800 }),
            heavy: new THREE.MeshLambertMaterial({ color: 0x9C27B0 }),
            light: new THREE.MeshLambertMaterial({ color: 0x4CAF50 }),
            ice: new THREE.MeshLambertMaterial({ color: 0x81D4FA, transparent: true, opacity: 0.8 }),
            rubber: new THREE.MeshLambertMaterial({ color: 0xFFEB3B }),
            metal: new THREE.MeshLambertMaterial({ color: 0x607D8B }),
            collider: new THREE.MeshBasicMaterial({ 
                color: 0x00FF00, 
                wireframe: true, 
                transparent: true, 
                opacity: 0.3 
            })
        };
    }
    
    createGeometries() {
        this.geometries = {
            ground: new THREE.PlaneGeometry(50, 50),
            wall: new THREE.BoxGeometry(1, 5, 20),
            smallBox: new THREE.BoxGeometry(1, 1, 1),
            mediumBox: new THREE.BoxGeometry(1.5, 1.5, 1.5),
            largeBox: new THREE.BoxGeometry(2, 2, 2),
            smallSphere: new THREE.SphereGeometry(0.5, 12, 8),
            mediumSphere: new THREE.SphereGeometry(0.75, 16, 12),
            largeSphere: new THREE.SphereGeometry(1, 20, 16),
            cylinder: new THREE.CylinderGeometry(0.5, 0.5, 2, 12),
            cone: new THREE.ConeGeometry(0.5, 1.5, 8),
            colliderBox: new THREE.BoxGeometry(1, 1, 1),
            colliderSphere: new THREE.SphereGeometry(0.5, 8, 6)
        };
    }
    
    createPhysicsMaterials() {
        // Create different physics materials for testing
        const bouncy = this.gameEngine.world.acquireComponent(PhysicsMaterialComponent);
        bouncy.restitution = 0.9;\n        bouncy.friction = 0.1;\n        bouncy.density = 0.5;\n        this.physicsMaterials.bouncy = bouncy;\n        \n        const ice = this.gameEngine.world.acquireComponent(PhysicsMaterialComponent);\n        ice.restitution = 0.1;\n        ice.friction = 0.05;\n        ice.density = 0.8;\n        this.physicsMaterials.ice = ice;\n        \n        const rubber = this.gameEngine.world.acquireComponent(PhysicsMaterialComponent);\n        rubber.restitution = 0.8;\n        rubber.friction = 0.8;\n        rubber.density = 1.2;\n        this.physicsMaterials.rubber = rubber;\n        \n        const metal = this.gameEngine.world.acquireComponent(PhysicsMaterialComponent);\n        metal.restitution = 0.3;\n        metal.friction = 0.6;\n        metal.density = 7.8;\n        this.physicsMaterials.metal = metal;\n        \n        const wood = this.gameEngine.world.acquireComponent(PhysicsMaterialComponent);\n        wood.restitution = 0.4;\n        wood.friction = 0.7;\n        wood.density = 0.6;\n        this.physicsMaterials.wood = wood;\n    }\n    \n    createEnvironment() {\n        // Ground plane\n        const ground = this.createStaticPlane(\n            { x: 0, y: 0, z: 0 },\n            { x: 0, y: 1, z: 0 },\n            this.materials.ground\n        );\n        \n        // Walls\n        this.createWall({ x: -25, y: 2.5, z: 0 }, this.materials.wall);\n        this.createWall({ x: 25, y: 2.5, z: 0 }, this.materials.wall);\n        this.createWall({ x: 0, y: 2.5, z: -25 }, this.materials.wall, { x: 0, y: Math.PI/2, z: 0 });\n        this.createWall({ x: 0, y: 2.5, z: 25 }, this.materials.wall, { x: 0, y: Math.PI/2, z: 0 });\n    }\n    \n    createStaticPlane(position, normal, material) {\n        const entity = this.gameEngine.createEntity();\n        \n        // Transform\n        const transform = this.gameEngine.world.acquireComponent(TransformComponent);\n        transform.setPosition(position.x, position.y, position.z);\n        transform.setRotation(-Math.PI / 2, 0, 0);\n        this.gameEngine.addComponent(entity, transform);\n        \n        // Renderable\n        const renderable = this.gameEngine.world.acquireComponent(RenderableComponent);\n        renderable.mesh = new THREE.Mesh(this.geometries.ground, material);\n        renderable.receiveShadow = true;\n        this.gameEngine.addComponent(entity, renderable);\n        \n        // Physics - Plane Collider\n        const collider = this.gameEngine.world.acquireComponent(PlaneColliderComponent);\n        collider.setNormal(normal.x, normal.y, normal.z);\n        collider.material = this.physicsMaterials.wood;\n        this.gameEngine.addComponent(entity, collider);\n        \n        this.gameEngine.renderingSystem.addToScene(renderable.mesh);\n        this.entities.push(entity);\n        \n        return entity;\n    }\n    \n    createWall(position, material, rotation = null) {\n        const entity = this.gameEngine.createEntity();\n        \n        // Transform\n        const transform = this.gameEngine.world.acquireComponent(TransformComponent);\n        transform.setPosition(position.x, position.y, position.z);\n        if (rotation) {\n            transform.setRotation(rotation.x, rotation.y, rotation.z);\n        }\n        this.gameEngine.addComponent(entity, transform);\n        \n        // Renderable\n        const renderable = this.gameEngine.world.acquireComponent(RenderableComponent);\n        renderable.mesh = new THREE.Mesh(this.geometries.wall, material);\n        renderable.castShadow = true;\n        renderable.receiveShadow = true;\n        this.gameEngine.addComponent(entity, renderable);\n        \n        // Physics - Static Box Collider\n        const collider = this.gameEngine.world.acquireComponent(BoxColliderComponent);\n        collider.setSize(1, 5, 20);\n        collider.material = this.physicsMaterials.wood;\n        this.gameEngine.addComponent(entity, collider);\n        \n        const rigidbody = this.gameEngine.world.acquireComponent(RigidbodyComponent);\n        rigidbody.isStatic = true;\n        rigidbody.material = this.physicsMaterials.wood;\n        this.gameEngine.addComponent(entity, rigidbody);\n        \n        this.gameEngine.renderingSystem.addToScene(renderable.mesh);\n        this.entities.push(entity);\n        \n        return entity;\n    }\n    \n    createBouncingBall(position = null, material = null, physicsMaterial = null) {\n        const entity = this.gameEngine.createEntity();\n        \n        // Random position if not specified\n        const pos = position || {\n            x: (Math.random() - 0.5) * 20,\n            y: Math.random() * 10 + 5,\n            z: (Math.random() - 0.5) * 20\n        };\n        \n        // Transform\n        const transform = this.gameEngine.world.acquireComponent(TransformComponent);\n        transform.setPosition(pos.x, pos.y, pos.z);\n        this.gameEngine.addComponent(entity, transform);\n        \n        // Renderable\n        const renderable = this.gameEngine.world.acquireComponent(RenderableComponent);\n        const mat = material || this.materials.ball;\n        const radius = Math.random() * 0.5 + 0.5; // 0.5 to 1.0\n        const geometry = new THREE.SphereGeometry(radius, 12, 8);\n        renderable.mesh = new THREE.Mesh(geometry, mat);\n        renderable.castShadow = true;\n        this.gameEngine.addComponent(entity, renderable);\n        \n        // Physics - Rigidbody\n        const rigidbody = this.gameEngine.world.acquireComponent(RigidbodyComponent);\n        rigidbody.mass = radius; // Mass based on size\n        rigidbody.restitution = 0.7;\n        rigidbody.friction = 0.3;\n        rigidbody.material = physicsMaterial || this.physicsMaterials.rubber;\n        \n        // Add some initial velocity\n        rigidbody.velocity.x = (Math.random() - 0.5) * 5;\n        rigidbody.velocity.z = (Math.random() - 0.5) * 5;\n        \n        this.gameEngine.addComponent(entity, rigidbody);\n        \n        // Physics - Sphere Collider\n        const collider = this.gameEngine.world.acquireComponent(SphereColliderComponent);\n        collider.setRadius(radius);\n        collider.material = physicsMaterial || this.physicsMaterials.rubber;\n        this.gameEngine.addComponent(entity, collider);\n        \n        this.gameEngine.renderingSystem.addToScene(renderable.mesh);\n        this.entities.push(entity);\n        \n        return entity;\n    }\n    \n    createPhysicsBox(position, size = null, material = null, physicsMaterial = null) {\n        const entity = this.gameEngine.createEntity();\n        \n        const boxSize = size || { x: 1, y: 1, z: 1 };\n        \n        // Transform\n        const transform = this.gameEngine.world.acquireComponent(TransformComponent);\n        transform.setPosition(position.x, position.y, position.z);\n        this.gameEngine.addComponent(entity, transform);\n        \n        // Renderable\n        const renderable = this.gameEngine.world.acquireComponent(RenderableComponent);\n        const mat = material || this.materials.box;\n        const geometry = new THREE.BoxGeometry(boxSize.x, boxSize.y, boxSize.z);\n        renderable.mesh = new THREE.Mesh(geometry, mat);\n        renderable.castShadow = true;\n        renderable.receiveShadow = true;\n        this.gameEngine.addComponent(entity, renderable);\n        \n        // Physics - Rigidbody\n        const rigidbody = this.gameEngine.world.acquireComponent(RigidbodyComponent);\n        rigidbody.mass = boxSize.x * boxSize.y * boxSize.z; // Volume-based mass\n        rigidbody.restitution = 0.3;\n        rigidbody.friction = 0.5;\n        rigidbody.material = physicsMaterial || this.physicsMaterials.wood;\n        this.gameEngine.addComponent(entity, rigidbody);\n        \n        // Physics - Box Collider\n        const collider = this.gameEngine.world.acquireComponent(BoxColliderComponent);\n        collider.setSize(boxSize.x, boxSize.y, boxSize.z);\n        collider.material = physicsMaterial || this.physicsMaterials.wood;\n        this.gameEngine.addComponent(entity, collider);\n        \n        this.gameEngine.renderingSystem.addToScene(renderable.mesh);\n        this.entities.push(entity);\n        \n        return entity;\n    }\n    \n    // Demo modes\n    initializeMode(mode) {\n        // Clear existing dynamic objects\n        this.clearDynamicObjects();\n        \n        switch (mode) {\n            case 'bouncing-balls':\n                this.initBouncingBalls();\n                break;\n            case 'collision-test':\n                this.initCollisionTest();\n                break;\n            case 'stack-demo':\n                this.initStackDemo();\n                break;\n            case 'force-field':\n                this.initForceField();\n                break;\n            case 'friction-test':\n                this.initFrictionTest();\n                break;\n        }\n    }\n    \n    initBouncingBalls() {\n        // Create initial bouncing balls\n        for (let i = 0; i < 10; i++) {\n            this.createBouncingBall();\n        }\n    }\n    \n    initCollisionTest() {\n        // Create balls with different materials\n        const materials = [\n            { visual: this.materials.bouncy, physics: this.physicsMaterials.bouncy },\n            { visual: this.materials.rubber, physics: this.physicsMaterials.rubber },\n            { visual: this.materials.metal, physics: this.physicsMaterials.metal },\n            { visual: this.materials.ice, physics: this.physicsMaterials.ice }\n        ];\n        \n        materials.forEach((mat, i) => {\n            this.createBouncingBall(\n                { x: (i - 1.5) * 3, y: 8, z: 0 },\n                mat.visual,\n                mat.physics\n            );\n        });\n        \n        // Create some boxes to collide with\n        for (let i = 0; i < 5; i++) {\n            this.createPhysicsBox(\n                { x: (i - 2) * 4, y: 0.5, z: 5 },\n                { x: 1, y: 1, z: 1 },\n                this.materials.box\n            );\n        }\n    }\n    \n    initStackDemo() {\n        // Create a stack of boxes\n        for (let y = 0; y < 8; y++) {\n            for (let x = 0; x < 3; x++) {\n                this.createPhysicsBox(\n                    { x: (x - 1) * 1.1, y: y * 1.1 + 0.5, z: 0 },\n                    { x: 1, y: 1, z: 1 },\n                    this.materials.box\n                );\n            }\n        }\n        \n        // Add a heavy ball to knock it down\n        setTimeout(() => {\n            this.createBouncingBall(\n                { x: 10, y: 5, z: 0 },\n                this.materials.heavy,\n                this.physicsMaterials.metal\n            );\n        }, 2000);\n    }\n    \n    initForceField() {\n        // Create objects that will be affected by forces\n        for (let i = 0; i < 15; i++) {\n            const entity = this.createBouncingBall(\n                {\n                    x: (Math.random() - 0.5) * 15,\n                    y: Math.random() * 3 + 1,\n                    z: (Math.random() - 0.5) * 15\n                },\n                this.materials.light\n            );\n            \n            // Make them lighter for force field effect\n            const rigidbody = entity.getComponent('RigidbodyComponent');\n            rigidbody.mass = 0.1;\n            rigidbody.drag = 0.05;\n        }\n    }\n    \n    initFrictionTest() {\n        // Create ramps with different friction materials\n        const rampPositions = [\n            { x: -10, z: 0 },\n            { x: -3, z: 0 },\n            { x: 4, z: 0 },\n            { x: 11, z: 0 }\n        ];\n        \n        const rampMaterials = [\n            { visual: this.materials.ice, physics: this.physicsMaterials.ice },\n            { visual: this.materials.wood, physics: this.physicsMaterials.wood },\n            { visual: this.materials.rubber, physics: this.physicsMaterials.rubber },\n            { visual: this.materials.metal, physics: this.physicsMaterials.metal }\n        ];\n        \n        rampPositions.forEach((pos, i) => {\n            // Create ramp\n            const ramp = this.createPhysicsBox(\n                { x: pos.x, y: 1, z: pos.z },\n                { x: 3, y: 0.2, z: 6 },\n                rampMaterials[i].visual,\n                rampMaterials[i].physics\n            );\n            \n            // Rotate to make it a ramp\n            const transform = ramp.getComponent('TransformComponent');\n            transform.setRotation(0, 0, Math.PI / 8);\n            \n            // Add a ball at the top of each ramp\n            this.createBouncingBall(\n                { x: pos.x, y: 5, z: pos.z - 2 },\n                this.materials.ball\n            );\n        });\n    }\n    \n    update(deltaTime) {\n        // Auto-spawn objects in bouncing balls mode\n        if (this.currentMode === 'bouncing-balls') {\n            this.spawnTimer += deltaTime;\n            if (this.spawnTimer >= 1 / this.spawnRate && this.getDynamicObjectCount() < this.maxObjects) {\n                this.createBouncingBall();\n                this.spawnTimer = 0;\n            }\n        }\n        \n        // Apply force field in force-field mode\n        if (this.currentMode === 'force-field') {\n            this.updateForceField();\n        }\n        \n        // Update collider visualization\n        if (this.showColliders) {\n            this.updateColliderVisualization();\n        }\n    }\n    \n    updateForceField() {\n        const center = { x: 0, y: 2, z: 0 };\n        const forceStrength = 50;\n        \n        const dynamicEntities = this.entities.filter(entity => {\n            const rigidbody = entity.getComponent('RigidbodyComponent');\n            return rigidbody && !rigidbody.isStatic;\n        });\n        \n        for (const entity of dynamicEntities) {\n            const transform = entity.getComponent('TransformComponent');\n            const rigidbody = entity.getComponent('RigidbodyComponent');\n            \n            if (!transform || !rigidbody) continue;\n            \n            // Calculate force towards center\n            const dx = center.x - transform.position.x;\n            const dy = center.y - transform.position.y;\n            const dz = center.z - transform.position.z;\n            \n            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n            if (distance < 0.1) continue;\n            \n            const force = forceStrength / (distance * distance);\n            const fx = (dx / distance) * force;\n            const fy = (dy / distance) * force;\n            const fz = (dz / distance) * force;\n            \n            rigidbody.addForce(fx, fy, fz);\n        }\n    }\n    \n    updateColliderVisualization() {\n        // This would update wireframe visualization of colliders\n        // Implementation depends on having debug rendering system\n    }\n    \n    clearDynamicObjects() {\n        const toRemove = [];\n        \n        for (const entity of this.entities) {\n            const rigidbody = entity.getComponent('RigidbodyComponent');\n            if (rigidbody && !rigidbody.isStatic) {\n                toRemove.push(entity);\n            }\n        }\n        \n        for (const entity of toRemove) {\n            this.removeEntity(entity);\n        }\n    }\n    \n    removeEntity(entity) {\n        const renderable = entity.getComponent('RenderableComponent');\n        if (renderable?.mesh) {\n            this.gameEngine.renderingSystem.removeFromScene(renderable.mesh);\n        }\n        \n        const index = this.entities.indexOf(entity);\n        if (index > -1) {\n            this.entities.splice(index, 1);\n        }\n        \n        this.gameEngine.destroyEntity(entity);\n    }\n    \n    getDynamicObjectCount() {\n        return this.entities.filter(entity => {\n            const rigidbody = entity.getComponent('RigidbodyComponent');\n            return rigidbody && !rigidbody.isStatic;\n        }).length;\n    }\n    \n    // Input handling\n    onKeyPress(key) {\n        switch (key) {\n            case 'Space':\n                this.createBouncingBall({ x: 0, y: 10, z: 0 });\n                break;\n                \n            case 'KeyG':\n                this.toggleGravity();\n                break;\n                \n            case 'KeyC':\n                this.clearDynamicObjects();\n                break;\n                \n            case 'KeyM':\n                this.nextMode();\n                break;\n                \n            case 'KeyV':\n                this.toggleColliderVisualization();\n                break;\n                \n            case 'KeyR':\n                this.initializeMode(this.currentMode);\n                break;\n                \n            case 'Digit1':\n            case 'Digit2':\n            case 'Digit3':\n            case 'Digit4':\n            case 'Digit5':\n                const modeIndex = parseInt(key.slice(-1)) - 1;\n                if (modeIndex < this.modes.length) {\n                    this.setMode(this.modes[modeIndex]);\n                }\n                break;\n                \n            case 'KeyH':\n                this.showHelp();\n                break;\n        }\n    }\n    \n    onMouseClick(event, intersects) {\n        if (intersects.length > 0) {\n            const mesh = intersects[0].object;\n            const entity = this.entities.find(e => {\n                const renderable = e.getComponent('RenderableComponent');\n                return renderable?.mesh === mesh;\n            });\n            \n            if (entity) {\n                this.applyImpulseToEntity(entity, intersects[0].point);\n            }\n        }\n    }\n    \n    applyImpulseToEntity(entity, clickPoint) {\n        const rigidbody = entity.getComponent('RigidbodyComponent');\n        const transform = entity.getComponent('TransformComponent');\n        \n        if (!rigidbody || rigidbody.isStatic) return;\n        \n        // Apply upward impulse\n        const impulse = { x: 0, y: this.mouseForce, z: 0 };\n        rigidbody.addImpulse(impulse.x, impulse.y, impulse.z);\n        \n        console.log(`Applied impulse to entity ${entity.id}`);\n    }\n    \n    // Demo controls\n    nextMode() {\n        this.modeIndex = (this.modeIndex + 1) % this.modes.length;\n        this.setMode(this.modes[this.modeIndex]);\n    }\n    \n    setMode(mode) {\n        if (this.modes.includes(mode)) {\n            this.currentMode = mode;\n            this.modeIndex = this.modes.indexOf(mode);\n            this.initializeMode(mode);\n            console.log(`Switched to ${mode} mode`);\n        }\n    }\n    \n    toggleGravity() {\n        this.gravityEnabled = !this.gravityEnabled;\n        const physicsSystem = this.gameEngine.physicsSystem;\n        \n        if (this.gravityEnabled) {\n            physicsSystem.setGravity(0, -9.81, 0);\n        } else {\n            physicsSystem.setGravity(0, 0, 0);\n        }\n        \n        console.log('Gravity:', this.gravityEnabled ? 'ON' : 'OFF');\n    }\n    \n    toggleColliderVisualization() {\n        this.showColliders = !this.showColliders;\n        console.log('Collider visualization:', this.showColliders ? 'ON' : 'OFF');\n    }\n    \n    // Get demo statistics\n    getStats() {\n        const baseStats = this.gameEngine.getStats();\n        const physicsStats = this.gameEngine.physicsSystem?.getStats() || {};\n        \n        return {\n            ...baseStats,\n            demo: {\n                name: 'Physics Demo',\n                mode: this.currentMode,\n                totalObjects: this.entities.length,\n                dynamicObjects: this.getDynamicObjectCount(),\n                gravityEnabled: this.gravityEnabled,\n                showColliders: this.showColliders\n            },\n            physics: physicsStats\n        };\n    }\n    \n    showHelp() {\n        console.log(`\n⚡ Physics Demo Controls:\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\nModes:\n1-5: Switch demo modes\nM: Next mode\nR: Reset current mode\n\nInteraction:\nSpace: Spawn ball\nClick: Apply impulse\nG: Toggle gravity\nC: Clear objects\nV: Toggle collider viz\nH: Help\n\nCurrent Mode: ${this.currentMode}\nModes: ${this.modes.join(', ')}\n        `);\n    }\n    \n    // Cleanup\n    destroy() {\n        for (const entity of this.entities) {\n            const renderable = entity.getComponent('RenderableComponent');\n            if (renderable?.mesh) {\n                this.gameEngine.renderingSystem.removeFromScene(renderable.mesh);\n            }\n            this.gameEngine.destroyEntity(entity);\n        }\n        \n        Object.values(this.geometries).forEach(geo => geo.dispose());\n        Object.values(this.materials).forEach(mat => mat.dispose());\n        \n        console.log('Physics Demo destroyed');\n    }\n}";