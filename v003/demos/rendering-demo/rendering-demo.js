import { TransformComponent } from '../../components/TransformComponent.js';
import { RenderableComponent, LightComponent } from '../../components/RenderableComponent.js';

/**
 * Rendering Demo
 * Demonstrates advanced rendering features: LOD, instancing, lighting, shadows
 */
export default class RenderingDemo {
    constructor(gameEngine) {
        this.gameEngine = gameEngine;
        this.entities = [];
        this.instancedEntities = [];
        
        // Demo settings
        this.numInstancedCubes = 500;
        this.lodTestObjects = [];
        this.lights = [];
        
        // Animation
        this.time = 0;
        this.lightAnimationSpeed = 1.5;
    }
    
    async initialize() {
        console.log('Initializing Rendering Demo...');
        
        // Create materials and geometries
        this.materials = this.createMaterials();
        this.geometries = this.createGeometries();
        
        // Create ground\n        this.createGround();\n        \n        // Create LOD test objects\n        this.createLODObjects();\n        \n        // Create instanced cubes for performance testing\n        this.createInstancedCubes();\n        \n        // Create dynamic lighting\n        this.createDynamicLights();\n        \n        // Create some large objects for shadow testing\n        this.createShadowCasters();\n        \n        console.log(`Rendering Demo initialized with ${this.entities.length} entities`);\n    }\n    \n    createMaterials() {\n        return {\n            ground: new THREE.MeshLambertMaterial({ color: 0x2E7D32 }),\n            instancedCube: new THREE.MeshLambertMaterial({ color: 0x1976D2 }),\n            lodHigh: new THREE.MeshPhongMaterial({ color: 0xFF5722, shininess: 100 }),\n            lodMed: new THREE.MeshLambertMaterial({ color: 0xFF8A65 }),\n            lodLow: new THREE.MeshBasicMaterial({ color: 0xFFAB91 }),\n            shadowCaster: new THREE.MeshPhongMaterial({ color: 0x795548 }),\n            emissive: new THREE.MeshBasicMaterial({ color: 0xFFEB3B })\n        };\n    }\n    \n    createGeometries() {\n        return {\n            ground: new THREE.PlaneGeometry(100, 100),\n            cube: new THREE.BoxGeometry(1, 1, 1),\n            sphere: new THREE.SphereGeometry(1, 32, 16),\n            sphereLowPoly: new THREE.SphereGeometry(1, 16, 8),\n            sphereVeryLowPoly: new THREE.SphereGeometry(1, 8, 4),\n            tower: new THREE.CylinderGeometry(0.5, 1, 3, 8)\n        };\n    }\n    \n    createGround() {\n        const groundEntity = this.gameEngine.createEntity();\n        \n        const transform = this.gameEngine.world.acquireComponent(TransformComponent);\n        transform.setPosition(0, 0, 0);\n        transform.setRotation(-Math.PI / 2, 0, 0);\n        this.gameEngine.addComponent(groundEntity, transform);\n        \n        const renderable = this.gameEngine.world.acquireComponent(RenderableComponent);\n        renderable.mesh = new THREE.Mesh(this.geometries.ground, this.materials.ground);\n        renderable.receiveShadow = true;\n        renderable.castShadow = false;\n        this.gameEngine.addComponent(groundEntity, renderable);\n        \n        this.gameEngine.renderingSystem.addToScene(renderable.mesh);\n        this.entities.push(groundEntity);\n    }\n    \n    createLODObjects() {\n        // Create objects at different distances to test LOD\n        const distances = [5, 15, 30, 50];\n        \n        for (let i = 0; i < distances.length; i++) {\n            const entity = this.gameEngine.createEntity();\n            \n            const transform = this.gameEngine.world.acquireComponent(TransformComponent);\n            const angle = (i / distances.length) * Math.PI * 2;\n            transform.setPosition(\n                Math.cos(angle) * distances[i],\n                2,\n                Math.sin(angle) * distances[i]\n            );\n            this.gameEngine.addComponent(entity, transform);\n            \n            const renderable = this.gameEngine.world.acquireComponent(RenderableComponent);\n            \n            // Create LOD levels\n            renderable.addLodLevel(\n                new THREE.Mesh(this.geometries.sphere, this.materials.lodHigh),\n                0 // High detail for close distances\n            );\n            renderable.addLodLevel(\n                new THREE.Mesh(this.geometries.sphereLowPoly, this.materials.lodMed),\n                20 // Medium detail for medium distances\n            );\n            renderable.addLodLevel(\n                new THREE.Mesh(this.geometries.sphereVeryLowPoly, this.materials.lodLow),\n                40 // Low detail for far distances\n            );\n            \n            // Start with highest LOD\n            renderable.mesh = renderable.lodLevels[0].mesh;\n            renderable.castShadow = true;\n            renderable.receiveShadow = true;\n            \n            this.gameEngine.addComponent(entity, renderable);\n            this.gameEngine.renderingSystem.addToScene(renderable.mesh);\n            \n            this.entities.push(entity);\n            this.lodTestObjects.push(entity);\n        }\n        \n        console.log(`Created ${this.lodTestObjects.length} LOD test objects`);\n    }\n    \n    createInstancedCubes() {\n        // Create instanced mesh for performance\n        const instancedMesh = this.gameEngine.renderingSystem.createInstancedMesh(\n            this.geometries.cube,\n            this.materials.instancedCube,\n            this.numInstancedCubes\n        );\n        \n        instancedMesh.castShadow = true;\n        instancedMesh.receiveShadow = true;\n        \n        // Create entities for each instance\n        for (let i = 0; i < this.numInstancedCubes; i++) {\n            const entity = this.gameEngine.createEntity();\n            \n            const transform = this.gameEngine.world.acquireComponent(TransformComponent);\n            transform.setPosition(\n                (Math.random() - 0.5) * 80,\n                Math.random() * 5 + 0.5,\n                (Math.random() - 0.5) * 80\n            );\n            \n            // Add some rotation\n            transform.setRotation(\n                Math.random() * Math.PI,\n                Math.random() * Math.PI,\n                Math.random() * Math.PI\n            );\n            \n            // Add random scale variation\n            const scale = 0.5 + Math.random() * 1.5;\n            transform.setScale(scale, scale, scale);\n            \n            this.gameEngine.addComponent(entity, transform);\n            \n            const renderable = this.gameEngine.world.acquireComponent(RenderableComponent);\n            renderable.setInstanceId(i, instancedMesh);\n            this.gameEngine.addComponent(entity, renderable);\n            \n            this.entities.push(entity);\n            this.instancedEntities.push(entity);\n        }\n        \n        // Register with rendering system\n        this.gameEngine.renderingSystem.registerInstancedMesh('instanced_cubes', instancedMesh);\n        \n        console.log(`Created ${this.numInstancedCubes} instanced cubes`);\n    }\n    \n    createDynamicLights() {\n        // Create colored point lights that move around\n        const lightColors = [0xFF0000, 0x00FF00, 0x0000FF, 0xFFFF00, 0xFF00FF];\n        \n        for (let i = 0; i < lightColors.length; i++) {\n            const lightEntity = this.gameEngine.createEntity();\n            \n            const transform = this.gameEngine.world.acquireComponent(TransformComponent);\n            const angle = (i / lightColors.length) * Math.PI * 2;\n            transform.setPosition(\n                Math.cos(angle) * 10,\n                5,\n                Math.sin(angle) * 10\n            );\n            this.gameEngine.addComponent(lightEntity, transform);\n            \n            const lightComp = this.gameEngine.world.acquireComponent(LightComponent);\n            lightComp.type = 'point';\n            lightComp.color = lightColors[i];\n            lightComp.intensity = 0.8;\n            lightComp.range = 15;\n            lightComp.decay = 2;\n            lightComp.castShadow = true;\n            this.gameEngine.addComponent(lightEntity, lightComp);\n            \n            // Create visual representation of the light\n            const lightVisual = this.gameEngine.createEntity();\n            const visualTransform = this.gameEngine.world.acquireComponent(TransformComponent);\n            visualTransform.setPosition(\n                transform.position.x,\n                transform.position.y,\n                transform.position.z\n            );\n            visualTransform.setScale(0.2, 0.2, 0.2);\n            this.gameEngine.addComponent(lightVisual, visualTransform);\n            \n            const visualRenderable = this.gameEngine.world.acquireComponent(RenderableComponent);\n            const emissiveMaterial = this.materials.emissive.clone();\n            emissiveMaterial.color.setHex(lightColors[i]);\n            visualRenderable.mesh = new THREE.Mesh(this.geometries.sphere, emissiveMaterial);\n            visualRenderable.castShadow = false;\n            visualRenderable.receiveShadow = false;\n            this.gameEngine.addComponent(lightVisual, visualRenderable);\n            \n            this.gameEngine.renderingSystem.addToScene(visualRenderable.mesh);\n            \n            this.entities.push(lightEntity);\n            this.entities.push(lightVisual);\n            this.lights.push({ entity: lightEntity, visual: lightVisual, baseAngle: angle });\n        }\n        \n        console.log(`Created ${this.lights.length} dynamic point lights`);\n    }\n    \n    createShadowCasters() {\n        // Create tall objects that cast interesting shadows\n        for (let i = 0; i < 5; i++) {\n            const entity = this.gameEngine.createEntity();\n            \n            const transform = this.gameEngine.world.acquireComponent(TransformComponent);\n            transform.setPosition(\n                (Math.random() - 0.5) * 30,\n                1.5,\n                (Math.random() - 0.5) * 30\n            );\n            \n            const height = 2 + Math.random() * 4;\n            transform.setScale(1, height, 1);\n            \n            this.gameEngine.addComponent(entity, transform);\n            \n            const renderable = this.gameEngine.world.acquireComponent(RenderableComponent);\n            renderable.mesh = new THREE.Mesh(this.geometries.tower, this.materials.shadowCaster);\n            renderable.castShadow = true;\n            renderable.receiveShadow = true;\n            this.gameEngine.addComponent(entity, renderable);\n            \n            this.gameEngine.renderingSystem.addToScene(renderable.mesh);\n            this.entities.push(entity);\n        }\n        \n        console.log('Created shadow casting towers');\n    }\n    \n    update(deltaTime) {\n        this.time += deltaTime * this.lightAnimationSpeed;\n        \n        // Animate lights in circular patterns\n        for (let i = 0; i < this.lights.length; i++) {\n            const light = this.lights[i];\n            const angle = light.baseAngle + this.time + i * 0.5;\n            const radius = 10 + Math.sin(this.time * 0.5 + i) * 5;\n            const height = 3 + Math.sin(this.time * 0.7 + i * 1.5) * 2;\n            \n            const lightTransform = light.entity.getComponent('TransformComponent');\n            const visualTransform = light.visual.getComponent('TransformComponent');\n            \n            const x = Math.cos(angle) * radius;\n            const z = Math.sin(angle) * radius;\n            \n            lightTransform.setPosition(x, height, z);\n            visualTransform.setPosition(x, height, z);\n        }\n        \n        // Animate instanced cubes\n        this.animateInstancedCubes();\n        \n        // Test culling and LOD by checking what's visible\n        this.updateRenderingStats();\n    }\n    \n    animateInstancedCubes() {\n        // Animate a subset of instanced cubes for performance testing\n        const animatedCount = Math.min(50, this.instancedEntities.length);\n        \n        for (let i = 0; i < animatedCount; i++) {\n            const entity = this.instancedEntities[i];\n            const transform = entity.getComponent('TransformComponent');\n            \n            if (transform) {\n                // Floating motion\n                const originalY = transform.position.y;\n                const floatHeight = Math.sin(this.time * 2 + i * 0.3) * 0.5;\n                \n                // Gentle rotation\n                transform.rotate(0, deltaTime * 0.5, 0);\n                \n                transform.markDirty();\n            }\n        }\n    }\n    \n    updateRenderingStats() {\n        const renderStats = this.gameEngine.renderingSystem.getRenderStats();\n        \n        // Count visible entities\n        let visibleCount = 0;\n        for (const entity of this.entities) {\n            const renderable = entity.getComponent('RenderableComponent');\n            if (renderable && renderable.isVisible) {\n                visibleCount++;\n            }\n        }\n        \n        this.renderingStats = {\n            totalEntities: this.entities.length,\n            visibleEntities: visibleCount,\n            culledEntities: this.entities.length - visibleCount,\n            drawCalls: renderStats.drawCalls,\n            triangles: renderStats.triangles,\n            instancedCubes: this.numInstancedCubes\n        };\n    }\n    \n    // Test different rendering features\n    toggleWireframe() {\n        const wireframe = !this.materials.instancedCube.wireframe;\n        Object.values(this.materials).forEach(material => {\n            if (material.wireframe !== undefined) {\n                material.wireframe = wireframe;\n            }\n        });\n        console.log('Wireframe mode:', wireframe ? 'ON' : 'OFF');\n    }\n    \n    toggleShadows() {\n        const shadowsEnabled = !this.gameEngine.renderingSystem.renderer.shadowMap.enabled;\n        this.gameEngine.setSetting('shadows', shadowsEnabled);\n        console.log('Shadows:', shadowsEnabled ? 'ON' : 'OFF');\n    }\n    \n    changeLODBias(delta) {\n        this.gameEngine.renderingSystem.lodBias += delta;\n        this.gameEngine.renderingSystem.lodBias = Math.max(0.1, Math.min(5.0, this.gameEngine.renderingSystem.lodBias));\n        console.log('LOD Bias:', this.gameEngine.renderingSystem.lodBias.toFixed(2));\n    }\n    \n    // Get demo statistics\n    getStats() {\n        const baseStats = this.gameEngine.getStats();\n        \n        return {\n            ...baseStats,\n            demo: {\n                name: 'Rendering Demo',\n                rendering: this.renderingStats,\n                lodBias: this.gameEngine.renderingSystem.lodBias,\n                lightsCount: this.lights.length,\n                animationTime: this.time.toFixed(2)\n            }\n        };\n    }\n    \n    // Handle input events\n    onKeyPress(key) {\n        switch (key) {\n            case 'KeyW':\n                this.toggleWireframe();\n                break;\n            case 'KeyS':\n                this.toggleShadows();\n                break;\n            case 'BracketLeft': // [\n                this.changeLODBias(-0.1);\n                break;\n            case 'BracketRight': // ]\n                this.changeLODBias(0.1);\n                break;\n            case 'KeyL':\n                // Focus camera on a random light\n                if (this.lights.length > 0) {\n                    const randomLight = this.lights[Math.floor(Math.random() * this.lights.length)];\n                    this.gameEngine.focusCamera(randomLight.entity, { x: 5, y: 5, z: 5 });\n                }\n                break;\n        }\n    }\n    \n    // Cleanup\n    destroy() {\n        for (const entity of this.entities) {\n            const renderable = entity.getComponent('RenderableComponent');\n            if (renderable && renderable.mesh) {\n                this.gameEngine.renderingSystem.removeFromScene(renderable.mesh);\n            }\n            this.gameEngine.destroyEntity(entity);\n        }\n        \n        Object.values(this.geometries).forEach(geo => geo.dispose());\n        Object.values(this.materials).forEach(mat => mat.dispose());\n        \n        console.log('Rendering Demo destroyed');\n    }\n}