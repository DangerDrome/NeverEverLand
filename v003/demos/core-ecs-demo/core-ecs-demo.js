import { TransformComponent } from '../../components/TransformComponent.js';
import { RenderableComponent } from '../../components/RenderableComponent.js';
import { InputComponent } from '../../components/InputComponent.js';

/**
 * Core ECS Demo
 * Demonstrates basic ECS functionality, entity creation, and component management
 */
export default class CoreECSDemo {
    constructor(gameEngine) {
        this.gameEngine = gameEngine;
        this.entities = [];
        this.cubes = [];
        this.player = null;
        
        // Demo settings
        this.numEntities = 100;
        this.gridSize = 10;
        this.cubeSize = 1;
        
        // Animation
        this.time = 0;
        this.animationSpeed = 2;
    }
    
    async initialize() {
        console.log('Initializing Core ECS Demo...');
        
        // Create materials
        this.materials = this.createMaterials();
        
        // Create geometries
        this.geometries = this.createGeometries();
        
        // Create player entity
        this.createPlayer();
        
        // Create a grid of entities to test ECS performance
        this.createEntityGrid();
        
        // Focus camera on player
        this.gameEngine.focusCamera(this.player, { x: 0, y: 15, z: 15 });
        
        console.log(`Core ECS Demo initialized with ${this.entities.length} entities`);
    }
    
    createMaterials() {
        return {
            player: new THREE.MeshLambertMaterial({ color: 0xffe100 }), // Yellow player
            cube1: new THREE.MeshLambertMaterial({ color: 0x4CAF50 }), // Green
            cube2: new THREE.MeshLambertMaterial({ color: 0x2196F3 }), // Blue
            cube3: new THREE.MeshLambertMaterial({ color: 0xFF5722 }), // Red
            cube4: new THREE.MeshLambertMaterial({ color: 0x9C27B0 }), // Purple
            ground: new THREE.MeshLambertMaterial({ color: 0x8BC34A }) // Light green
        };
    }
    
    createGeometries() {\n        return {\n            cube: new THREE.BoxGeometry(this.cubeSize, this.cubeSize, this.cubeSize),\n            player: new THREE.BoxGeometry(this.cubeSize * 0.8, this.cubeSize * 1.2, this.cubeSize * 0.8),\n            ground: new THREE.PlaneGeometry(50, 50)\n        };\n    }\n    \n    createPlayer() {\n        // Create player entity\n        this.player = this.gameEngine.createEntity();\n        \n        // Add transform component\n        const transform = this.gameEngine.world.acquireComponent(TransformComponent);\n        transform.setPosition(0, this.cubeSize * 0.6, 0);\n        this.gameEngine.addComponent(this.player, transform);\n        \n        // Add renderable component\n        const renderable = this.gameEngine.world.acquireComponent(RenderableComponent);\n        renderable.mesh = new THREE.Mesh(this.geometries.player, this.materials.player);\n        renderable.castShadow = true;\n        renderable.receiveShadow = false;\n        this.gameEngine.addComponent(this.player, renderable);\n        \n        // Add input component for player control\n        const input = this.gameEngine.world.acquireComponent(InputComponent);\n        this.gameEngine.addComponent(this.player, input);\n        \n        // Add to scene\n        this.gameEngine.renderingSystem.addToScene(renderable.mesh);\n        \n        this.entities.push(this.player);\n        \n        console.log('Player entity created');\n    }\n    \n    createEntityGrid() {\n        const halfGrid = this.gridSize / 2;\n        const materials = [this.materials.cube1, this.materials.cube2, this.materials.cube3, this.materials.cube4];\n        \n        for (let x = 0; x < this.gridSize; x++) {\n            for (let z = 0; z < this.gridSize; z++) {\n                // Skip center position (for player)\n                if (x === Math.floor(halfGrid) && z === Math.floor(halfGrid)) {\n                    continue;\n                }\n                \n                const entity = this.gameEngine.createEntity();\n                \n                // Add transform component\n                const transform = this.gameEngine.world.acquireComponent(TransformComponent);\n                const worldX = (x - halfGrid) * (this.cubeSize + 0.5);\n                const worldZ = (z - halfGrid) * (this.cubeSize + 0.5);\n                transform.setPosition(worldX, this.cubeSize * 0.5, worldZ);\n                \n                // Add some random rotation\n                transform.setRotation(\n                    (Math.random() - 0.5) * 0.2,\n                    Math.random() * Math.PI * 2,\n                    (Math.random() - 0.5) * 0.2\n                );\n                \n                // Add some random angular velocity for animation\n                transform.angularVelocity = {\n                    x: (Math.random() - 0.5) * 0.5,\n                    y: (Math.random() - 0.5) * 1.0,\n                    z: (Math.random() - 0.5) * 0.5\n                };\n                \n                this.gameEngine.addComponent(entity, transform);\n                \n                // Add renderable component\n                const renderable = this.gameEngine.world.acquireComponent(RenderableComponent);\n                const materialIndex = (x + z) % materials.length;\n                renderable.mesh = new THREE.Mesh(this.geometries.cube, materials[materialIndex]);\n                renderable.castShadow = true;\n                renderable.receiveShadow = true;\n                \n                this.gameEngine.addComponent(entity, renderable);\n                \n                // Add to scene\n                this.gameEngine.renderingSystem.addToScene(renderable.mesh);\n                \n                this.entities.push(entity);\n                this.cubes.push(entity);\n            }\n        }\n        \n        // Create ground plane\n        this.createGround();\n        \n        console.log(`Created ${this.cubes.length} cube entities in ${this.gridSize}x${this.gridSize} grid`);\n    }\n    \n    createGround() {\n        const groundEntity = this.gameEngine.createEntity();\n        \n        // Add transform component\n        const transform = this.gameEngine.world.acquireComponent(TransformComponent);\n        transform.setPosition(0, 0, 0);\n        transform.setRotation(-Math.PI / 2, 0, 0); // Rotate to be horizontal\n        this.gameEngine.addComponent(groundEntity, transform);\n        \n        // Add renderable component\n        const renderable = this.gameEngine.world.acquireComponent(RenderableComponent);\n        renderable.mesh = new THREE.Mesh(this.geometries.ground, this.materials.ground);\n        renderable.receiveShadow = true;\n        renderable.castShadow = false;\n        this.gameEngine.addComponent(groundEntity, renderable);\n        \n        // Add to scene\n        this.gameEngine.renderingSystem.addToScene(renderable.mesh);\n        \n        this.entities.push(groundEntity);\n        \n        console.log('Ground plane created');\n    }\n    \n    // Demo-specific update logic\n    update(deltaTime) {\n        this.time += deltaTime * this.animationSpeed;\n        \n        // Animate cubes with sine wave motion\n        for (let i = 0; i < this.cubes.length; i++) {\n            const entity = this.cubes[i];\n            const transform = entity.getComponent('TransformComponent');\n            \n            if (transform) {\n                // Add floating motion\n                const originalY = this.cubeSize * 0.5;\n                const floatHeight = Math.sin(this.time + i * 0.5) * 0.5;\n                transform.position.y = originalY + floatHeight;\n                \n                // Mark as dirty to trigger matrix update\n                transform.markDirty();\n            }\n        }\n        \n        // Test ECS performance by querying components\n        this.performECSQueries();\n    }\n    \n    performECSQueries() {\n        // Query different component combinations to test performance\n        const transforms = this.gameEngine.query(['TransformComponent']);\n        const renderables = this.gameEngine.query(['RenderableComponent', 'TransformComponent']);\n        const inputEntities = this.gameEngine.query(['InputComponent']);\n        \n        // Store for debug display\n        this.queryResults = {\n            transforms: transforms.length,\n            renderables: renderables.length,\n            inputEntities: inputEntities.length\n        };\n    }\n    \n    // Test dynamic entity creation and destruction\n    testEntityLifecycle() {\n        // Create a temporary entity\n        const tempEntity = this.gameEngine.createEntity();\n        \n        const transform = this.gameEngine.world.acquireComponent(TransformComponent);\n        transform.setPosition(\n            (Math.random() - 0.5) * 20,\n            2,\n            (Math.random() - 0.5) * 20\n        );\n        this.gameEngine.addComponent(tempEntity, transform);\n        \n        const renderable = this.gameEngine.world.acquireComponent(RenderableComponent);\n        renderable.mesh = new THREE.Mesh(this.geometries.cube, this.materials.cube1);\n        this.gameEngine.addComponent(tempEntity, renderable);\n        \n        this.gameEngine.renderingSystem.addToScene(renderable.mesh);\n        \n        // Destroy after 2 seconds\n        setTimeout(() => {\n            this.gameEngine.renderingSystem.removeFromScene(renderable.mesh);\n            this.gameEngine.destroyEntity(tempEntity);\n            console.log('Temporary entity destroyed');\n        }, 2000);\n        \n        console.log('Temporary entity created - will be destroyed in 2 seconds');\n    }\n    \n    // Get demo statistics\n    getStats() {\n        const baseStats = this.gameEngine.getStats();\n        \n        return {\n            ...baseStats,\n            demo: {\n                name: 'Core ECS Demo',\n                totalEntities: this.entities.length,\n                cubeEntities: this.cubes.length,\n                queryResults: this.queryResults,\n                animationTime: this.time.toFixed(2)\n            }\n        };\n    }\n    \n    // Handle input events\n    onKeyPress(key) {\n        switch (key) {\n            case 'KeyT':\n                this.testEntityLifecycle();\n                break;\n            case 'KeyC':\n                // Focus camera on a random cube\n                if (this.cubes.length > 0) {\n                    const randomCube = this.cubes[Math.floor(Math.random() * this.cubes.length)];\n                    this.gameEngine.focusCamera(randomCube, { x: 0, y: 10, z: 10 });\n                }\n                break;\n            case 'KeyP':\n                // Focus back on player\n                this.gameEngine.focusCamera(this.player, { x: 0, y: 15, z: 15 });\n                break;\n            case 'KeyR':\n                // Reset all cube rotations\n                for (const cube of this.cubes) {\n                    const transform = cube.getComponent('TransformComponent');\n                    if (transform) {\n                        transform.setRotation(0, 0, 0);\n                    }\n                }\n                break;\n        }\n    }\n    \n    // Cleanup\n    destroy() {\n        // Remove all entities\n        for (const entity of this.entities) {\n            const renderable = entity.getComponent('RenderableComponent');\n            if (renderable && renderable.mesh) {\n                this.gameEngine.renderingSystem.removeFromScene(renderable.mesh);\n            }\n            this.gameEngine.destroyEntity(entity);\n        }\n        \n        // Dispose geometries and materials\n        Object.values(this.geometries).forEach(geo => geo.dispose());\n        Object.values(this.materials).forEach(mat => mat.dispose());\n        \n        console.log('Core ECS Demo destroyed');\n    }\n}